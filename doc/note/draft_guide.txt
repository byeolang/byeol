indep 모듈
##########

WHEN 매크로
===========
byeol은 프로젝트 전체적으로 early-return pattern을 적용 하고 있다.
이는 코드의 흐름을 알기 쉽게 해주며 block 문 depth를 줄여주는 이점이 있다.
단점이라면 `if(checks) return res;` 와 같은 식으로 사용하기 때문에 `if` 바로 보고
이 코드가 branching을 위한 if 인지 아니면 return하려고 하는 if인지 구분이 되지 않는
다는 점과 `if(checks)` 뒤에 블록문이 오게 되는 경우 가독성이 떨어진다는 점이다.
다음과 같은 코드를 보면 좀 체감이 될 것이다.

@code
    str me::eval(const args& a) {
        std::string key = _makeKey(a);
        if(key.empty()) {
            BY_E("key is empty");
            return tstr<obj>();
        }
        if(_isSelfMaking(key)) {
            BY_E("error: you tried to clone self generic object.");
            return tstr<obj>();
        }

        if(!_cache.count(key))
            _makeGeneric(key, params::make(_paramNames, a));

        return _cache[key];
    }
@endcode

WHEN 매크로는 이 부분을 해결하는 것으로 WHEN은 early-return pattern 시에만 사용된다.
또한 90% 이상의 early-return은 에러 발견시 로그를 찍고 에러 값을 내보내는 것 뿐이라는
것에 착안해서 그 2가지 과정을 한 줄에 표현할 수 있도록 chaining을 지원한다.
결과 다음과 같이 코드가 간략해지고 if의 목적이 명확해진다.

@code
    str me::eval(const args& a) {
        std::string key = _makeKey(a);
        WHEN(key.empty()).err("key is empty").ret(tstr<obj>());
        WHEN(_isSelfMaking(key)).err("error: you tried to clone self generic object.").ret(tstr<obj>());

        if(!_cache.count(key)) _makeGeneric(key, params::make(_paramNames, a));
        return _cache[key];
    }
@endcode

WHEN 매크로는 프로젝트 내에서 아주 빈번하게 사용되므로 잘 파악해 두는 게 좋다.




fsystem 클래스
==============
fsystem은 지정한 폴더에서 파일을 재귀적으로 탐색하는 간단한 클래스다.
윈도우와 posix 계열 운영체제에서 모두 사용가능한 플랫폼 독립적인 API를 제공한다.
핵심 API는 iterator 클래스를 통해 이뤄진다.

사용 예제는 아래와 같다.
@code
auto e = fsystem::find("../your/path");
while(e.next()) { // 모든 파일을 탐색하면 false를 반환한다.
    const std::string& path = *e; // 찾은 파일의 경로
    if(*e == "../your/path/child/helloWorld.cpp") // 항상 상대경로를 사용한다.
        doSomething(e->getDir()); // 찾은 파일의 folder 경로를 반환한다.
}
@end code

# 항상 파일만을 iterate 한다.
빈 폴더가 있다면 해당 폴더는 iterate시 skip 된다.


buildFeature 클래스
===================
CMake에 의해서 자동으로 생성되는 buildInformation.hpp 에 정의된 정보를 반환하는 클래스다.
절대 수동으로 값을 변경해서는 안된다.
빌드 일시, 버전, 빌드한 OS, 바이너리 타입에 대한 정보를 갖는다.
buildInformation.hpp에 값의 원본이 #define으로 정의되어 있으므로, 필요하다면 이를 사용해도 된다.
#ifdef시에도 종종 사용되니 참고하라.

예:
@code

    if(buildFeature::config::isDbg())
        platformAPI::unlimitCoreDump();

// 혹은,

#ifdef BY_BUILD_PLATFORM_IS_WINDOWS
...
#endif

@endcode

@section byeol의 아키텍처는 플랫폼 종속적인 코드는 반드시 `indep` 모듈에 속해야 한다.
따라서 indep 보다 상위의 모듈에서 함부로 OS에 대한 #ifdef의 조건부 컴파일이나 buildFeature::platform::getName() 을
사용해서 코드를 branch 하는 건 권장하지 않는다.


cpIter 클래스
=============
문자열에 대해서 codepoint 기반의 iteration을 담당한다.
주로 @ref nStr 에서 UTF8 unicode와 같은 multibyte 문자열을 순회할 때 사용한다.
일반적인 iterator 답게, 전위 증가 및 후위증가연산자, 역참조 연산자, bool 형변환 연산자 등을 지원한다.
cpIter를 생성할때 순회할 문자열과 함께 기본 iteration의 방향을 지정할 수 있다.

@remark cpIter 생성시 입력한 방향은 iter 자체의 기본 방향과 초기 위치를 정의한 것이다.
reverse = true로 argument로 주면 cpIter는 문자열 끝에서 역방향으로 출발한다.
그러나 이때 stepBackward()나 stepForward()를 명시적으로 호출하면, 이 기본 방향과 관계없이 해당 방향으로 전진한다.


@remark STL과 마찬가지로 begin은 첫번째 원소를 가리키지만, end는 마지막 원소의 다음 위치를 가리킨다. (past-the-end)
따라서 역방향 순회시에는 먼저 next()를 해야만 한다.


사용 예제는 다음과 같다.
@code
    std::string src = "abcd🏁efg"; // UTF8에서 🏁는 3개의 character로 표현된다.
    cpIter e4(src, true); // 기본 iteration 을 역방향으로 정의한다. 이때 마지막 원소의 다음 위치를 가리킨다.
    while(*e4 != "") // 현재 end 위치에 있으므로, 이때는 ""가 반환된다.
        ++e4; // e4.next()를 호출한 것과 같다. 이때 기본 iteration 방향인 역방향으로 순회한다.
              // 하지만 실제로 이 코드는 한번도 실행되지 않는다.
    ASSERT_EQ(*e4, "");

    std::string expects[] = {"g", "f", "e", "🏁", "d", "c", "b", "a"};
    for(int n = 0; n < 8; n++) {
        e4.stepBackward(1); // 명시적으로 방향을 지정해서 iterator를 순회한다. e4의 방향과 관계없이 무조건 역방향으로 순회한다.
        // 역방향시에는 이처럼 step을 먼저해야한다.
        ASSERT_EQ(*e4, expects[n]);
    }
@endcode


dlib 클래스
===========
dynamic loading for library 의 약자다. 플랫폼 독립적인 동적 로딩을 담당한다.
라이브러리의 메모리 적재, 원하는 함수을 찾아 함수포인터로 변환할 수 있다.
다음과 같이 사용한다.
1. dlib 객체를 생성한다.
2. 로딩할 라이브러리의 위치를 지정한다.
3. 함수명을 통해 원하는 함수를 찾아 함수포인터로 받는다.

@remark @ref tmay를 사용하므로 tmay를 사전에 익혀두는 걸 권장한다.


@remark dlib은 RAII idium으로 구현되어 있다. 해당 인스턴스가 소멸될때 외부로 반환된 함수포인터는 사용할 수 없게 된다.


사용예제는 다음과 같다.
@code
    dlib lib = dlib(path); // 1번과 2번을 동시에 한다.
    auto res = lib.load(); // `res` evaluated as true when it has an error.
    WHEN(res) .err("couldn't open %s slot: %d", path, res.get()).ret((rel(), false));

    typedef void (*entrypointFunc)(bicontainable*);
    constexpr const nchar* ENTRYPOINT_NAME = "byeol_bridge_cpp_entrypoint";
    auto info = lib.accessFunc<entrypointFunc>(ENTRYPOINT_NAME); // 결과는 tmay로 받는다.
    WHEN(!info.has()) // tmay의 has()로 결과 체크 중
        .err("couldn't access entrypoint of %s slot: %d", path, info.getErr()).ret((rel(), false));

    (*info)(&tray); // 정상적으로 함수를 가져오면, 호출이 가능하다.

    // lib이 소멸되면서 자동으로 메모리가 해제된다.
@endcode


end 클래스
==========
코드 실행을 지연시킨다. 다른 언어에서 `defer` 와 같은 키워드와 같은 역할이다.


platformAPI 클래스
==================
단발성으로 호출되는, 플랫폼 종속적인 API들을 독립적으로 제공하는 일종의 완충작용을 한다.
예를들면 텍스트 출력시 색깔을 입히려면 posix 계열 플랫폼에서는 ANSI escape sequence를 사용하지만
윈도우에서는 WINAPI를 사용해야 한다.
이때 platformAPI::foreColor()를 사용하면,

@code
    cout << foreColor(LIGHTGRAY) << "(" << foreColor(YELLOW) << _encodeNewLine(rightName)
         << foreColor(LIGHTGRAY) << ")";
@endcode

와 같이 사용하면 플랫폼 독립적인 코드를 작성하게 된다.


tmay 클래스
===========
값으로 반환하는 함수에 대해 속도가 느린 exception을 사용하지 않고도 에러임을 알려주는 클래스다.
std::optional<T>과 거의 동일하다. API look을 프로젝트 컨벤션에 맞춘것에 가깝다.

정상동작일 경우 tmay의 생성자로 값을 T&로 넘기면 된다.
에러상황일 경우 tmedium 클래스를 nullptr로 생성해서 넘기면 된다.

@remark 왜 @ref tmedium을 사용하는지는 해당 클래스를 참조.


@remark `has()` 나 `get()`, `rel()`, `set()` 함수를 제공하는데, 이는 프로젝트 전반적으로 많이 사용되는 네이밍 컨벤션이다.


tres 클래스
===========
tmay와 동일하나, 에러일 경우, 원하는 에러 타입을 갖도록 정의할 수 있다.
예를들어 tmay<A>는 에러인지 아닌지만 알 수 있지만, tres<A, std::string>으로 정의하면 에러일 경우, 어떤 에러인지
메시지도 알 수 있도록 만들 수 있다.






clog 모듈
#########

filters 클래스
==============
@ref logger 클래스에서 등록된 @ref filterable 클래스들을 관리한다.
filterable과 동일한 API를 가지며, 해당 API를 호출하면 소유한 모든 filterable에 해당 API를 호출한다.


filterable 클래스
==============
@ref logger 클래스가 특정한 조건에 해당 하는 logging은 필터링 할 수 있게 해준다.
`filt()` 함수를 제공하며, parameter로 주어진 Log 정보에 대해 true를 반환할 경우 해당 Log는 @ref stream 에 올려지지 않는다.


errPassFilter 클래스
==============
말그대로 err만 통과시키는 @ref filterable 클래스다. 이 filter를 @ref logger에 등록하면 warning이나 info는 출력되지 않는다.
직접 사용하지 않으며, 객체 생성하여 logger에 add 하는 용도로 사용한다.


enablesZone 클래스
==============
@ref logger 클래스는 여러개의 @ref stream을 가지고 있고 특정 stream을 disable 혹은 enable 함으로써 출력되는 경로를 제어할 수 있다.
여기서 문제는 특정 코드 블록 혹은 함수에서만 stream을 제어 한 후, 블록을 벗어날 때는 원래 상태로 되돌리고자 하는 경우가
매우 자주 일어난다.
enablesZone 은 이럴때 사용하는 것으로, RAII idium으로 구현되어 있어서, 객체 생성과 동시에 stream의 enable 상태를 기록했다가
enablesZone이 소멸될때 각 stream의 enable 여부를 초기상태로 되돌린다.
보통은 다음과 같이 사용한다.

@code
    // let's assume that all streams in logger are enabled.

    {
        enablesZone zone;
        logger& log = logger::get();
        log.getStream(0).setEnable(false); // 0번째 stream을 disable.
        logger::getStream("consoleStream").setEnable(false); // console로 logging 하지 않도록 disable.
        BY_E("error message1"); // 이 로그는 0번 stream과 console로는 로깅되지 않는다.

        logger::setEnable(false); // 모든 stream을 disable.
        BY_E("this message won't log on any stream");

    }

    BY_E("this message will definitely be log on entire stream");
@endcode


logger 클래스
==============
logger 클래스는 @stream 이라고 불리는 복수의 로깅 경로를 통해 체계적으로 로깅이 가능한 경량화된 c++ 로깅 프레임워크의 일종의 focade다.
일반적으로는 동봉되는 매크로를 통해, 다음과 같이 사용한다.

@code
    BY_I("slot[%s] origins loaded.", getName());
@endcode

위 코드는 다음과 같이 출력된다.

    Oct 22 2025  21:26:13 I cppPackLo <_loadLibs#49> slot[cpp] origins loaded.

위 로그는 다음과 같은 정보를 보여준다.

1. 로깅한 날짜(Oct 22 2025)와 시간(21:26:13)
2. 로그 레벨(I, Info).
   로그 레벨은 ERR, WARN, INFO 총 3개가 존재한다.
3. 로깅한 클래스명(cppPackLoading)
4. 로깅한 함수(_loadLibs)와 해당 파일내 라인번호(49)
5. 로그 메시지(slot[cpp] origins loaded)

기본적인 사용법은 여기까지만 알아도 충분하다.
다음은 logger 클래스 개발자로써 필요한 정보를 설명한다.


@section stream 클래스
먼저 clog 모듈의 핵심은 @ref stream 이다.
stream은 쉽게 말해 로깅이 출력되는 스트림, 즉 목적지를 표현한다.
현재는 @ref consoleStream 과 @ref fileLogStream 2가지가 존재한다.
모든 stream은 기본적으로 logger 클래스가 처음부터 소유하고 있다.

각 stream은 byeol 의 기본적인 단위 클래스와 마찬가지로
> RELEASED ---init()---> INITIALIZED
> RELEASED <--rel()----- INITIALIZED

위와 같은 state를 도식을 갖는다.
객체를 처음 생성하면 자동으로 init() 상태로 진입한다.
단, 특정 stream 인스턴스를 명시적으로 rel() 한 경우는, 다시 명시적으로 init()을 하지 않으면
정상적으로 동작하지 않는다.

stream은 또한 enable 여부를 관리한다. setEnable(false)를 통해 특정 stream을 disable 시키면
해당 stream은 동작하지 않는다.

또하나 중요한 점은 logger 클래스 자체도 stream에서 상속하기 때문에 stream과 동일한 API를
제공한다는 점이다.
logger는 각 API에 대해 소유한 모든 stream들에 대해 redirection 하는 구성으로 구현되어있다.
예를들어 `logger::get().setEnable(false)`를 하게 되면, 모든 stream이 disable 된다.

stream은 logBypass(const nchar*) 라는 함수를 제공하는데, 이것은 어떠한 가공도 없이 문자열을
그대로 지정한 stream으로 로그 메시지를 보낸다.


@section macro
앞서 언급한 `logByPass()`를 통해서 직접 로깅을 해도 되지만, 파일명이나 함수명, 라인번호 등
좀 더 고급스러운 로깅을 하고 싶다면 로깅 매크로를 사용하면 된다.
다음과 같이 사용한다.
@code
    BY_I("just message.")
@endcode

Byeol 매크로 컨벤션에 따라 매크로는 항상 `BY_` prefix로 시작한다.
뒤에는 로그 레벨인 `I`가 나오며, 매크로 안쪽에는 로깅할 메시지가 들어간다.
위와 같이 로깅할 경우 다음과 같이 출력된다.

> Oct 22 2025  21:26:13 I cppPackLo <_loadLibs#49> just message.

로그 레벨은 Error, Warning, Info, 3개가 존재하며, 각각 매크로도 3개가 존재한다.
또한 만약 디버그 바이너리에서만 로그를 출력하고 싶다면 레벨 앞에 `D`를 붙인다.
이를테면 다음과 같다.
@code
    BY_DE("leaf: ERR: %s", e);
@endcode

위 코드는 printf에서 익숙하게 봤을 서식문자를 사용하고 있다. 이렇게 동적인 값을 집어넣는 것도 가능하다.
결과는 다음과 같이 출력된다.

    Oct 22 2025  21:26:13 E leafPars <_finalize#263> leaf: ERR: src is empty

해당 macro의 구현은, 출력할 문자열 앞에 날짜나 시간 등을 붙여서 logBypass()에 전달하도록 expand 하는 것이긴 하나,
그외에도 한가지 중요한 기능이 더 있다.
@ref richLog 라는 기능으로, 서식문자에 입력된 argument를 다형성을 활용해서 적절한 타입으로 변환해서 로깅하는 기능이다.
이를 사용하면 다음과 같은 코드가 가능해진다.

> BY_I("make a closure for %s.%s", meObj, cast.getSrc().getName());

결과는 다음과 같이 나올 수 있다.

> Oct 22 2025 22:01:12 I closure <_make#73> make a closure for obj.foo

meObj은 tstr<obj> 라는 타입이고, getName()은 std::string을 반환하지만 양쪽 모두 적절하게 문자열로 변환해서 로깅이 된다.
단 주의할 점은, `%d` 인지 `%s`를 써야 하는지 타입마다 다를 수 있다는 점이다. (하지만 대부분 scalar type을 제외하고는 %s를 사용한다.)
어떤 서식문자를 써야 하는지 알아내는 법은 추후 서술한다.
clog 모듈은 architecture 상 아랫부분에 위치하기 때문에 clog에 종속하는 클래스가 뭐가 있는지 알아서는 안된다.
그렇기 때문에 richLog는 각 모듈마다 정의되어 있으며, 해당 모듈에 포함된 클래스를 어떻게 문자열로 변환할지를 정의해두고 있다.


@section 간략화된 주소값
richLog로 void*를 넘기게 되면 `indep` 모듈에 있는 @ref platformAPI를 사용해서 `toAddr()`를 호출한다.
이 함수는 void*를 마지막 4 hex값을 문자열로 변환하는 함수이며, 프로젝트 내에서 주로 `@` 뒤에 적는 스타일이다.
예를 들면 다음과 같이 로깅 된다.

> Nov 18 2025  20:02:13 I verifier  <onLeave#87> '' assignExpr@9a50: step#1 --> set evalType

위 로그에서 assignExpr@9a50은 assignExpr 객체가 heap 주소의 끝자리가 9a50인 곳에
있는 인스턴스라는 얘기다.
이는 동일한 타입에 대해 서로 다른 인스턴스가 같은 시점에 로깅되는 경우 좀 더 수월하게
디버깅 하도록 돕는다.


@section filterable
각 stream에 전달될 로그 메시지를, 특정한 조건으로 필터링 할 수 있게 해준다.
@ref filterable은 `filt()` 함수를 통해, 메시지의 적합성을 판단해 필터링할 것인지를 결정한다.
logger 클래스의 `setFilters(const filters&)` 를 통해서 filterable을 추가할 수 있다.

예를들어 @ref errPassFilter 는 @ref errLv 이 ERR일때만 통과시키는 필터다.
다음과 같이 사용할 수 있다.
@code
    const filters& prevFilters = logger::get().getFilters();
    filters fs(new errPassFilter());
    logger::get().setFilters(fs);

    // doSomething..

    logger::get().setFilters(prevFilters);
@endcode


richLog 클래스
==============
서식문자에 입력된 argument를 다형성을 활용해서 적절한 타입으로 변환해서 로깅하는 기능이다.
clog 모듈은 architecture 상 아랫부분에 위치하기 때문에 clog에 종속하는 클래스가 뭐가 있는지 알아서는 안된다.
그렇기 때문에 richLog는 각 모듈마다 정의되어 있으며, 해당 모듈에 포함된 클래스를 어떻게 문자열로 변환할지를 정의해두고 있다.

richLog는 크게 __convert__ 부분과 unwrap 2부분으로 나뉘어져 있다.

@section __convert__()
각 모듈에 속한 클래스를 어떻게 로깅하기 쉬운 타입으로 변경할지를 정의한다.
호출자는 __convert__()에 자신이 받은 구체타입을 넣을 뿐이며, 오버로딩에 의해서 가장 적절한 타입에 대한 __convert__가 호출된다.
그 말은, 범용적인 __convert__()와 특정 타입에 특화된 __convert__()를 동시에 정의할 수 있다는 말이다.
대표적으로는 __convert__(void*)가 있다. 어떠한 T*에도 매칭 되지 않으면 이 __covert__가 대신 호출된다.


@section wrap
wrap이 필요한 이유는 richLog() 안쪽에서 __convert__()를 호출하고 이때 전달받은 값들을 가변인자를 통과할 수 있도록 풀어주는
역할을 한다.
가변인자 함수는 scalar type이나 T*만 넘길 수 있기 때문에 값으로는 넘길 수 없다.
일부 __convert__()는 안에서 새로운 값을 만들어 값으로 넘겨야 하는 상황도 있을 수 있기 때문에
logger::log()가 가변인자로 구성되어 있는 한은 wrap이 꼭 필요하다.

__convert__() 함수들은 크게 @ref strWrap 혹은 @ref noWrap<T> 2가지 중 하나를 반환형으로 정의하는데
noWrap은 아무런 가공없이 받은 걸 그대로 반환하지만 strWrap은 std::string::c_str()를 내부적으로 호출한다.






meta 모듈
#########

adam 클래스
===========
@ref type 의 클래스 계층구조 상 아무런 부모도 없는 메타타입은 범용적으로 다루기가 어렵다.
예를들어 모든 메타타입에 대해서 동작하는 함수를 작성하고자 한다면, 다음과 같은 코드를 작성할 수 있어야 한다.
@code
    const auto& types = how_to_get_all_meta_types() // ?
    for(const auto& t : types)
        cout << t.getName() << "\n";

    vector<type> how_to_get_all_meta_types() {
        // 모든 타입들을 순회해서 가져올 방법이 없다.
        // 그러니 다음과 같이 해야한다?
        vector<type> ret;
        ret.push_back(ttype<A>());
        ret.push_back(ttype<B>());
        ...

        return ret;
    }
@endcode

이를 해결하고자 메타 정보를 구성할때 어떠한 부모클래스도 없는 클래스라면 부모를 adam으로 정의한다.
이제 다음과 같이 작성할 수 있게 된다.
@code
    for(const auto& t : ttype<adam>().getSubs())
        cout << t.getName() << "\n";
@endcode


ttype<T> 클래스
===============
사용자가 메타 정보를 다루고자할때 진입점이 되는 클래스다.
ttype<T>를 사용할때는 매번 객체를 생성해서 사용해야 한다. 전체적으로 monostate 패턴으로 설계 되어있어서
매번 객체를 만들어 사용하지라도 값은 공유하기 때문에 추가비용은 들지 않는다.

meta 모듈의 전체적인 설계에 대해 파악하고자 한다면 핵심이 되는 @ref type 를 먼저 살펴보자.


type 클래스
===========
meta 모듈의 핵심이 되는 클래스다. type에 대한 다음의 기본적인 API를 제공한다.

@section 기본 타입 식별과 관련된 정보를 제공한다.
isTemplate(): 템플릿 클래스 여부를 반환한다.
isAbstract(): 추상 클래스 여부를 반환한다.
getName(): 클래스명을 반환한다. 이름은 demangle 되어 반환된다.


@section 클래스 계층과 관련된 정보를 제공한다.
getSupers(): super class들을 리스트에 담아 반환한다.
이 클래스의 직접적인 부모 클래스는 리스트 마지막 원소에, 보다 더 super class일 수록 리스트 앞에 담겨있다.
예를들어 다음과 같은 코드를 보자.
@code
    const auto& supers = getType().getSupers();

    // 가장 첫번째 클래스는 항상 adam 이 된다. adam 클래스 참조.
    supers[0].getName() // "adam"

    supers.last()->getName() // this 클래스의 부모클래스 이름이 나온다.
@endcode

getSubs(): sub class들을 리스트에 담아 반환한다. getSupers()와 마찬가지 방식으로, 가까운 sub 일 수록 리스트 앞에 담겨있다.
isSuper(const rhs& type): this class가 rhs보다 super 클래스 인지 체크한다.
dynamic_cast과 동일한 기능이지만 알고리즘 복잡도가 더 뛰어나다. 일반적으로 dynamic_cast는 vtable을 순회해서 체크한다.
반면 meta 는 메타 정보 생성시 super 클래스 계층도를 통해서 자신이 몇 tier의 자손인지를 바로 알 수 있다.
이 tier값과 char* 의 주소값을 비교해서 타입정보를 비교한다.
isSub(cosnt rhs& type)


@section 인스턴스 생성 함수를 제공한다.
make(): 이 type의 기본생성자로 인스턴스를 생성한다.
만약, 기본생성자가 없다면 nullptr가 반환되니 주의.


@section 메타 타입 정보 관리
init()으로 초기화를, rel()로 해제를 한다.
이는 @ref BY_INIT_META 매크로를 통해서 자동으로 처리가 되는 부분이라 외부에서 직접 호출할 경우는 드물다.


@section 메타 정보가 어떻게 생성되나
`isTemplate()` 이나 `isAbstract()`, `getName()` 같은 타입정보는 @ref ttypeBase<T>에서 메타프로그래밍을 통해 채워준다.
따라서 type::init()이 존재하는 이유는 클래스 계층를 구성하기 위해서다.

그리고 그 계층을 구성하는 핵심은 `모든 클래스는 typedef로 super 를 정의해야 한다` 라는 제약사항으로 해결한다.
모든 클래스에 `super` 가 존재한다면, ttype<super>().init()도 호출할 수 있기 때문에
다음과 같은 간단한 코드로 클래스 계층을 재귀적으로 구성할 수 있게 된다.

@code
    // 주의: 다음은 실제 코드 동작을 이해하기 쉽게 간략화 한 것이다.
    nbool me::init() {
        if(_isInit) return false;
        _isInit = true;

        // 위 코드로 인해, 여기는 딱 1번만 실행된다.
        type& super = (type&) getSuper(); // getSuper()는 ttype<typename T::super>::get() 를 반환한다.
        super.init(); // 재귀적으로 부모의 타입을 계속 호출하는 과정이 반복된다.
                      // 최종적으로는 adam 클래스까지 올라가게 되며, adam은 부모가 없기 때문에 취소된다.

        types& mySupers = getSupers();
        mySupers = super.getSupers();
        mySupers.push_back(&super);
        ...
    }
@endcode

실제 코드는 이와 크게 다르진 않다. 실제로 몇 줄의 간단한 코드만으로도 클래스 계층을 구성한다.
이 과정은 재귀를 사용하긴 하지만, 프로그램 실행 후 1번만 발생하기 때문에 비용도 비교적 적다.


@section 메타 정보 자동 생성
앞서 얘기한 대로 각 type 클래스들의 정보는 `init()` 함수를 호출하면 생성되고 채워진다.
문제는 각 클래스 들에 대한 타입 객체를 일일이 사용자가 생성하고 각각을 명시적으로 `init()` 을 호출하는 것은
굉장히 비효율적이라는 점이다.

이걸 해결하고자 @ref MY_INIT_META 매크로를 사용한다.
BY_INIT_META는 @ref BY_INITIATOR 매크로를 응용하는데, 이 매크로는 static 객체에 람다함수를 끼워넣음으로써 원하는 동작을
main() 함수가 시작되기 전에 실행하는 매크로다.

이 매크로를 응용하면 init() 함수를 main() 함수가 호출되기 직전에 실행하는 게 가능해진다.
한가지 제약사항으로는 각 클래스 선언시에 MY_INIT_META(MyClass) 를 추가해야 한다는 점이다.

이러한 메타 DSL 형태의 매크로들은 BY 매크로에 의해서 실행되도록 컨벤션이 정해져있다.
그리고 core 모듈에서도 추가로 정의해야할 메타 DSL 매크로가 있기 때문에 직접 BY_INIT_META를 호출하기 보다는
BY(CLASS()) 나 BY(ADT())를 통해서 한번에 정의한다.


@section 메타 정보를 추가하고 싶다면
type은 기본적으로도 비교적 많은 타입 정보를 제공하지만, byeol 처럼 언어를 다루는 경우에는
parameter나 return type과 같이 추가적인 정보를 담고 싶은 경우가 있다.
이때 쉽게 생각하면 `type을 상속받은 클래스를 만들면 되는거 아닌가?` 라는 아이디어를 떠올리기 쉽지만
@ref ttype<T> 에서 언급한 것처럼, 항상 사용자의 최종 진입점은 `ttype<T>` 에 접근하면서 시작되어야 한다.
문제는 ttype<T>의 코드를 meta 모듈을 종속하는 쪽에서 수정할 수는 없기 때문에 상속으로는 불가능하고
메타 타입을 주입하는 형태로 문제를 해결한다.
핵심 코드는 @ref ttypeBase<T>에 있다.

@code
    template <typename T, typename S = typename tmetaTypeDef<T>::is>
    class ttypeBase: public S {
        ....
    }

    template <typename T, nbool hasMeta = tifHasMetaTypeDef<T>::is>
    struct tmetaTypeDef {
        using is = type;
    };
    template <typename T>
    struct tmetaTypeDef<T, true> {
        using is = typename T::metaType;
    };
@endcode

tmetaTypeDef는 T에 typedef metaType 이 있을 경우에는 해당타입을 반환하고, 없으면 type을 반환한다.
ttype은 ttypeBase를 상속하며, ttypeBase는 바로 tmetaTypeDef<T>::is를 상속한다.
이걸 통해서 만약 class T에 대해 ttype<T>를 호출하는 순간, class T의 개발자가 typedef metaType Mytype;
처럼 새로운 MyType 클래스를 선언하여 추가하면 해당 ttype<T>()로 객체를 만들었을때 MyType을 기반으로 해서 만들어지게 된다.

실제로 이 기능은 core 모듈에서 ntype을 주입하기 위해 사용한다.
자세한 내용은 ntype을 참조.







memlite 모듈
############

binder 클래스
=============
binder의 일반화된 바인딩 클래스로 @ref instance 클래스를 상속한 클래스로부터 생성된 모든 객체를 바인딩할 수 있다.
reference counting으로 적절한 시점에 객체를 소멸시키며, 표준 라이브러리에 잘 정의된
std::weak_ptr과 같은 기능을 @ref tweak가, std::shared_ptr은 @ref tstr이 각 담당한다.
shared_ptr를 이미 잘 알고 있다면 아래와 같이 사용할 수 있다는 걸 쉽게 이해할 수 있을 것이다.


@section 기본 사용법
객체를 바인딩하는 `bind()` 와 `isBind()`, `get()` 을 주로 사용하게 될 것이다.
byeol은 기본적으로 setter 형 API에 대해 T*와 T&를 모두 준비해두는 경우가 많으니 참고하자.

@code
    class A : public instance {}; // instance를 상속했으니 바인딩 가능하다.
    A* a = new A();

    {
        tstr<A> strBinder;
        strBinder.bind(a);
        strBinder에 의해 a의 `life`는 count가 1이 된다.

        strBinder.isBind(); // true
        a == strBinder.get(); // true
    } // 이때 strBinder가 소멸되면서 life의 count를 0으로 만들고 결과 a가 자동으로 소멸된다.

    *a; // 에러: 소멸된 객체를 사용하려 한다.
@endcode

위는 아주 기본적인 API만 사용한 지나치게 정석적인 예제다.
실제로는 이보다는 더 간략하게 쓰는 편이다.

@code
    class shell : public instance {
    public:
        int age;
    };

    tstr<shell> foo() {
        tstr<shell> ptr(new shell()); // 생성과 동시에 바인딩한다.
        ptr->age = 57; // operator->를 지원한다.

        tweak<shell> weak = ptr; // 같은 shell에 대한 바인더 끼리도 호환된다.
        callShell(*weak); // operator*() 도 당연히 지원한다.

        return ptr; // tstr을 값으로 반환하므로 count는 유지된다.
                    // 따라서 foo() 안에서 new 로 생성한 shell객체는 소멸되지 않는다.
    }
@endcode


이쯤되면, 아마도 왜 shared_ptr를 사용하지 않고 굳이 tstr을 만들었는 가에 대해 의문을 가질 것이다.
shared_ptr이 제공하지 못하는 몇가지 장점이 있기 때문이다.


@section reference counting 블록은 인스턴스 자체에 붙어있다.
shared_ptr은 생성시 내부적으로 reference counting을 위한 `Control block` 이라는 걸 heap에 만들어서
관리한다는 건 이미 잘 알고 있을 것이다. 그래서 shared_ptr 사용시 다음과 같은 사용은 매우 위험하다

@code
    Foo* raw = new Foo();
    shared_ptr<Foo> foo1(raw);
        .....
    shared_ptr<Foo> foo2(raw); // foo1과 foo2 각각 control block 이 생성되므로
                               // double delete가 발생한다.
@endcode

그리고 이 문제는 바로 프로그램이 종료하지 않기 때문에 디버깅이 아주 어렵다.
byeol 에서는 reference counting을 위한 클래스를 @ref life 라고 하며, 이는 @ref watcher에 의해
인스턴스마다 별도로 대여된다. 때문에 이중 해제문제가 발생하지 않는다.


@section ADT 제공
tstr과 tweak는 같은 binder 기반클래스를 갖기 때문에 binder타입으로 범용적인 로직을 구현할 수 있다.

@code
    void me::rel(binder& me) { // me가 tstr인지 tweak인지 상관없다.
        WHEN(!me.isBind()) .ret();

        life* l = me._getBindTag();
        if(l) l->_onStrong(-1);
    }
@endcode


@section 동적 타입 체킹
binder는 ADT이며 클래스 템플릿 조차 아니다. 따라서 binder::bind() 함수는 parameter가 instance 타입으로 되어있다.
이 말은 tstr<A>라고 할지라도 bind(new B()); 컴파일 에러가 발생하지 않는다는 걸 의미한다.
bind() 안쪽에서 meta 모듈을 사용하여 동적으로 타입을 검사해서 올바른 경우만 인스턴스가 바인딩 된다.

@remark binder는 abstract 하므로 객체 생성이 불가능하다. tstr이나 tweak로 이미 생성된 바인더들을 범용적인 로직을
작성할때만 의의를 갖는다.


@section 자체 메모리 풀 사용
memlite의 궁극적인 목적은, byeol managed 환경을 실행할 수 있는 경량화된 c++ 메모리 관리에 있다.
따라서 GC 등 추가적인 메모리 관리가 필요로 해지며, 이는 자체 메모리 풀을 가지고 있으며, 인스턴스의 라이프사이클을
관리해야 한다는 것을 시사한다.
인스턴스 할당시 모든 작업은 @ref instancer를 시작으로 이뤄지니, 해당 클래스를 참조.


@section 속도 개선
shared_ptr의 알고리즘은 같은 shared_ptr 끼리 공유되는 reference counting 정보를 heap에 보관하고 공유하는 것이다.
heap보다 빠른 자체 메모리 풀을 사용하고, 바인딩 속도를 조금이나마 최적화한다면 속도를 개선할 여지가 있다.
참고로, binding은 byeol에서 가장 많은 퍼포먼스 비용을 차지하는 핫스팟중에 하나다.


@section 추가 정보 제공
shared_ptr은 heap에 reference counting 정보를 보관하는 객체를 생성하고 이를 공유한다.
반면 memlite 모듈은 @ref watcher 클래스를 통해서 이미 메모리는 할당된, 빈 @ref life 하나를 내어주고,
그곳을 해당 instance의 reference counting 공간으로 활용한다.
만약 이후, GC와 같은 기능이 추가되면 인스턴스마다 추가적으로 생명주기와 관련된 정보를 필요로 할 여지가 있다.
shared_ptr 와 달리 각 인스턴스의 생명주기 정보 또한 자체적으로 관리하고 있기 때문에 그런 요구사항에도 적절하게 대응할 수 있다.



instance 클래스
===============
memlite 모듈의 자체 memory pool에 의해서 관리되는 객체는 모두 인스턴스를 상속해야 한다.
인스턴스 class를 상속해야만 @ref binder를 통해 weak pointer나 strong pointer로 참조 할 수 있다.
instance의 식별은 @ref id 를 통해서 이뤄진다.


@section id 부여 알고리즘
memlite 에서 가장 취약한 부분을 고르라면 바로 이 id 부여 알고리즘이다.
인스턴스 생성은 memory pool을 관리하는 @ref instancer 에 의해서 이뤄진다.
이때 instancer는 @ref value라고 하는 instance 내부의 클래스에 instance 주소와 id를 map에 push 한다.
instance::operator new() 가 불리면 안쪽에서는 vault에게 `map[this]` 와 같은 코드로 id값을 가져오는 방식이다.

얼핏 괜찮아 보이지만 단점이 많다.

1. 생성자 단계에서 vault에 접근해서 값을 가져오는 방식 자체가 안전하다고 보긴 어렵다.
2. 느리다.
최초 구현은 vector로 만 되어있었으며 FIFO로 관리했었으나, 생성자 안에서 다른 객체를 생성하는 경우에는 추가되는 id의
순서가 FIFO가 아니게 되면서 ID가 꼬이는 문제가 있었다.


@section 속도에 있어서 instance 클래스의 중요성
byeol에서 가장 빈번히 하는 작업은 객체를 생성하면서 id를 부여하거나 binding을 하는 작업이다.
여유가 있을때 꼭 개선을 해야 한다.



instancer 클래스
================
low level로 메모리를 관리하는 @ref pool 클래스와, @ref instance 들의 라이프사이클을 관리하는 @ref watcher
를 가지고 있다.
이 둘을 잘 제어해서 인스턴스의 생명 관리(할당/소멸)를 하는 것이 목적이다.
사실상 memlite에서 핵심 작업을 수행하기 위해 각 제어클래스들에게 작업을 분배하거나 명령을 내리는 진입점을 담당한다.



memoryHaver 클래스
==================
memory pool에서 일정 메모리를 직접 혹은 간접적으로 소유하고 있으며,
그 메모리를 READ 가능한 클래스들의 기본 인터페이스를 정의한다.
그래서 메모리의 크기나, 상태 등을 알 수 있는 인터페이스로 정의되어 있다.


@section 간접적으로 소유하다?

해당 객체가 직접 메모리를 할당받아 사용하는 것이 아니라, 내부에 멤버변수로 있는
다른 객체들이 담당하는 경우가 있다.
그리고 메모리의 할당은 내부 멤버변수들을 통해 직접해야 한다면, 그 클래스는 memoryHaver만 상속받아야 한다.
만약 할당도 가능하다면 @ref allocator 를 상속하면 된다.



@section len 과 size
할당 가능한 메모리의 크기는 size로 표현하며, 그 중에서 할당한 메모리는 len 으로 표현된다.
void* 및 byte 단위로만 제어하는 것을 전제로 한다.


@remark memoryHaver의 파생클래스들은 자신들이 담당하는 메모리의 사이즈가 제각기 다르다는 것에 주의하자.



allocator 클래스
================
@ref memoryHaver를 상속하고 있다는 점에서 알다시피 관리하는 메모리의 상태나 크기를 측정할 수 있으면서,
추가적으로 메모리를 할당/소멸 할 수 있는 클래스다.

@remark 모든 메모리는 void* 및 바이트 관점에서만 바라본다는 memlite 컨셉에 맞게,
new(), del()의 파라메터는 void*만 제공한다.


@section memlite 전용의 공통 인터페이스의 네이밍 컨벤션
할당은 new1() (new one 이라는 뜻이다.), 해제는 del()를 사용한다.
이 네이밍은 memlite 뿐만 아니라 byeol 프로젝트 내부에서 자주 사용된다.



chunk 클래스
============
memlite에서 메모리를 실제로 할당 가능한 최소 단위 클래스다.
모든 메모리 관리는 chunk 들을 엮어서 수행한다.

@remark chunk는 메모리가 flexible하게 늘어나도록 하는 _resize() 함수가 있지만,
memlite의 컨셉상 이를 public으로 공개하지 않는다.
결과적으로 chunk의 메모리는 객체 생성시 고정되며, 추가 메모리가 필요하다면 chunk 객체를 더 생성해서 운영해야 한다.


@section Block size
chunk는 생성시 block size와 size 2개를 입력받는다.
blockSize는 메모리에 인스턴스 하나가 차지하게 될 최소 단위 크기다. 반면 size는 그러한 인스턴스가 몇개 까지 들어갈 지를 정한다.
예를들어 만약 int64만 100개 담는 chunk를 만든다고 한다면, 다음과 같이 된다.
@code
    new chunk(sizeof(int64), 100)
@endcode


@section real block size
실제 메모리 할당시에는 block size와 대신 real block size을 사용하는데, 이는 최적화에 따른 것이다.
CPU 연산시 1이나 2바이트 등 작은 단위로 메모리 할당해서 계산하는 것보다 4나 8등 CPU 수준에 맞게
적당히 최소 바이트 이상 가져가는 게 더 효율적이다.


@section ArrayList
chunk는 배열 기반 리스트인 ArrayList로 구현되어 있다. 크기가 고정되어 있지만 크기 내에서는 추가 삭제가 자유로우며
임의접근 속도 또한 매우 빠르다.

알고리즘은 다음과 같다.
0. 각 원소의 byte 크기는 4이상이어야 한다는 전제조건을 갖는다.
   각 원소들은 모두 동일한 byte 크기를 갖는다.
   chunk는 어짜피 void*로 다루기 때문에, 각 원소에 값이 없을 경우에는 int타입으로 취급한다.

1. 배열 초기화시 size를 받아 n번째 원소가 차지하는 byte 앞에 n+1를 표현하는 정수값을 넣어둔다.
예: size=4의 경우, [1, 2, 3, 4]

2. _head는 가장 최근에 add된 원소의 인덱스를 표현하며, 0으로 초기화되며,
   _heap은 heap에 할당된 메모리를 가리킨다.

3. new1으로 외부에서 메모리 할당을 요청하면 _head를 현재 _head번째 원소의 int로 값으로 할당한다.
예: new1() 경우, _head는 이제부터 _heap[0]에 담긴 `1` 값이 할당된다.
    이는 다음 new1()을 했을때 _heap[1]를 메모리를 할당가능한 빈 원소로 간주한다는 얘기다.

4. 방금 가져온 원소에 할당된 메모리 주소를 반환한다.
   _head = 1, [사용중, 2, 3, 4]

5. 메모리 해제가 발생하면, parameter로 해제할 메모리 주소를 void*로 받는다.
   예: del(used = _heap[0])

6. 해당 메모리에 _head 값을 할당한다.
   (여기에 오기 전에 이미 소멸자가 호출되었다고 전제한다.)
   *used = _head  // [1, 2, 3, 4]

7. _head값을 현재 해제중인 메모리의 인덱스로 할당한다.
   이때 인덱스는 _heap에서 얼마나 _head가 떨어져 있는지를 pointer 연산으로 계산한다.
   _head = _heap - used // _heap - _heap  --> 0
   _head = 0, [1, 2, 3, 4]



chunks 클래스
=============
chunks 객체는 여러개의 @ref chunk의 인스턴스 관리를 담당한다. chunk는 생성시 고정된 크기만 메모리를 활용하기 때문에
chunks가 여러개의 chunk를 추가/삭제 함으로써 유동적으로 메모리를 관리한다.


@section chunks 역시 고정된 메모리만 제공한다.
chunks는 chunk 들을 추가하거나 삭제하므로, chunk가 각 셀마다 고정된 크기만을 사용하기 때문에 chunks 또한 고정된 크기의
메모리만 할당할 수 있다.


@section pool과의 연계
최초 메모리 요청을 받는 곳은 @ref pool 클래스다. 해당 객체에서 할당해야할 memory size를 받으면,
해당 memory size를 처리할 수 있는 chunks 인스턴스를 lazy로 가져와, new1()를 요청하게 된다.
chunks::new1() 에서는 메모리 할당이 가능한 chunk를 찾고, 없을 경우는 추가로 chunk를 생성한다.


@section 가용 chunk 검색 알고리즘
가장 최근에 메모리를 할당한 chunk가 추가로 할당 할 가능성이 가장 높다.
멤버변수 `_s` 는 바로 최근에 할당한 chunk의 인덱스를 가지고 있다.
만약 _chunks[_s]에 가용 메모리가 없을 경우 _s를 ++ 한다.
이후 마치 원형배열처럼, _chunks의 끝은 처음과 이어져 있다고 보면 된다. 그래서 다시 _s가 순회직전의 _s로
값이 같아질 때까지도 가용 메모리가 없다면, chunks 전체에 가용 메모리가 없는 상태이므로 resize()에 들어간다.


@section vector를 쓰면 안된다
당연한 건데, vector는 heap으로 관리되므로 자체 메모리 풀을 만든다면서 vector를 사용해서는 안된다.
차후 수정 예정.



pool 클래스
===========
외부로부터 메모리 할당 요청시 가장 최초로 처리하는 클래스다.
내부적으로 @ref chunks 에 대한 배열을 가지고 있으며, chunks는 @ref chunk을 가지고 있으므로, 사실상 로우레벨의 메모리 관련
클래스를 모두 관리하는 셈이다.


@section pool은 할당 가능한 size 별로 lazy하게 chunks를 가진다.
자체 메모리 풀을 만들때 중요한 포인트는, 같은 사이즈의 메모리를 한 곳에 나열함으로써 속도를 높이는 것이다.
chunks는 블록이라는 개념이 있어서 각 블록은 미리 지정된 크기의 메모리만 할당/해제 될 수 있다.
pool은 chunks를 만들때 블록의 크기를 고정해서 생성하며, 외부에 의해서 특정 사이즈의 메모리 할당을 요청받으면,
해당 크기의 블록을 담당하는 chunks를 찾는다. 없을 경우 lazy 하게 생성한다.



life 클래스
==============
@ref pool 클래스가 로우레벨 관점에서 블록 단위로 메모리를 관리하는 클래스라면,
@ref watcher 컴포넌트는 각 블록의 정보를 유기적으로 관리하는 클래스다. 자세한 내용은 먼저 watcher를 참조하자.
life는 pool 에 할당되어있는 주소값(_pt)와 reference counting을 위한 값들을 갖는다.

_strong은 reference counting을 위한 값이며, _pt는 pool에 할당받은 인스턴스를 직접 가리킨다.
_id는 객체를 식별하기 위한 값으로 자세한 내용은 @ref id 를 참고.


id 클래스
=========
64bit integer로 되어있는 @ref instance 식별자다.
tagN은 @ref life를 식별하며, chkN은 몇번째 @ref chunk 인지를 나타내며 serial은 객체 검증에 사용된다.


@section serial은 프로세스 실행 도중 instance 객체의 생성횟수다.
@ref pool 과 chunk를 먼저 봤다면 알겠지만, 자체 메모리 풀을 사용하기 때문에
메모리가 해제 될때는 소멸자만 호출할 뿐, 모든 메모리를 초기화 하지 않는다.
그러니 이전에 할당해서 사용후 소멸된 데이터가 그대로 남아있으며, 심지어 이 데이터에
접근도 가능하다. (이미 사용한 데이터에 접근시 exception이나 UB가 된다면 weak pointer나
strong pointer를 구현한 @ref binder 를 구현할 수 없었을 것이다)
binder에서는 이렇게 해서 가져온 데이터가 정말로 유효한 데이터인지 구분하기 위해서 serial을 추가로 비교한다.


@section tagN 은 life 객체에 접근할때 사용한다.
@ref watcher 는 자신의 배열에서 tagN 번째 @ref life 객체를 가져올때 이 값을 사용한다.


@section chkN은 chunk 객체를 가져올 때 사용한다.
@ref pool 은 먼저 id와 매핑된 instance의 size를 계산해 @ref chunks를 가져온다.
그리고 chunks는 자신의 chkN 번째 원소인 메모리블록을 반환한다.
외부에서는 전달 받은 메모리 주소와 serial 값을 비교해서 같은 인스턴스인지를 검증한다.



watcher 클래스
==============
메모리 관리의 한 축을 담당하는 클래스로, 생성된 객체의 라이프사이클을 관리한다.
@ref instance 가 생성될때마다 watcher는 @ref life 객체를 추가로 할당해 reference counting으로 객체의 소멸시점을 판별한다.


@section reference counting
@ref binder 에 의해서 instance가 바인딩 될때마다 life가 count 하는 strong 값을 1 증가시킨다.
binder가 instance를 rel() 할때 count를 1 감소하며, 0이 되는 순간 delete 로 메모리에서 해제한다.
instance는 `operator delete()` 를 통해 @ref instancer 에게 메모리 해제 작업을 실행하도록 한다.







stela 모듈
#########

stela 클래스
============
stela 모듈의 가장 기본 단위가 되는 클래스로, 다음의 기능을 제공한다.
1. stela는 asInt(), asChar() 등, int, char, string, bool의 값으로 변환을 시도하는 API를 제공한다.
1. 값이 있는 경우 @ref valStela의 API가 실행되며, 적절한 값으로 변환된다.
   예를들어 verStela(22)의 경우 `asStr()`을 하면 std::string("22") 가 반환된다.
2. 값이 없는 경우 @ref nulStela로 표현된다.
   이 경우 어떠한 타입변환 시도에도 기본값(빈 문자열 혹은 0)이 반환된다.
3. 버전타입을 제공한다.
   major, minor, patch 버전을 가지고 있으며, 범위로도 표현이 가능하다.
4. stela는 또다른 stela를 자식으로 둘 수 있다.
   stela 객체마다 이름이 존재하므로, 자식을 찾을 때는 이름으로 검색하거나 순회한다.
   주어진 이름에 맞는 자식이 없는 경우 nulStrela가 반환된다.

`core` 모듈의 @ref node 와 닮았다.


@section 사용법
예제를 보면 바로 알 수 있을 것이다.

@code
    const std::string script = R"SRC(
        def man
            dummy := 5
            name := "dark souls"
            ver := 1.0.8
    )SRC";

    root = stelaParser().parse(script);
    ASSERT_TRUE(root);

    stela& man = root->sub("man");
    stela& name = man["name"];
    ASSERT_TRUE(name);

    ASSERT_STREQ(name.asStr().c_str(), "dark souls");

    verStela& ver = man["ver"].cast<verStela>() OR_ASSERT(ver);
    ASSERT_STREQ(ver.asStr().c_str(), "1.0.8");
    ASSERT_EQ(ver.asMajor(), 1);
    ASSERT_EQ(ver.asMinor(), 0);
    ASSERT_EQ(ver.asFix(), 8);
@endcode



nulStela 클래스
===============
@ref stela로 자식 객체를 가져올 때 보통 이름으로 가져오는데, 해당 이름을 가진 자식 객체가 없을 경우
nulStela가 대신 반환된다.
nulStela는 null object 패턴을 구현한 것으로, 해당 객체에 대해 값 변환을 요청할 경우 항상 해당 타입의 기본값이 반환된다.

@remark stela 객체가 nulStela인지 확인하려면 isExist() 혹은 operator bool()이 false인지 확인하면 된다.



valStela 클래스
===============
@ref nulStela와 달리 int, float, string등 scalar 타입을 가지고 있는 @ref stela다.
내부적으로는 기본 문자열로 값을 가지고 있는 상태이며, `asInt()` 와 같은 타입변환 요청에 따라서 적절한 타입으로 변경할 수 있다.

@remark 만약 타입변환에 실패한다면, 예외가 발생하니 주의하자.



verStela 클래스
===============
@ref valStela와 비슷하게 `version` 이라는 타입의 값을 가지고 있는 @ref stela다.


@section version 타입
stela 언어는 byeol 언어의 경량화된 언어로, manifest나 옵션과 같은 특수 목적용 언어다.
version 타입은 `major.minor.fix` 의 3가지 변수를 가지고 있으며 범위 표현 또한 가능한 타입이다.



stelaParser 클래스
==================
@ref stela 파싱 컴포넌트의 진입점 역할을 한다.
`parse()` 나 `parseFromFile()` 을 통해서 스크립트를 지정하면 파싱된 결과가 @ref stela 구조로 반환된다.


@section byeol 파서와 유사한 구조
stela 언어 자체가 byeol의 특화된 언어이므로 파서 또한 byeol 언어의 파서를 기반으로 하고 있다.
byeol 파서대비 덜 복잡한 언어이므로 core 모듈을 보기 전에 이 파서 코드를 먼저 살펴볼 것을 권장한다.


@section scanner - bison - stelaParser 구조
flex와 bison을 사용하고 있으며 flex는 lowscanner로, bison은 lowparser로 각각 명명한다.
이 lowlevel scanner, parser는 parser 컴포넌트 안에만 존재하는 것으로 외부에서는 일절 노출 되지 않는다.
stelaParser::parse() 가 실행되면 lowscanner를 실행시키고, lowscanner는 토큰을 뜯어서 lowparser에게 넘기고,
lowparser는 받은 토큰에 대해 rule이 match 되면 그 이벤트를 다시 stelaParser 에게 넘긴다.
그러므로 stelaParser의 `on` 으로 시작하는 함수들은 그러한 이벤트를 handling 하는 함수로, 실제로 어떻게 node를 생성해서
ast를 구축하는 지를 정의한다.


@section indentation rule
stela 언어는 byeol 언어와 마찬가지로 offside rule을 적용하므로, indentation에 매우 민감하다.
일반적인 언어와 달리, 개행직후로 몇개의 공백이 있는가를 count 할 수 있어야 하며,
indentation이 확정되어 해당 코드라인이 어느 scope에 속한 것인지가 확정되면 이후로는 공백을 무시해야 한다.
다음 byeol 언어의 예제를 보고, 이 문제에 대해 더 생각해보자.

@code
def A
    foo(val int) void
        if val > 0
          if val < 5
                  print("0 < val < 5")
        print("end of func") # 1)
@endcode

파서가 `print("0 < val < 5")` 를 파싱하고 나서 다음 줄인 `print("end of func")` 를 파싱할때
앞에 공백이 몇개 있는지 세야 한다. 그리고 지금까지 각 scope별 공백 갯수와 비교해서
해당 코드라인이 어느 scope에 속한 것인지를 판단해야 한다.
위 예제를 보면, 우리는 직관적으로 `print("end of func)`이 `if val > 0` 과 같은
공백을 갖고 있다는 점에서, foo() 본문 바로 안에 속한 코드라는 걸 알 수 있다.
그렇다는 건, 이 시점에서 `if val > 0` 안쪽의 scope와 `if val < 5` 안쪽의 scope 2개 모두
종료되었으므로 lowscanner는 lowparser가 `print("end of func")`를 인식하기 전에
scope의 종료를 의미하는 `DEDENT` 토큰을 2개 먼저 인식할 수 있도록 만들어야 한다.


@section tokenDispatcher
flex는 yyin 이라는 별도로 지정된 stream 을 통해서 글자를 가져와 token으로 정의한다.
위의 예제를 보다시피, 파싱 도중에 토큰을 추가한다는 것은 이 stream에 특정 문자를 추가하는 것을 의미한다.
기본적으로 이런 경우는 unput을 사용하나, 여러개를 unput 하거나 뒤가 아니라 앞에 push 하는 경우 등에
유연하게 대응하기 위해, stelaLowscanner는 내부적으로 @ref stelaTokenDispatcher를 사용한다.


@section tokenScan
앞서서 indentation을 탐지하는 게 얼마나 중요한지 설명했다. 정확한 공백의 갯수를 셈해야 하기 때문에
@ref normalScan 과 @ref indentScan 2개의 scan 객체를 전환해가며 사용한다.
개행이 탐지되면 indentScan으로 교체해서 정확하게 공백을 count해서 scope를 결정하고,
이후에는 normalScan으로 교체해서 평상시처럼 공백을 다 무시한다.



stelaTokenScan 클래스
================
@ref stelaParser는 해당 클래스에서 언급한 것처럼 indentation을 정밀하게 측정하기 위해서 scan mode를
동적으로 변경해아 한다.
tokenScan은 그러한 스캔 모드 전략 1개를 담당한다.


@section 명령 token
token 중에는 `SCAN_AGAIN`, `SCAN_EXIT` 등 scanner나 parser에 명령을 주는 토큰 들이
존재한다.
자세한 내용은 `stelaParser.hpp`의 zztokenType enum을 참조.


@section isBypass
IndentScan의 경우 대부분의 token을 무시하며 오직 공백이 몇개인지 갯수를 세는 데 집중한다.
하지만 이전 라인에서 여러 token을 push 해둔 상황이라면 내부적으로 bypass 모드로 동작한다.
이때는 indentation 갯수를 세는 동작을 skip 하고 넣어둔 token을 그대로 읽어서 반환한다.



stelaSmartDedent 클래스
==================
@ref stelaParser 가 indentation으로 scope을 만들때마다 몇개의 공백이 앞에 있는지를
count 해서 배열로 관리하는 클래스.
예를들어 다음의 stela 코드를 파싱한다고 하자.
@code
def config
    def device
      name := "my device"
      # 1)
@endcode

만약 1번 위치에서 파서가 파싱중일때, smartDedent는 [0, 4, 6] 으로 내부 배열 값이
구성되어 있다.
즉 가장 바깥의 scope의 공백의 수는 smartDedent[0]인 0이 되며,
가장 안쪽의 scope인 device 의 scope임을 증명하는 공백의 수는 smartDedent[smartDedent.len() - 1] = 6으로
앞에 6개의 공백이 있어야 한다는 걸 의미한다.






frontend 모듈
#############

cli 클래스
==========
`frontend` 모듈의 핵심 클래스로, `core` 모듈의 @ref interpreter 를 사용해서
코드를 파싱하고 검증하고 평가하는 일련의 과정들을 위해 적절한 클래스를 호출해서 제어한다.
즉, cli는 뭔가 알고리즘을 만들어서 동작하는 클래스가 아니라 이미 잘 짜여진 클래스들을
조합하는 역할이다.

파라메터로 cli 프로그램에 사용자가 입력한 인자를 받으며, 이를 적절히 파싱해서
추가로 명령을 수행한다.
자세한 내용은 `flags` 폴더 참조.


@section 핵심 알고리즘
사용자가 파라메터로 flagArgs를 줘서 eval() 을 호출하면 다음과 같이 실행된다.
1. interpreter, @ref errReport, @ref starter 객체를 생성한다.
2. interpreter, starter에 flag를 set 한다.
   이 @ref worker의 flag를 말하는 것으로, cli의 @ref flag와 다른 것이다.
   자세한 내용은 worker를 참조.
3. flagArgs를 파싱해서 사전 작업 수행
   flag 객체에 `take()` 함수를 호출해서 수행한다.
4. interpreter를 수행한다.
5. 인터프리트 결과를 체크한다. 이상이 있으면 결과를 내보내고 종료한다.
6. 이상이 없으면 starter에 검증된 AST를 넣고 실행한다.
7. starter의 결과를 반환한다.


flag클래스
==========
shell 기반 프로그램에서 흔히 볼 수 있는 플래스들을 handling 하는 클래스다.
한가지 착각하기 쉬운 포인트는 이 클래스는 `--version` 과 같은 플래그를 표현하는
클래스가 아니라 그러한 플래그가 존재하는지, 존재한다면 어떤 동작을 해야 하는지를
담당한다.


@section flag의 설명
각 flag는 자신의 이름 뿐만 아니라 어떠한 기능인지 description을 정의해두고 있다.
이 들은 @ref helpFlag에 의해서 사용된다.


@section 정규식에 의한 패턴매칭
각 flag 클래스는, 자신이 찾고자 하는 패턴이 정해져 있다.
예를들어 @ref verFlag 는 `--version` 이라는 문자열이 프로그램 인자로 들어와 있는지
를 찾아, 들어와 있을 경우 @ref buildFeature로부터 version 정보를 가져와 출력한다.
이 동작은 `flag::take()` 가 호출되면 파생클래스의 `_getRegExpr()` 에 정의해둔
정규식 표현으로 각 flag 객체가 원하는 패턴을 찾는 형태로 동작한다.
정규식으로 찾기 때문에 flag 간 순서는 무시된다.

또한 정규식 패턴을 정의할 때는 여러개 패턴을 정의할 수 있다.

@code
    const strings& me::_getRegExpr() const {
        static strings inner{"^\\-S$", "^\\--show-structure$"};
        return inner;
    }
@endcode

위는 `^\-S$` 혹은 `^\--show-structure$` 둘 중 하나라도 매칭되면 된다.


@section 복수의 flag 인자를 consume하기
위에서 예로 들었던 verFlag를 다시 보자. `--version` 이라는 문자열이 프로그램 인자에
있는 경우, 버전을 출력한다.
단, 이때 또 다시 verFlag가 동작하지 않도록, 동작을 마치면 `--version` 이라는 문자열을
@ref flagArgs 에서 제거한다.

그러면 다음으로 @ref bufferSrcFlag 를 보자. 이 클래스는
> `--script "main() void: print("wow!)"`

와 같이 사용한다. 이를 찬찬히 뜯어보면,
> `--script` 로 flag의 시작임을 알게 되면, 공백 뒤에 나오는
> "<your code>" 가 실행할 byeol 코드의 본문이라는 인자다.

한 줄로 적은 해당 byeol 코드를 풀어쓰면,
@code
    main() void
        print("wow!")
@endcode

가 되면서 실행 결과는 `wow!` 가 화면에 출력될 것이다.
이처럼 어떤 flag는 패턴과 일치하는 부분만을 consume 하지 않는다.
`--script` 을 찾으면 거기서 추가적으로 1개의 인자를 더 뜯어내서
`bufferSrcFlag::_onTake()`로 전달해 함수의 본문이 _onTake()로 전달되도록 해야 한다.
각 flag의 파생클래스는 원할 경우, `getArgCount()` 를 오버라이드 해서 몇개의 인자를
더 뜯어낼 것인지를 명시한다.

@code
    // -- bufferSrcFlag.cpp
    ncnt me::getArgCount() const { return 1; } // 1개 더 뜯을 거임.

    me::res me::_onTake(const flagArgs& tray, cli& c, interpreter& ip, starter& s) const {
        // main() 의 argc, argv 를 잘 알고 있을 것이다. 그것과 비슷하게, 매칭된 문자열이 tray에 담겨있다.
        // 즉 tray[0]은 "--script"
        //    tray[1]은 "main() void: print(\"wow\")"
        // 가 들어있게 된다.
        if(tray.size() < 2) return BY_E("invalid flagArgument size < 2"), EXIT_PROGRAM;

        ip.addSupply(*new bufSupply(tray[1]));
        return MATCH;
    }
@endcode


@section 중단 가능한 flag

bufferSrcFlag는 프로그램 시작 전에 사전 작업을 필요로 하는 flag다.
반면 verFlag 같은 경우는 일단 매칭이 되면 어떠한 인터프리팅도 하지 않고 그대로
버전을 출력하고 종료한다. (대다수 프로그램이 이렇게 동작한다는 걸 알고 있을 것이다.)

이처럼 flag의 패턴이 매칭이 되면 동작을 하고 바로 종료하고 싶을 때는,
`_onTake()` 를 오버라이딩 할때 반환값을 EXIT_PROGRAM 으로 준다.
bufferSrcFlag 처럼 계속 동작을 하는 경우에는 MATCH 로 반환한다.




core 모듈
#########

node 클래스
===========
AST의 가장 기본클래스를 node 라고 한다.
AST 구조와 관련된 API와 해당 node를 평가하는 `eval()`, 자식 node를 탐색하는 API 그리고
해당 node 객체를 다른 타입으로 형변환하는 API 등을 제공한다.


@section Program Excution Tree?
일반적인 언어와 달리, byeol 언어는 AST 구조를 유지한 채로 프로그램을 실행한다.
따라서 타 언어의 AST는 말그대로 문법 구조를 트리로 표현한, 중간결과물에 지나지 않지만
byeol에는 실행가능한 최종 output 을 AST가 담당한다.
그래서 AST라기 보다는 Program Excution Tree(줄여서, PET?) 라는 용어가 더 어울릴지도 모른다.
중요한 점은, 실행까지 염두에 두고 구현되었기 때문에 프로그램 구조를 Tree로 표현한 것은 물론이고,
형변환이나 node의 evaluation 등의 API도 같이 제공된다는 점이다.

왜 AST를 실행가능하게 만들었는가에 대해서는 개발 가이드 문서를 꼭 먼저 참조하자.


@section 가장 기본이 되는 클래스
각 node는 실행이 가능해야 한다는 이유 때문에, 각 node는 함수일수도, 객체일수도, `+` 와 같은
덧셈 연산자일수도 있다. 이렇게 실행하고 값을 평가하는 함수를 `eval(const args&) `로 제공한다.


@section side funcs
node는 byeol 프로젝트의 핵심 모듈 중에서도 핵심이 되는 기본 클래스이 때문에 매우
다양한 SIDE func을 제공한다.


@section AST 탐색
AST 특성상, node는 또 다른 node의 파생클래스의 객체도 가지고 있을 수 있어야 한다.
때문에 마치 DOM tree 처럼 composition 패턴을 사용해서 설계되어있으며 이 tree를 탐색하는
함수 또한 다양하게 지원하고 있다.
이 tree를 byeol 언어에서는 @ref scope 라고 표현하고 있으며 scope은 map을 기반으로 한다.
@ref blockExpr 같은 것은 node 이면서도 내부에 statement 뭉치를 array로 가지고 있다.
따라서 AST는 전체적으로 보면 map과 array과 혼합된 구조로 구성되어 있음을 알 수 있다.
scope은 key로써 각 node의 이름을 받는다. 이때 key는 @ref parser가 각 인스턴스에 대한 적절한
이름을 key로 정의해서 추가한다.
AST탐색을 위해 주로 사용하는 함수는 `operator[], sub(), subs(), in(), subAll()` 이다.

@code
const node& root = getRoot();
root.sub("name1"); // name1이라는 이름을 가진 node를 root에서 찾는다.
                   // 이 name1이 함수인지 객체인지 모른다.
root.sub<func>("name1") // name1 이름을 가진 symbol이 함수일때만 가져온다.

// 이름이 name2 이며 int 인자 하나를 받는 node를 모두 찾아서 반환한다.
tnarr found = root.subAll("name2", args(narr(*new nInt())));

const scope& subs = root.subs(); // subs는 tbicontainable의 모든 API를 활용할 수 있다.
                                 // for loop는 물론 이고, 반복자나 람다를 활용해 필터링 기능등
                                 // 다양한 기능을 제공한다.
subs.len(); // root가 몇 개의 자식 node를 가지고 있는지 반환.
@endcode


@section 중복 symbol 처리
byeol 언어는 동일한 scope내 중복 symbol을 허용하지 않는다. 하지만 이 말은 동일한 key로 2개의
pair가 들어갈 수 없다는 뜻은 아니다.
함수의 경우는 이름이 같을 지라도 파라메터의 갯수나 타입이 다르면 다른 symbol이 되기 때문이다.
따라서 단순히 string 비교만으로 중복여부를 판단할 수 없기에 scope 클래스는 map 기반이 아니라
multimap 기반으로 되어 있다.


@section eval
node는 함수일수도 있고, 객체일 수도 있고, 표현식일 수도 있다.
`eval(const args&)` 은 이러한 node를 실행한 결과를 반환한다. (byeol에는 클래스란 개념이 없고, 객체가 이를 대신한다.
그러니 객체 또한 함수처럼 실행할 수 있으며, 이는 생성자가 호출되는 것과 같다.)
eval()에는 evaluate시 필요로하는 인자인 @ref args 객체를 같이 넣는다.
해당 node는 자신이 예상한 파라메터와 args의 갯수나 타입이 다를 경우, 빈 @ref str이 반환될 수 있다.
node는 `eval()`에 name을 파라메터를 같이 받는 함수들이 있다.
이는 node의 name과 일치하는 자식 node들 찾아서 args를 전달해서 대신 evaluate 하는 함수들이다.
이는 일종의 메시지를 처리하도록 던지는 것이다.


@section infer
infer() 는 type inference를 수행한다. 런타임의 정확한 어떠한 값이 나오는지를 반환하는 것이 아니라
verification 단계에서 확정되는 타입을 객체로 반환한다.
예를들어 다음 코드가 있다고 해보자.

@code
    // byeol 언에서 `2 + 3.5` 표현하면 아래와 같다.
    FBOExpr e = FBOExpr(FBOExpr::SYMBOL_ADD, *new nInt(2), *nFlt(3.5));

    str infered = e.infer(); // int인 2와 flt인 3.5의 덧셈했을때의 타입은 뭐가 되어야 할까?
    infered->cast<nFlt>() != nullptr; // true: 정답은 flt
@endcode

위 코드는 @ref nInt객체와 @ref nFlt 객체를 @ref FBOExpr에 넣어서, 둘을 2 + 3.5 와 같은
표현식으로 생성한 것이다.
이 표현식의 결과를 알아내기 위해 `infer()`를 하면 int + flt는 type promotion에 의해
flt이 되므로 infered에는 nFlt 객체가 들어간다. (node에 있는 `promote()` 함수를 얘기하는 거다.)
특정 표현식에 대해 타입을 유추하려면 해당 표현식이 가지고 있는 자식 node 들에게 재귀적으로
타입유추를 호출해서 계산할 필요가 있다. 즉, `getType()` 처럼 호출 즉시 타입정보가 반환되지 못한다.
AST를 순회하면서 타입 정보를 계산해야 한다.
단, type inference는 어디까지나 타입을 빨리 아는 데 집중하므로 값의 계산은 수행하지 않는 다는 점에 주의하자.
예를들어, 위의 infer()를 호출하면, `infered`에 들어가 있을 nFlt의 값은 기본값이 들어가게 되므로
값을 정확하게 알고 싶다면 `eval()`을 해야만 한다.


@section 타입 변환
node는 명시적 타입 변환을 위한 `as()` 와 타입 변환이 가능한지 체크하는 `is()`를 제공한다.
다음과 같은 코드를 보자.

@code
    // 다음의 byeol 코드를 c++로 옮긴 것이다:
    //  foo(val int) void
    //      if val is flt
    //          doSomething(val as flt)

    void foo(const nInt& val) {
        if(val.is<nFlt>()) {
            str isFlt = val.as<nFlt>();
            nflt converted = isFlt->get();
            doSomething(converted);
        }
    }
@endcode

int가 flt로 타입변환한지 미리 체크하고, 가능하다면 타입변환을 수행한 후, 값을 가져온다.
이 시점에서, @ref nFlt이나 @ref nInt가 낯설다면 미리 보고 오는 게 좋을 것이다.

`as()`나 `is()` 는 다양한 SIDE func을 제공하고 있다. 다음과 같이 범용적인 함수를 만드는 것도 가능하다.

@code
    str convertIfPossible(const node& it, const node& toThisType) {
        // getType()을 하면 타입정보를 얻을 수 있다.
        // 이 타입은 c++ 클래스에 대한 타입일 수도 있고, byeol 언어로 사용자가 define 한
        // 타입일 수도 있다.
        // 자세한 내용은 type과 ntype 클래스를 참조하자.
        if(!it.is(toThisType.getType())) return str();

        return it.as(toThisType.getType());
    }
@endcode

사실 위의 예제는 이해를 돕기 위해, 풀어서 작성한 것이다.
실제 코드에서는 @ref WHEN 등을 사용해서 좀 더 간결하게 작성된다. foo() 함수를 현재 코드 스타일로
다시 작성해보면 다음과 같다.

@code
    void foo(const nInt& val) {
        tstr<nFlt> converted = val OR.ret(); // eary-return pattern + WHEN + OR macro
        doSomething(converted->get());
    }
@endcode


@section managed 환경의 타입 변환과 native 환경의 타입 변환
앞서 설명한 `as()`, `is()`는 byeol 언어 환경에서의 타입 변환이다.
예를 들어보자.
@ref nInt는 byeol 언어에서 `int` 를 표현하는 c++ 클래스다.
@ref node에서 상속받고 있는데, byeol 언어에서는 int 또한 AST에 포함될 수 있는 인스턴스이기 때문이다.

여기서 nInt에 대해 is<nFlt>() 을 호출하는 것은 허용되지만, 그렇다고 해서 c++ 코드상에서 nInt가
nFlt로 타입 변환이 된다는 뜻은 아니다.
c++에서 본다면 둘은 클래스이기 때문에 일반적으로는 nInt가 nFlt의 부모클래스 일때만 묵시적으로 형변환이 허용된다.

nFlt이 node의 일종인지 알려면 meta 모듈의 타입 변환을 사용해야 하며, 이를 `cast()` 가 담당한다.
이처럼, meta 모듈은 c++ 코드에서의 native 환경에서의 타입을 관리한다.
즉, 타입 변환은 native 용으로 1개, byeol 언어 환경인 managed에서 1개, 총 2 종류가 존재한다.
예를 보자.

@code
    // nFlt과 nInt의 상속관계를 간단히 표현해주겠다.
    class nFlt : public obj {};
    class nInt : public obj {};
    class obj : public node {};

    nInt val1;
    nFlt val2;

    // native 타입 변환:
    nFlt* cast1 = dynamic_cast<nFlt>(val1) // nullptr: 허용되지 않는 변환이다.
    nFlt* cast2 = val1.cast<val2>(); // nullptr: 위와 같다. 다만 meta 모듈의 타입변환을 사용한 것 뿐이다.
    node* isNode = val1.cast<node>(); // != nullptr: upcasting이니 당연히 된다.
    isNode->cast<nFlt>(); // nullptr
    &val1 == isNode->cast<nInt>(); // true

    // managed 타입 변환:
    val1.is<nFlt>(); // true: byeol 언어에서 int <-> flt의 명시적 형번환을 지원한다.
@endcode

이처럼 core 모듈에는 native와 managed 별로 동일한 개념을 각각 구현한 경우가 종종 있다.
익숙해지는 게 좋다.
형변환이 동작하는 흐름을 알고 싶다면 @ref ases와 @ref asable을 참조하자.


@section 묵시적 형변환과 명시적 형변환
묵시적 형변환은 `impliAs()`, `impliIs()`로 제공된다.
이를 외부에서 직접 호출하는 일은 적다. 대부분은 @ref expr이나 @ref baseFunc 등 AST 클래스들에 의해서 호출된다.
참고로, byeol 사용자가 정의한 타입 변환은 당연히 묵시적 형변환에 포함되지 않는다. 그래서 이 둘을 구분하는 것이다.


@section visitable class
AST를 순회하는 동작 자체는 매우 다양한 목적으로 발생한다. 단순히 `eval()` 을 위해서만 아니라
디버깅 정보를 위해 AST를 출력할때도 사용된다.
순회 방식과 node에 대한 처리를 분리시키기 위해 visitor 패턴이 node에 반드시 적용되어야 한다.
`accept()`는 바로 이 @ref visitor 클래스에 의해 사용되며, 각 클래스는 헤더에 이를 위해
VISIT 매크로가 추가로 필요하다. 자세한 내용은 @ref visitor를 참조.


@section frame interaction
@ref frame은 현재 실행 중인 scope와 안에 등록된 symbol 등을 관리한다.
node는 AST의 기본을 구성하므로 node가 객체이거나 함수일 경우, frame에 자신이 소유한 함수나 property 등을
등록하거나 해제하는 작업을 해줘야 한다.
`inFrame()`과 `outFrame()`이 이를 담당하며, 자세한 내용은 @ref frame를 참조하자.


@section message priority
byeol은 함수 오버로딩을 지원하므로 어떤 객체에는 같은 이름을 가졌으되, 파라메터가 다른 함수가 여럿 있을 수 있다.
어떤 함수는 인자에 대해서 정확하게 일치할 것이고, 어떤 함수는 약간의 타입변환이 필요할 지도 모른다.
node는 자식 node들에 대해서 주어진 args 에 대해 얼마나 잘 일치하는 가를 `prioritize()` 함수를 통해 판단결과를 받는다.
이때 각 node의 파생클래스는 args가 정확하게 일치하면 EXACT_MATCH로 반환하며,
일치하지 않으면 NO_MATCH로 반환된다. 정확한 판단기준이나 알고리즘은 @ref tprior과 @ref priorType을 참고하자.



defaultCopyCtor 클래스
======================
managed 환경에서 byeol 타입에 대해 사용자가 복사 생성자를 정의하지 않은 경우
parser에 의해 추가되는 기본 복사생성자다.
args에 복사 대상 객체가 전달되며, 이 객체의 property들을 얇은 복사를 수행한다.
참고로 @ref scalar는 immutable 객체이므로 얇은 복사를 시도해도 깊은 복사처럼 동작한다.
자세한 내용은 @ref immutableTactic참조.



FBOExpr 클래스
==============
Binary operator 표현식을 담당한다.
lhs, rhs에 각각 피연산자 표현식이 들어가며, 둘은 모두 scalar 타입이어야 한다.



FUOExpr 클래스
==============
Unary operator 표현식을 담당한다.
args에 피연산자가 1개 들어가며 scalar 타입이어야 한다.



assignExpr 클래스
=================
할당 표현식을 담당한다.

@remark 이 표현식은 scope에 등록된 참조를 바꾸는 것이지 객체 자체에 대해
operator=()를 호출하는 것이 아니다.
일례로, obj::operator=()를 호출하게 되면 일종의 깊은 복사처럼 동작하니 주의하자.



blockExpr 클래스
================
블록 표현식을 담당한다.
frameInteractable 하며, 외부에서 frame에 등록을 요청하면 scope을 하나 생성해 등록한다.
이 scope는 이 블록문에서만 유효한 것으로, 흔히들 말하는 local scope다.


@remark blockExpr은 eval()을 함수 안에서 local scope을 생성하지 않는다.
이는 특정 context에서는 불필요한 scope 생성을 막아 최적화 하려는 것이다.


@section block문은 표현식이다.
byeol 언어는 대부분 표현식으로 구성되며, block문도 예외가 아니다.
block문은 마지막 줄의 evaluation 결과를 반환한다.



defArrayExpr 클래스
===================
배열 리터럴 표현식을 담당한다. 어떠한 타입의 배열인지는 배열의 원소로 적은 리터럴 상수들의
타입들을 type promotion(`promote()`)을 해서 inference 된다.

@remark arr 클래스
@ref tnarr은 native 환경에서 배열을 담당하는 클래스다. @ref arr은 tnarr을 managed 환경에 맞게
확장한 것이다. 이렇게 함으로써 c++에서도 byeol 에서도 서로 유사한 API를 사용 가능하게 된다.
자세한 내용은 arr과 tnarr을 참조.



defNestedFuncExpr 클래스
========================
byeol 언어의 중첩 함수인 @ref nestedFunc을 생성한다.
중첩함수는 정의할때는 이름을 생략할 수 있으며, @ref closure 로도 활용될 수 있다.



defSeqExpr 클래스
=================
@remark seq 클래스
@ref nseq은 native 환경에서 배열을 담당하는 클래스다. @ref seq은 nseq를 managed 환경에 맞게
확장한 것이다. 이렇게 함으로써 c++에서도 byeol 에서도 서로 유사한 API를 사용 가능하게 된다.
자세한 내용은 seq와 nseq를 참조.



endExpr 클래스
==============
`end` 키워드를 구현한다.

@remark endExpr은 단순히 블록문을 가지고 있을 뿐이다. @ref func이 end를 실행시킨다.



getGenericExpr 클래스
=====================
@ref genericOrigin 객체를 사용해서 generic 타입을 생성한다.


@section lazy하지만 lazy 하지 않다.
genericOrigin은 `eval()`로 주어진 type parameter를 사용해 lazy 하게 generic 타입을 생성한다.
하지만 @ref verifier에 의해서 프로그램이 실행되기 전에 미리 생성되기 때문에
실질적으로는 lazy하게 생성되진 않는다.



retStateExpr 클래스
===================
@ref blockExpr에서 벗어나는 키워드들의 기반클래스다.


@section 블록문을 바로 종료하는 알고리즘
블록문 안에서 `ret` 등을 하여 바로 블록문을 종료해야 하는 경우, @ref thread에 `setRet()`로 값을 넣어야 한다.
각 blockExpr은 구문을 한줄 한줄 실행하다가 thread에 setRet()에 일정한 값이 발견될 경우,
모든 동작을 중단하고 해당 값을 블록문의 호출자에게 올려보낸다.

만약 이런 방식을 하지 않고 expr의 `eval()`의 반환값이 retStateExpr인지를 확인하는 알고리즘도 있을 수 있다.
단, 이 경우에는 blockExpr을 소유한 모든 expr(@ref ifExpr, @ref forExpr 등)은 자신이 소유한 blockExpr의
결과가 retStateExpr일 경우, 이를 바로 올려보내는 코드가 각각 들어가야만 한다.
그렇지 않으면 blockExpr 안에 ifExpr 안에 blockExpr이 있는 중첩된 blockExpr이 존재하는 케이스를 처리할 수 없다.



modifier 클래스
===============
타입에 속한 함수나 property에 대해 접근제한자를 표헌한다.
byeol 언어에는 public/protected/override 3 종류의 modifier만 존재한다.



srcFile 클래스
==============
말 그대로 AST의 출처가 되는 소스코드 파일에 대한 정보를 담는다.
byeol 언어의 Context 기반 REPL이 핵심 기능에 사용된다.



src 클래스
==========
생성된 AST @ref node가 어떠한 @ref srcFile 안의 어느 위치에서 생성된 것인지를 담고있다.
byeol 언어의 Context 기반 REPL이 핵심 기능에 사용된다.

@remark src 정보는 managed 환경에 국한한다.
native에서 생성된 객체는 src에 더미 값이 들어간다. 자세한 내용은 @ref dumSrc 참조



args 클래스
===========
함수나 객체 `eval()`을 위해 전달하는 인자를 표현한다. @ref narr 을 상속하므로 narr의 모든 API를 사용할 수 있다.


@section me
args는 `me` 객체가 포함되어 전달되는 게 특징이다.
함수를 예를들면, 함수는 현재 런타임의 어떤 객체로부터 `eval()` 요청이 왔는지 기본적으로 알 수 없다.
그리고 일부 타 언어와 달리, args에 숨겨진 `thisptr`를 생성하지도 않는다.
별도로 `setMe()` 를 통해 args를 사용하는 함수나 property는 어떤 객체로부터 이 args가 전달되었는지를 알 수 있다.

참고로, @ref baseObj는 `eval(name, args)` 를 호출받으면 `setMe(this)` 를 호출해 자신을 args에 넣는다.



slot 클래스
===========
byeol 언어는 `pack` 이라는 일종의 압축파일로 단위로 라이브러리를 배포하는데,
pack 파일에는 최상위 `@ref obj` 객체와 @ref manifest, 종속하는 pack 목록이 포함된다.
(byeol 언어에서 내 코드에서 다른 pack을 사용하려면 manifest에 종속관계에 있다는 걸 선언해야 한다)

slot은 pack 파일로부터 만들어지는 결과물이지, pack을 불러오는 걸 담당하지 않는다.
pack 로딩에 대해서는 @ref packLoading 이나 @ref slotLoader를 참조.



autoslot 클래스
===============
@ref slot을 상속하므로, slot이 낯설다면 slot 클래스를 먼저 보자.

byeol 언어는 pack을 lazy 하게 동적으로 불러온다. autoslot은 이 기능을 구현한 것으로,
@ref slotLoader가 pack 파일을 찾으면 @ref packLoading 객체를 적절히 생성해서 autoslot에 넣어둔다.
이후 autoslot에 접근해서 안에 포함된 symbol을 가져오려는 시도를 하면 lazy하게 packLoading이 동작해 symbol을
파일로부터 불러온다.

자세한 내용은 slotLoader와 packLoading을 참조.


@section 복수의 packLoading
packLoading은 native 환경에서 가져올 수도 있고(dll 혹은 so 파일), managed 환경에서
가져올 수도 있다(.byeol 파일)
또는 2개가 모두 하나의 pack에 있는 경우도 있을 수 있다.
따라서 autoslot은 항상 1개의 packLoading만 가지지 않고, 배열로 처리한다.


@section 동적 검증과 의존성 문제
모든 pack이 검증이 완료된, 완전무결한 상태라고 전제하고 그냥 로딩만 해서는 안될 수 있다.
때로는 pack이 올바른지 한번 더 검증할 필요가 있기에, autoslot 중 일부는 symbol을 불러올때
사전에 파싱이나 검증을 해야 한다.
문제는 어떠한 pack은 다른 pack에 종속되는 경우가 매우 많이 발생한다는 점으로,
종속한 pack이 검증에 실패하게 되면, 그 사실을 전파해서 종속된 pack들도 모두 사용이
불가능해야 한다.
이를 후술할 4가지 상태를 제어하는 알고리즘으로 해결한다.


@section autoslot state
총 4개의 상태를 가지며 다음과 같은 흐름으로 로딩 파이프라인을 갖는다.

>                    ┌────────────────┐
>                    │Make an instance│
>                    └────────┬───────┘
>                             │
>                         ┌───▼────┐
>                         │RELEASED│
>                         └───┬────┘
>                          ┌──▼───┐
>                          │PARSED│
>                          └──┬───┘
>                         ┌───▼────┐
>                         │VERIFIED│
>                         └───┬────┘
>                          ┌──▼───┐
>                          │LINKED│
>                          └──────┘

slot 생성: slotLoader가 slot 객체를 생성해 시스템에 추가한다.
           이때 slot간의 dependencies도 기록한다.
RELEASED: 초기 상태로, 어떠한 메모리도 점유하지 않는다.
          사용하지 않는 대부분의 slot은 여기에 속한다.
PARSED:   autoslot에 접근이 이뤄진 경우, 본격적으로 사용하기 위해 코드를 파싱한다.
          만약 파싱 단계가 필요없는 경우 (optimized 된 pack을 배포했거나, native pack 인 경우)
          에는 LINKED 상태로 바로 건너뛴다.
VERIFIED: 파싱 이후, 코드의 정합성을 검증한다.
          만약 검증에 실패했다면 isValid값을 false로 한다.
LINKED:   자신이 검증에 실패한 상태라면, 자신을 참조하는 모든 dependents에게
          자신이 검증에 실패했다는 사실을 전파한다.


@section 재귀적 로딩
pack이 다른 pack에 종속되는 경우는 부지기수로 많다. autoslot이 lazy하게 동작하기 때문에
어떠한 slot을 loading 하다가 다른 autoslot에 접근함으로써 해당 autoslot도 재귀적으로
로딩 시퀸스에 들어가는 일도 많다.
이때 중복으로 초기화 되거나 아직 완전히 파이프라인을 통과하지 않는지 체크한다.


@section RAII
autoslot은 @ref slot에 정의된 _pack 객체를 가리킨다. 이 객체는 외부 파일인 `pack`
을 로딩함으로써 읽어온 심볼들이다.
autoslot은 packLoading을 통한 pack의 로딩을 책임지므로, 심볼과 pack의 소멸또한
책임진다.
RAII를 사용해, autoslot객체가 소멸될때 모든 심볼을 먼저 없애고 packLoading 객체
또한 없앰으로써 so 파일을 close 하는 등의 작업을 수행한다.
자세한 내용은 packLoading을 참조하자.



origin 클래스
=============
byeol 언어로 사용자가 정의한, 원본이 되는 타입을 origin 객체라고 한다.
@ref ctor와 같은 생성자 호출을 하면 모두 origin 객체를 복사 생성해서 만들어진다.

@remark 절대로 origin에 대해 함부로 메타타입을 사용해서는 안된다.
origin 객체는 @ref obj에서 상속받았으며 생성시점을 제외하고는 obj 타입으로써
사용되는 것을 전제로 작성되어 있다.
따라서 다음과 같은 코드는 다소 위험하다.

@code
origin* new1 = new origin(...); // 생성시에 origin* 로 참조하는 건 괜찮지만..
new1->getType(); // origin 클래스의 특징을 이해하지 않은 상태에서,
                 // 이런식으로 `meta` 모듈을 사용해서 타입정보를 가져오는 건 권장하지 않는다.
                 // 자칫하면 아래와 같이 쓸 수 있기 때문이다.

new1->cast<origin>(); // 이 코드는 nullptr가 반환된다.
@endcode


@section 왜 cast<origin>() 은 nullptr를 반환하는가?
`getType()` 은 byeol로 정의한 managed 객체인 origin 객체의 type만 해당되지 않는다.
@ref node나 @ref instance 와 같이 native 환경의 c++ 클래스의 대한 타입도 제공된다.
예를들어 사용자가 다음과 같이 byeol 코드를 작성했다고 해보자.

@code
    def MyObj
        foo() void
            print("hello")

    def YourObj
        boo() void
            doSomething()
@endcode

`MyObj` 는 AST의 일부이므로 c++에서는 @ref obj의 인스턴스로 생성되서 표현된다.
만약 별다른 추가 코드 없이 `MyObj`를 표현하는 obj 인스턴스에 `getType()`을 하면 어떻게 될까?
당연히 `ttype<obj>()`가 나오게 된다.
문제는 `YourObj`를 표현하는 obj 인스턴스에 호출시에도 같은 ttype<obj>()를 반환할 것이다.
결과, 프로그램을 실행하는 @ref starter는 YourObj와 MyObj를 같은 타입이라고 생각하게 된다.

이를 해결하기 위해 c++ obj 클래스는 멤버변수로 @ref mgdType 변수를 갖는다.
mgdType은 managed 환경에서의 byeol 타입에 대한 타입정보다. 자세한 내용은 mgdType을 참조하자.
아무튼 중요한 점은, 이 mgdType은 기존 native type의 meta 정보 트리의 구조에 확장되는 형태로
구성되기 때문에 ttype<obj>를 상속한 것으로 표현된다는 점이다.
그래서 c++의 MyObj 객체에 대해 getType()을 하면 mgdType이 나오고, 이 타입은 부모클래스가
`obj` 타입이며 YourObj와는 다른 타입이라고 구분할 수 있게 된다.

만약 이런 방식을 하지 않고, getType()과 getMgdType() 2개를 구분한다면,
type을 사용하는 모든 함수들에서, node* 를 받았을때 이게 native 객체인가 managed 객체인가를 구분하고
managed 에서 생성된 객체라면 getMgdType()을 호출해서 처리를 해야 했을 것이다.

눈치가 빠른 사람이라면 이제 왜 cast<origin>()을 하면 안되는 지 알았을지도 모른다.
아무런 처리를 하지 않는다면 origin 클래스의 getType()은 ttype<origin>()을 반환하려고 할 것이다.
하지만 위의 예제처럼 byeol 코드의 MyObj를 표현하기 위해서 생성된 obj 인스턴스는 mgdType을 반환해야 한다.
그리고 당연히 ttype<origin>은 방금 생성된 mgdType 인스턴스와 아무런 상속 관계가 아니므로
cast<origin>을 호출하면 내부에서 타입체킹에 실패하게 된다.

따라서 핵심은 c++의 `obj` 클래스를 기점으로 기존의 c++ 클래스별로 메타 타입을 제공하는 것이,
c++ 인스턴스 별로 메타타입을 제공하는 mgdType으로 전환된다.
그러니 origin 객체에 대해서 함부로 meta 모듈을 사용하려고 하면 안된다.
origin 클래스의 getType()은 c++의 origin 타입과 아무런 관련이 없는 타입을 반환한다.
하지만 이때의 mgdType은 부모클래스로 `ttype<obj>`가 되도록 parser가 연관을 지어서 생성한다.
그러니 obj 타입으로의 형변환이나 `cast<obj>()` 같은 것은 아무런 문제가 되지 않는다.

@code
    origin* makeOrigin() {
        mgdType t = typeMaker::make<obj>("MyObj"); // mgdType은 보통 typeMaker 클래스로 생성한다.
                                                   // t는 부모가 `obj` 이며 이름은 MyObj 인 타입이다.
        return new origin(t); // 꼭 필요한 게 아니라면 반환형은 origin*이 아니라 obj*이 좋다.
                              // 물론 setCallComplete() 같은 origin 클래스에만 있는 거라면
                              // origin* 타입으로 반환하자.
    }

    void main() {
        auto* org = makeOrigin();
        org->setCallComplete(....);

        tstr<obj> bind1(org); // 성공: obj는 origin의 부모 클래스다.
        str bind2(org); // 성공

        obj* cast = bind2->cast<obj>(); // 성공.
        cast->getType().isSub<obj>(); // true
    }
@endcode

@remark origin 자체가 obj 타입으로 사용될 것을 전제로 한 것이기에 일부를 제외하고는 거의 모든 public 함수는
obj 타입의 API와 동일한 것이다. 굳이 origin 타입으로 써야할 필요가 없다.

@remark 호출 자체는 아무런 c++ 컴파일러 제약이 없다. dynamic_cast를 사용한다면 안전하게 형변환이 가능하며,
위의 제약사항을 잘 이해하고 있다면 얼마든지 origin으로부터 getType() 호출해서 cast는 isSub등을 사용해도 상관없다.
요약하면, 의도를 잘 이해를 하고 사용하자는 것이다.



param 클래스
============
param은 말 그대로 파라메터를 표현한다. 이름과 타입을 표현하기 위한 origin 객체에 대한
참조가 있다.



scope 클래스
============
scope는 @ref tnchain을 바탕으로 선언되어 있다.
tnchain이 생소 하다면 그걸 먼저 보고 오자.


@section byeol에서 scope에 대한 개념
scope는 만든 주체가 local(즉, @ref blockExpr), 혹은 @ref baseFunc, 혹은 @ref baseObj 등등
누구냐에 따라 각각 local scope, func scope, obj scope, file scope, pack scope 총 5 종류로 분류한다.
(여기서 pack은 코드상으로는 baseObj에서 파생된 @ref obj와 동일하지만,
byeol에서는 개념적으로 pack scope는 별도로 취급하므로 분리해서 적었다.)


@section scope는 어떻게 사용되는 가
scope는 @ref thread객체가 소유한 @ref frames 에 `add()` 되면서 프로그램의 각 AST의 @ref node들이
scope에 등록된 symbol 들을 접근할 수 있게 된다.
그러나 여기서는 각 scope에 대한 개념적인 설명만 하겠다. 실제로 scope들이 어떻게 생성되고
등록되고 해제되는 지는 @ref frameInteract나 @ref frames를 먼저 참조하면 좋다.


@section local scope
local scope은 함수 내에서 블록문이 실행되면서 생성된다. 블록문이 종료되면 scope이 사라지며,
해당 scope에 참조되는 인스턴스들은 참조 카운트를 1씩 잃는다.
local scope 생성 자체는 최적화를 위해서 @ref blockExpr이 직접 생성/해제하지 않고, blockExpr을
실행하는 쪽에서 @ref frameInteractable인 blockExpr에게 생성하도록 만든다.

@code
    str me::_interactFrame(node& meObj, scope& s, nidx exN) {
        ...
        frameInteract f3(*_blk); // 여기서 local scope이 생성되어 frame에 들어간다.
        return _run(exN);
        // RAII이므로 c++ 블록문 종료와 함께 local scope도 해제된다.
    }
@endcode


@section func scope
func이 소유하는 symbol 들이 저장되는 scope이다. 보통은 func의 sub nodes들에 대한 참조가
func scope으로써 그대로 사용될 것이다.
대표적으로는 func이 소유한 @ref nestedFunc나 func 내에서 정의한 @ref obj나 static variable
들이 여기에 속한다.
이 들은 매 func이 생성될때마다 새로운 객체나 func이 생성되는 것이 아님에 유의하자.
이 scope는 시스템내 유일하게 존재하는 func 객체가 소유한 유일한 sub node들이므로,
이 역시 unique하게 1개씩만 존재하는 셈이다.


@section obj scope
func scope과 유사하게 특정 객체가 소유 중인 func이나 variable들이 소속된 scope를 obj scope라고 한다.
obj는 shares와 owns가 별도로 구분되어 존재하며 상속받은 symbol 들 또한 이 obj scope에 포함된다.
자세한 내용은 @ref obj를 참조하자.


@section file scope
file scope는 말그대로 해당 source code unit에서만 접근 가능한 scope로,
byeol 코드에서 `pack` 보다 위에 정의를 한 symbol은 모두 file scope에 속하게 된다.
예를 들어 byeol 코드로 다음과 같이 작성하면,

@code
    IS_DBG := false # 이건 file scope에 있는 거다.

    ####### 여기서부터는 pack scope ###########
    pack test

    def yourObj # 이건 pack에 속한 객체다.
        age := 3

    IS_DBG := true # 경고: pack과 file scope은 서로 밀접한 관련있으므로
                   #       굳이 중복된 이름을 사용할 필요가 없다.

    main() void
        print(IS_DBG) # true. pack보다 file scope이 우선된다.
@endcode

IS_DBG는 file scope과 pack scope에 각각 1개씩 정의되며, 다른 byeol 파일에서는
IS_DBG를 접근하면 타 파일의 file scope에는 접근이 불가능하므로 pack scope의 IS_DBG
가 접근된다. 결과 false가 아니라 true로 나오게 된다.

@remark file scope는 @ref parser에 의해서 항상 pack scope를 chain 하도록 만들어진다.
chain에 대해서는 @ref tnchain을 참조하자.


@section pack scope
pack 바로 밑에 정의된 symbol 들이 위치한 scope로,
pack 내에서 정의한 함수는 자신의 me를 `pack`으로, 정의한 @ref origin 객체는
자신의 obj scope이 pack scope를 chain 하도록 만들어진다.
왜 이렇게 chain을 거는 지는 @ref frames를 참조하자.
pack scope는 file scope과 달리 @ref manifest에 종속관계만 정의하면 외부에서도 접근이 가능하다.



baseObj 클래스
==============
byeol의 객체를 표현하는 데 있어서 기반 클래스다.
core 모듈은 byeol 언어로 작성된 managed 환경에서의 객체(@ref obj)와 c++ 코드를 사용해서
작성된 native 환경에서의 객체(@ref baseObj) 모두를 구분하지 않고 사용한다. 둘은 모두 @ref node임과
동시에 baseObj 일 뿐이다. 이를 위해서 obj를 baseObj에서 상속받게 함으로써 둘을 같은 클래스 계통으로
묶었다.
그러니, baseObj는 native 객체와 managed 객체의 공통된 기능만 갖는다. 다시말하면, managed 객체인 obj
는 기능적으로 baseObj 보다 항상 더 많은 기능을 갖는다.


@section origin 객체
byeol 언어로 사용자가 정의한, 원본이 되는 타입을 @ref origin 객체라고 한다.
@ref ctor와 같은 생성자 호출을 하면 모두 origin 객체를 복사 생성해서 만들어진다.


@section baseObj는 getOrigin() 함수를 override 하면 된다
c++ 코드로 새로운 baseObj를 정의해서 byeol 코드로 사용하고 싶다면 baseObj를 상속한 c++ 클래스를 만들고
getOrigin()을 override 해서 적절한 baseObj의 origin 객체를 반환하면 된다.
예를들면 이렇다.

@code
    // integer를 표현하는 baseObj에서 상속한 nInt 라는 c++ 클래스가 있다.
    // 이 nInt의 origin의 기반은 nInt라는 c++ 클래스 자체다.
    // c++ 클래스를 기반으로 하므로 정적이다. 동시에 싱글톤으로 표현이 가능하다.
    const baseObj& nInt::getOrigin() const {
        // tbaseObjOrigin을 사용해서 nInt 클래스에 기반한 tbaseObjOrigin 객체를 쉽게 만들 수 있다.
        static tbaseObjOrigin<me> org(tbridger<me>::ctor().ctor<me>().subs());
        const baseObj& supers = super::getOrigin();
        return &supers == this ? org : supers;
    }
@endcode

@ref tbaseObjOrigin은 편의를 위해 추가된 클래스 템플릿이다. 자세한 내용은 해당 클래스를 참조하자.
여기에 @ref tbridger를 사용하면 native의 함수를 추가 코드 없이 간단하게 한줄로 managed 함수로 노출 시킬 수 있다.
@ref nStr에 좋은 예시가 있다.

@code
    // 예시를 위해 실제코드에서 일부를 생략한다.
    class nStr : baseObj {
        // 아래 함수들을 managed 쪽으로도 노출할 거다.
        nint len() const;
        nchar get(nidx n) const;

        // 그리고 `get` 이라는 이름으로 seq를 넣으면, 위의 get(nidx)와 다른 동작을 하도록
        // managed 에서만 추가로 노출해보자.
        // 예를들어 `get(1..3)`을 하면 원 문자열에 대해 index [1, 3) 까지를 짤라서 반환하는
        // 함수를 추가해보자.
    }

    typedef nStr me;

    // origin 객체를 내보내자.
    const baseObj& me::getOrigin() const {
        // baseObj라는 정적타입의 origin이므로 static이 가능하다.
        static tbaseObjOrigin<me> org(
            // 여기서부터 tbridger를 사용해서 c++의 함수를 본따 managed 함수를 생성한다.
            tbridger<me>::ctor().ctor<nStr>()
                .func("len", &me::len) // nStr::len() const는 이 한줄로 managed 에서도 사용 가능해진다.
                .func<nchar, nidx>("get", &me::get) // 타입 파라메터로 파라메터형과 반환형을 명시하면
                                                    // c++의 오버로딩 함수가 있어도 문제없이 노출할 수 있다.
                .func("get", new getSeqFunc())      // 이것은 `get` 이라는 이름으로 `getSeqFunc` 라는 함수를
                                                    // c++로 넣는다.
                .subs());
        return org;
    }


    // 참고로 getSeqFunc은 아래와 같다:
    //  func 부분이므로, 굳이 모든 코드를 이해 못해도 이 클래스와는 관계없다.
    class getSeqFunc: public baseFunc {
        ...
        str eval(const args& a) override {
            // 여기서부터 함수의 동작 부분이다. 가장 먼저 인자에서 seq를 얻어와야 한다.
            WHEN(a.len() != 1) .ret(str()); // 사실 인자 체크가 검증되지 않으면 이 함수는 호출되지 않는다.
                                            // 그래도 혹시 모르니까.
            nStr& me = a.getMe() TO(template cast<nStr>()) OR.ret(str());
            tstr<seq> s = a[0].as<seq>() OR.ret(str());

            nint start = (*s).get().getStart().get();
            nint end = (*s).get().getEnd().get();
            return me.substr(start, end);
        }

        const ntype& getType() const override {
            // 이 함수는 seq 타입을 1개 받는다고 parameter를 정의한다.
            // 반환형은 nStr, 즉, 문자열로 정의한다.
            static mgdType inner("get", ttype<baseFunc>::get(),
                params(*new param("range", new seq(nInt(0), nInt(1)))), false, new nStr());
            return inner;
        }
        ...
    };

@endcode

이제 위 클래스를 pack으로써 노출하게 되면 byeol 코드에서도 nStr::len()이나 getSeqFunc을 사용할 수 있다!
어떻게 pack으로 내보내는지는 @ref packLoading 이나 @ref autoslot 등을 참조하자.
byeol 코드에서는 다음과 같이 사용할 수 있게 된다.

@code
    # nStr의 이름은 byeol 환경에서는 `str`로 변경해서 내보냈다.
    foo(got str) void
        got.len() # 5 반환. 내부적으로 nStr::len()이 호출된다
        got.get(1) # 'e' 반환. nStr::get(nidx) 는 n 번째 인덱스의 문자를 반환한다.
        got.get(2..4) # 'll' 반환. sequence를 넣었으므로 getSeqFunc 함수가 실행된다.

    main() void
        foo("hello")
@endcode

이처럼 tbridger는 native로 작성된 함수를 매우 간단하게 managed 로 노출시킬 수 있다.
좀 더 자세한 tbridger 사용 방법은 해당 클래스를 참조.


@section obj 달리 baseObj의 origin 객체는 하나만 존재한다
obj는 byeol 언어로 작성된 객체를 표현한다. 이 중에서도 `def` 키워드로 작성된 origin 객체는
origin 클래스의 인스턴스로 표현된다.
반면 baseObj는 그 자체로 사용할 수 없으며 이를 상속한 c++의 클래스가 존재한다.
둘의 차이를 잘 이해해보자.
c++ 코드로 봤을때 baseObj의 origin은 정적이지만 obj의 origin은 동적이라는 얘기다. 예를 보자.

@code
    // 앞서서 적은 baseObj의 origin 객체 예제를 다시 보자. static 객체로 되어있음을 알 수 있다.
    // 같은 걸 obj에 대해서도 할 수 있을까?

    // 사용자가 byeol 코드로 다음과 같이 작성했다고 해보자:
    //      def MyObj
    //          foo() void
    //              print("hello")
    // MyObj 라는 타입은 c++에서 봤을때는 동적이다. 그러니 class MyObj 라는 걸
    // 컴파일 타임에 만들 수 없다.
    // MyObj 자체를 byeol에서는 origin 객체라고 하며 이는 `origin` 클래스의 인스턴스로 표현된다.
    origin org(typeMaker::make<obj>(name)); // name == "MyObj"
    // 위와 같이 런타임에 parser에 의해 만들어지기에 싱글톤이 될 수도 static이 될 수도 없다.
@endcode



tbaseObjOrigin 클래스
=====================
baseObj에 대한 @ref origin 객체를 쉽게 정의하기 위해서 사용하는 클래스 템플릿이다.

@remark 먼저 origin와 @ref baseObj를 보고 오는 것이 좋다.

구조나 컨셉은 origin 클래스와 동일하다. 자신의 타입을 shadow 하며, baseObj 타입으로 다뤄지도록 의도한다.
단 사용방법에서 차이가 발생한다. 이는 baseObj 클래스의 컨셉이 obj와 다르기 때문이다.


@remark obj 달리 baseObj의 origin 객체는 하나만 존재한다. 자세한 내용은 baseObj를 참조.



obj 클래스
==========
managed 환경에서의 객체를 표현하는 클래스다.
baseObj의 기능을 확장해서 managed 환경에서만 필요한 scope에 대한 처리나 shares, owns
에 대한 개념을 추가한다.


@section 타입으로써의 obj
c++ 에서 타입은 클래스로 표현되지만 byeol은 클래스란 존재하지 않는다. 객체와 클래스의
구분이 없으므로 `obj` 자체가 타입인 셈이다.
예를들어 다음의 c++ 코드를 보자.

@code
    class A {}; // c++에서 클래스란 곧 타입이다.
    A* a = new A(); // 객체와 클래스는 엄연히 구분된다.


    // byeol 코드:
    //  def myObj
    //      name str
    //      foo() void: ...
    //
    //  myObj2 myObj
    //
    //
    // 위의 코드를 c++로 옮기면 아래와 같다:
    obj myObj = new obj(....); // byeol에서 `def` 로 만든 경우.
    obj* myObj2 = myObj.clone(); // byeol 에서 `myObj2 myObj` 로 객체를 만든 경우.
@endcode

위처럼, managed 환경에서는 객체란 `def 로 정의된 obj`와 `obj로부터 복제된 obj` 2가지의 경로로
생성된 obj만 존재할 뿐, 이 둘은 모두 타입으로써 사용된다. 따라서 이 둘의 구분은 무의미하다.


@section shares, owns
baseObj의 경우는 기반이 c++ native 클래스이기 때문에 객체의 생성도 c++의 `new`와 생성자를
통해서 만들어지며, 이때 해당 클래스에 정의된 멤버변수도 같이 만들어진다.
하지만 byeol 코드를 작성하는 경우는 어떨까?
managed 환경에서는 객체를 표현하는 obj는, 위의 예시의 `name` 과 같은 property 를 가질 수 있다.
managed 환경에서 객체를 정의하는 것은 @ref origin 객체로부터 객체를 복제하는 행위이므로
origin에 clone()를 호출하면 property나 func도 복사가 발생하게 되는데, 이때 func은
어짜피 시스템 내 한개만 있으면 될 뿐 매번 func 객체가 복사될 필요가 없다.
반면 위의 예시의 name 같은 property는 인스턴스마다 다른 값이 들어가야 하므로 복사가 되어야 한다.
이를 효율적으로 하기 위해, 같은 타입의 obj끼리 공유되는 부분들을 shares, 복사가 되는
부분들을 owns로 구분 한다.
따라서 obj의 clone()이 발생하면 shares는 원본인 origin에서 shares에 대한 참조만 가져오고,
owns 부분만 clone를 수행한다. (obj::_cloneEach()를 봐보자.)


@section immutable type
str, int 등 scalar 타입은 모두 immutable 타입이다. 이는 byeol의 호출 전략이
`by object`를 따르는 데서 기인하는 데, java, c#등 c-family에서 자주 사용하는,
`객체에 대한 참조는 얇은 복사, raw 타입은 깊은 복사` 로 동작하는 것이다.
node는 그냥 node일 뿐이며, obj는 자신이 넣어야할 node가 immutable 타입인지 아닌지 알아서는 안된다.
이게 깨지는 순간 다형성도 같이 깨지고 만다.
그래서 객체가 들어왔는데 이를 복사해야하는지, 아니면 참조만 가리키면 되는지는 @ref immutableTactic
을 통해서 판단한다.

자세한 내용은 @ref immutableTactic이나 tscalar를 참조하자.



manifest 클래스
===============
stela 언어로 작성된, pack을 로딩하기 위한 기본정보를 담고 있는 객체다.
`manifest.stela` 파일로부터 stela 모듈을 사용해 파싱된다.



immutableTactic 클래스
======================
str, int 등 scalar타입은 모두 immutable 타입이다. 이는 byeol의 호출 전략이
`by object`를 따르는 데서 기인하는 데, java, c#등 c-family에서 자주 사용하는,
`객체에 대한 참조는 얇은 복사, raw 타입은 깊은 복사` 로 동작하는 것이다.

단 이를 책임져야 하는 부분은 @ref node나 @ref obj 와 같이 컨테이너를 소유한 객체가 아니라
@ref tnmap 과 같은 컨테이너 클래스 자체가 되어야 한다.

obj 입장에서는 node는 그냥 node일 뿐이며, 자신이 소유한 container에 넣어야할
새로운 node가 immutable 타입인지 아닌지를 알아야할 필요가 있어서는 안된다.
이게 깨지는 순간 다형성도 같이 깨지고 만다.
그래서 객체가 들어왔는데 이를 복사해야하는지, 아니면 참조만 가리키면 되는지를 immutableTactic
을 통해서 판단한다.


@section 알고리즘
판단은 단순하게 @ref ntype에 정의된 `isImmutable()` 함수로 판단한다.
scalar type을 구현한 @ref nInt, @ref nStr 등은 자신의 타입을 내보낼때 isImmutable()이 true
로 나오는 타입으로 내보낸다. 이는 meta 모듈의 타입 확장 기능을 통해 구현되어 있다.
자세한 타입 확장 기능에 대한 내용은 @ref type을 참조하자.

immutable 타입으로 판단되면 인자를 바로 넣지 않고 `clone()`을 호출한다.



tmock 클래스
============
주어진 타입 파라메터 T에 대한 일종의 proxy 클래스다.
만약 생성시 T* 로 원본이 될 인스턴스를 넣지 않으면 아무런 동작을 하지 않는 dummy 객체로 동작한다.
최초에는 검증 시간을 최적화 하기 위해 고안되었다. 예를들어 @ref verifier가 특정
symbol이 scope에 있는지 없는지 코드를 검증하려면 실제로 그 객체를 만들기 보다
타입 정보만 redirection 하는 tmock을 대신 생성하기 위해서였다.
현재는 해당 기능은 사용되지 않으며 dummy 객체로 대신 사용중이다.



tbridge 클래스
==============
@ref tbridger 클래스로부터 생성된 c++ native 클래스를 모사하는 baseObj 다.
자세한 내용은 tbridger를 살펴보자.



tbridger 클래스
===============
tbridger는 이름에서부터 알 수 있듯이 c++ native 환경과 byeol managed 환경의 bridge 역할을 담당한다.
그 중에서도 tbridger는 `cpp <--> byeol`의 bridge를 담당한다.
즉, native로 정의한 함수나 클래스를 c++ 코드 몇 줄로 간단히 managed 타입이나 함수로
노출 시키는 게 목적이다.

@remark tbridge를 하나의 클래스가 아니라 컴포넌트 단위로 설계되어 있다.
사용만 한다면 크게 문제가 없지만, 코드를 이해하려 든다면 이쪽 관련 경험이 없을 경우
좀 난감할 수 있다.
그러니 기초적인 사용법을 먼저 보고 감을 잡은 뒤에, 상세한 구조에 대해 살펴보자.

@remark @ref baseObj나 @ref obj 에 대해 미리 살펴보고 오는 것을 추천한다.


@section 기초 사용법
@code
    // 이런 구조체가 2개 있다고 해보자.
    struct window {
        int getX() { return 5; }
        int getY() { return _y; }
        void setY(int newY) { _y = newY; }

        window& new1(int newY) {
            window& ret = *new window();
            ret._y = newY;
            return ret;
        }

        int _y;
    };

    struct openGL {
        int init(window* win) { return win->getY() + win->getX(); }
    };


    // openGL 을 byeol 코드에서도 사용가능 하도록 managed 객체로 만들고 싶다면
    // origin 객체를 정의하고, 그 origin 객체를 참조하는 복사객체를 만드는 것으로
    // 쉽게 managed 객체로 만들 수 있다.

    // 일단 다음과 같이 tbridge를 사용해 origin 객체를 생성할 준비를 해야 한다.
    tbridger<window>::ctor()
        .ctor<window>()
        .func("new1", &window::new1)
        .func("getX", &window::getX)
        .func("getY", &window::getY)
        .func("setY", &window::setY);
    tbridger<openGL>::ctor().ctor<openGL>().func("init", &openGL::init);

    // 이제 tbridger를 사용하면 위의 타입정보를 사용해서 managed 객체를 만들 수 있다.
    node* winBridge = tbridger<window>::make(new window());
    node* winOpenGL = tbridger<openGL>::make(new openGL());

    // 생성한 managed 객체는 다음과 같이 c++ 코드로 사용 가능하다.
    winBridge->eval("setY", args(narr(*new nInt(20))));
    str res = winOpenGL->eval("init", args(narr(*winBridge)));
    res->cast<int>(); // 25가 나온다.
@endcode

이 winBridge는 baseObj 계열의 인스턴스이므로 pack의 일부로써 배포가 가능하다.
배포에 대한 자세한 내용은 @ref slotLoader나 @ref autoslot이나 `sys` 모듈을 살펴보자.
배포가 되었다면 다음과 같이 byeol 코드로 위 c++과 동일한 코드를 사용할 수 있다.

@code
    win := window()
    win.setY(20)

    res := openGL().init(win) # res == 25
@endcode


@section 설계 구조
bridge 컴포넌트의 핵심 클래스들을 간략하게 소개한다.
자세한 동작방식이나 알고리즘은 각 클래스를 참조하길 바란다.

* tbridger는 bridge 컴포넌트의 진입점, Facade 역할을 수행한다.
  tbridger는 각 c++ 클래스를 타입파라메터로 받는 클래스 템플릿이다.
  func()등의 함수를 통해 외부에서 정의한 함수들을 static variable인 subs()에 저장한다.

* tbridge는 tbridger에 등록된 subs를 origin으로 삼아 생성된 baseObj다.
  내부적으로 tbaseObjOrigin<tbridger<T>>과 같은 형태로 origin을 정의하고 있어서,
  tbridger를 통해 subs()를 채워넣은 후 tbridge::getOrigin()을 호출하면,
  tbridge 객체는 origin을 통해 해당 함수들을 갖고 있는 셈이 된다.

* tbridgeFunc는 일반 c++ 멤버함수 포인터를 redirection 하는 managed 환경의 baseFunc 인스턴스를
  생성한다.
  tbridger::func()를 하게 되면 안에서 tbridgerFunc<....>()의 형태로 tbridgeFunc 인스턴스를 만들게 된다.
  tbridgeFunc은 내부적으로 마샬링을 통해서 c++ native type(node*, int 등)을 적절한
  managed type(str, nInt)으로 변경한다.
  반환값을 내보낼때도 동일하게 마샬링을 적용한다.

* @ref tmarshaling은 위에서 언급한 마샬링을 처리한다.

* tbridgeCtor은 생성자를 위한 함수를 표현한다.
  managed 에서의 @ref ctor은 생성자 함수일 뿐 객체의 생성에는 관여하지 않는다.
  이는 인스턴스 생성과 생성자의 호출이라는 역할을 분리시키고, 상속 관계이 있는
  부모클래스의 생성자를 호출하는 로직을 간결하게 만들기 위한 것이다.
  그러나 tbridgeCtor은 생성자를 c++ 문법에 맞게 표현해야 하기 때문에 new를 통한 객체 생성과
  생성자의 호출을 별도로 분리하기가 쉽지 않다.
  따라서 tbridgeCtor은 `new` 키워드를 통해서 생성자 함수의 redirection과 객체의 생성을 모두
  관여한다.

* tbridgeClosure는 c++의 람다함수를 tbridger를 통해서 노출시킬 수 있도록 도와준다.
  원리 자체는 tbridgeFunc과 크게 다르지 않다. 다만 함수포인터 대신 람다를 std::function으로
  받아 처리한다.


@section bridge 흐름
사용자가 bridge API를 사용했을때, 위의 소개한 각 클래스들이 어떠한 순서로 상호작용하는지
흐름을 간략하게 적겠다.
먼저, 위의 코드를 다시 가져오자.

@code
    // 사용자가 아래와 같이 했다고 가정하자.
    tbridger<window>::ctor()
        .ctor<window>()
        .func("new1", &window::new1)
        .func("getX", &window::getX)
        .func("getY", &window::getY)
        .func("setY", &window::setY);
@endcode

이때 다음과 같은 순서로 동작한다.

1. tbridger<window>::ctor()이 호출된다.
2. tbridger<T>는 모든 public API를 호출하면 _get() 함수를 호출한다.
3. tbridger<T>::_get()은 자신의 static variable을 반환하는, 싱글톤 객체를 반환하는 함수다.
   즉 tbridger<T>는 모노스테이트 패턴으로 되어있다는 걸 알 수 있을 것이다.
4. tbridger<T>::ctor()은 `new tbridgeCtor<...>()`을 통해 생성자 함수를 만들어 `_get().subs().add()`
   를 사용해서 tbridger<T>에 추가한다.
5. 이하 tbridger<window>::func()도 비슷하게 반복 됨.

그 후, 사용자는 다음과 같이 객체를 만든다.

@code
    node* winBridge = tbridger<window>::make(new window());
@endcode

이때 `tbridger<window>::make()` 는 인자로 들어온 native 인스턴스인 window* 를 tbridge<window>() 생성자에 넘긴다.
그리고 사용자는 만든 객체를 통해 함수를 호출한다.

@code
    winBridge->eval("setY", args(narr(*new nInt(20))));
@endcode

이때 다음과 같은 흐름으로 c++ native 함수가 호출된다.

1. tbridge<window>::eval(name, args) 가 넘겨진다.
2. tbridge<window>는 부모클래스인 node::eval(name, args)의 동작에 의해서
   subs 에서 name과 args는 처리할 수 있는 sub node를 찾는다.
   이때 window::setY를 바탕으로 생성된 tbridgeFunc이 매치된다.
   그 후, node::eval(name, args)는 _onEvalSub(tbridgeFunc, args)를 호출한다.
3. baseObj::_onEvalSub(tbridgeFunc, args) 에서 args에 setMe(this)를 통해 tbridge<window>를 주입한다.
   그리고 node:;_onEvalSub(tbridgeFunc, args)에 의해서 tbridgeFunc.eval(args)가 호출된다.
4. tbaseBridgeFunc::eval(args)는 args.evalAll(getParams())를 통해서 args를 각 parameter로
   필요시 묵시적 형변환을 사용해서 인자를 추출한다.
   그리고 추출된 인자를 _runNative(args)로 호출한다.
5. tbridgeFunc::_runNative(args)는 마샬링을 위해 tmarshaling을 사용한다.
6. tmarshaling은 nInt로 들어온 인자를 c++ native type인 int로 변환하기 위해 marshaling의
   toNative()를 호출한다.

@code
    template <> struct _nout tmarshaling<nint, false>: public tnormalMarshaling<nint, nInt> {};

    template <typename tnativeType, typename tmarshalType> struct tnormalMarshaling: public metaIf {
        typedef tmarshalType mgd;
        typedef tnativeType native;

        static native toNative(node& it) { return ((mgd&) it).get(); } // <--- 여기!
        static str toMgd(native it) { return str(new mgd(it)); }
        ...
    };
@endcode

7. toNative()는 builtin 객체인 nInt::get()을 호춣한다. 결과 int형 값이 반환된다.
8. tbridgeFunc::_marshal()은 parameter pack을 사용해서 위의 6,7번 과정을 각 인자마다 반복 수행해서
   native 타입으로 expand 하여 함수포인터를 실행한다.

@code
    template <typename T, template <typename, nbool> class Marshaling, typename... Args>
    class tbridgeFunc<void, T, true, Marshaling, Args...>: public tbaseBridgeFunc<void, T, Marshaling, Args...> {
        .....
        template <size_t... index> str _marshal(args& a, std::index_sequence<index...>) {
            ....
            (me.*(this->_fptr))(
                Marshaling<Args, tifSub<typename typeTrait<Args>::Org, node>::is>::toNative(a[index])...);
            ....
        }
        ....
    };
@endcode




tucontainable 클래스
====================
byeol 언어에는 기본적으로 array와 map, seq 를 지원한다.
tucontainable 클래스는 이때 array와 같은 index를 입력받아 임의의 타입 T를 반환하는
container 클래스의 기본 인터페이스를 정의한다.


@section native 타입을 managed 타입이 상속한다.
byeol 언어는 AST를 그대로 프로그램 실행으로 이용하는 구조이기 때문에 c++ native 클래스를
그대로 managed 타입으로 노출시키면, native API와 managed API가 동일해지므로 이점이 있다.
이를 원활하게 하기 위해서, 기본 인터페이스를 tucontainable로 정의하고, 이걸 구현한
c++ native 클래스를 정의한다.
byeol에 사용할 managed 타입은 이 native 클래스를 상속한 후, bridger를 사용해 쉽게
노출시키는 전략을 사용한다.
이는 모든 컨테이너 클래스에 적용된다.


@section native 타입에는 이름 앞에 `n`이 붙는다.
n은 `native`의 첫글자를 딴 것이다.
위에서 설명한 대로, 컨테이너 클래스는 native 클래스와 그걸 상속한 managed 클래스가 나오게 된다.
native 클래스는 임의의 타입에 대해서도 동작해야 하므로 클래스 템플릿으로 정의된다.
그래서 native 환경에서 사용하는 `tnarr`과 managed 환경에서 사용할 `arr` 과 같이 하나의
컨테이너에 대해 2벌씩 클래스가 나온다.


@section `t` prefix
컨벤션 규칙에 따라, 클래스 템플릿인 경우는 prefix `t`가 붙는다.
그리고 `t` 빠진 타입을 typedef 로 선언하는 경우가 있는데 이는 해당 클래스 템플릿의 기본 파라메터를
넣은 것을 의미한다.
예를들어 클래스 템플릿인 `tnarr`의 기본 타입 파라메터인 @ref node를 넣은걸 @ref narr이라고 한다.
@ref tstr도 마찬가지로 `tstr<node>` 를 @ref str 이라고 선언하고 있다.


@section 컨테이너 기본 제공 API
모든 컨테이너는 원소를 추가하는 `add()`, 삭제하는 `del()`, 반복자를 제공하는 `begin(), end(), iterate()`,
역방향 반복자를 제공하는 `rend(), rbegin(), riterate()`, 기존 원소를 대체하는 `set()`,
원소가 존재하는지 검사하는 `in()` 을 제공한다.


@section R과 RSquare
tucontainable은 본래 index에 대해 타입파라메터 T를 원소로 반환하는 컨테이너다.
그러니 타입 파라메터가 T만 있어도 충분할거라 생각하기 쉽지만 실제로는 R과 RSquare라는
타입을 추가로 갖고 있다.

* R은 Reference의 약자로 대부분의 타입T에 대한 참조를 내보내야 하는 경우에 사용된다.
일반적인 경우는 T*가 될 것이다.

* RSquare는 non nullable 참조자를 내보내는 경우에 사용되는 타입이다.
만약 R이 non nullable이라면 R이 그대로 사용한다. 일반적인 경우에는 T&가 될 것이다.

이렇게 2가지 타입을 추가로 정의하는 이유는 `nseq` 때문이다.
nseq는 그 기본 형태가 index를 기반으로 하는 int 배열과 유사하다.
다만 반환 타입은 참조가 될 수 없다. seq의 범위가 몇 억에 가깝다면 사용하지도 않을
몇 억개의 int 원소를 다 가지고 있을 필요가 없다.
그래서 nseq는 99% API가 ucontainable과 동일하나 반환형이 nInt*가 아니라 nInt 여야
한다는 차이만 있을 뿐이다.



tbicontainable 클래스
=====================
byeol 언어에는 기본적으로 array와 map, seq 를 지원한다.
tbicontainable 클래스는 이때 map과 같은 key를 입력받아 임의의 타입 T를 반환하는
container 클래스의 기본 인터페이스를 정의한다.


@section native 타입을 managed 타입이 상속한다.
byeol 언어는 AST를 그대로 프로그램 실행으로 이용하는 구조이기 때문에 c++ native 클래스를
그대로 managed 타입으로 노출시키면, native API와 managed API가 동일해지므로 이점이 있다.
이를 원활하게 하기 위해서, 기본 인터페이스를 tucontainable로 정의하고, 이걸 구현한
c++ native 클래스를 정의한다.
byeol에 사용할 managed 타입은 이 native 클래스를 상속한 후, bridger를 사용해 쉽게
노출시키는 전략을 사용한다.
이는 모든 컨테이너 클래스에 적용된다.


@section native 타입에는 이름 앞에 `n`이 붙는다.
n은 `native`의 첫글자를 딴 것이다.
위에서 설명한 대로, 컨테이너 클래스는 native 클래스와 그걸 상속한 managed 클래스가 나오게 된다.
native 클래스는 임의의 타입에 대해서도 동작해야 하므로 클래스 템플릿으로 정의된다.
그래서 native 환경에서 사용하는 `tnmap`과 managed 환경에서 사용할 `map` 과 같이 하나의
컨테이너에 대해 2벌씩 클래스가 나온다.


@section `t` prefix
컨벤션 규칙에 따라, 클래스 템플릿인 경우는 prefix `t`가 붙는다.
그리고 `t` 빠진 타입을 typedef 로 선언하는 경우가 있는데 이는 해당 클래스 템플릿의 기본 파라메터를
넣은 것을 의미한다.
예를들어 클래스 템플릿인 `tnmap`의 기본 타입 파라메터인 @ref node를 넣은걸 @ref nmap이라고 한다.
@ref tstr도 마찬가지로 `tstr<node>` 를 @ref str 이라고 선언하고 있다.


@section 컨테이너 기본 제공 API
모든 컨테이너는 원소를 추가하는 `add()`, 삭제하는 `del()`, 반복자를 제공하는 `begin(), end(), iterate()`,
역방향 반복자를 제공하는 `rend(), rbegin(), riterate()`, 기존 원소를 대체하는 `set()`,
원소가 존재하는지 검사하는 `in()` 을 제공한다.



nseq 클래스
===========
@ref seq의 기반이 되는 @ref ucontainable 를 구현한 클래스로, int 를 받아서 적절한 int를 반환하는
범위형 컨테이너다.
예를들어 byeol 코드로 `3..5` 라고 정의한 seq가 있다면 해당 seq[0]은 3, seq.len() 은 2가 나오게 된다.



smultimap 클래스
================
byeol 에서는 AST에서 node를 구성할때 단순하게 map을 사용할 순 없으며 multimap을 사용해야 한다.
(자세한 내용은 @ref node를 참조.)
다만 여기서 중요한 점은 원소의 삽입 순서는 곧 scope의 우선순위와도 직결되는 문제이기 때문에
삽입된 순서를 기억하고 유지할 필요가 있으므로 삽입된 순서를 기억하는 multimap을 별도로
구현해 사용하고 있다.


@section API 룩 앤 필은 std 라이브러리를 최대한 비슷하게 구성한다
이는 @ref tnarr또한 내부적으로는 vector를 사용하므로 같은 상황에 같은 컨벤션이 되도록
의도적으로 구성한 것이다.


@section 삽입 순서를 관리하는 알고리즘
중요한 것은 `_end` 멤버 변수다. 이는 여타 stl 라이브러리 구현물처럼 마지막 원소 다음을
가리킨다. 이를 통해서 iterator == end 일 경우, 끝에 도달한걸로 사용하곤 했을 것이다.
end는 wrap이라는 일종의 linked list의 node 역할 같은 존재이며 STL처럼 양방향 정보를 가지고 있다.
또한 end는 next가 다시 첫번째 원소를 가리키는, 일종의 원형 linked list로 구현되어 있는 셈이다.
이 점을 이용해서 `_link()` 라는 함수에서 삽입 순서를 기억하기 위한 linked list를 구성한다.


@section 왜 삽입 순서를 기억해야만 하는가?
when a nested function is exported to a closure, there is a requirement to capture and
maintain the local scope at that time. But, local variables that occurred after the time of
capture should have no relation to the nested function.
For this reason, closures don't capture the entire scope, but rather only capture
variables that belong to the local scope up to the point where the closure is created.
It's easy to think that implementing this requires a shallow copy of the scope, but I
solve this problem without copying using a container class called tnchain and link().
However this requires tnchain to guarantee that its iterators traverse in insertion
order, making it impossible to directly use STL's multimap.
자세한 사항은 @ref tnchain을 참조.



tnchain 클래스
==============
@ref node가 AST의 근간을 이루는 가장 중요한 클래스라고 한다면,
tnchain은 AST의 데이터를 보관하는 컨테이너로써 가장 중요한 클래스라 할 수 있다.


@section 목적
tnchain은 말그대로 컨테이너를 chain하면서 관리하는 클래스로, 여러 원소들을 하나의
그룹으로 묶어서 참조하거나, 순회하거나, 다른 곳에 있는 컨테이너를 여기에 참조만
chain 해서 겉으로는 마치 하나의 flatten 된 map 처럼 보이도록 하는 기능을 가지고 있다.
그래서 tnchain을 사용하면 함수 호출 1번으로 간단하게 달성할 수 있다.
쉽게 비유하면 linked list의 각 node를 배열로 구성한 컨테이너를 떠올리면 좋다.


@section tbicontainable로도 대부분의 기능을 사용할 수 있다.
tnchain의 가장 중요한 컨셉으로, 외부 사용자는 bicontainer를 하나 받았을 뿐,
이것이 실체가 @ref tnmap인지, tnchain인지는 몰라도 상관없어야 한다.
물론 이것은 tnchain을 bicontainable로써 `add(), del(), len()` 등을 할때의 얘기이며
`link()` 와 같이 tnchain의 고유 기능을 사용하려면 tnchain이라는 걸 알아야만 한다.


@section link
tnchain의 존재의의라고 봐도 과언이 아니다.
tnchain은 내부적으로는 타입 파라메터로 선언한 defaultContainer를 한개 가지고 있으며,
next, prev라고 하는 tnchain에 대한 참조를 갖는 일종의 linked list의 node와 비슷한 구조로
되어 있다.
`link(const tnchain<T>&)`로 새로운 chain 객체를 넘기면 this의 container의 next에 새로운
chain이 연결된다. 이때 탐색을 하면 tnchain은 자신의 defaultContainer를 모두 탐색 한 후
바로 다음 next chain의 defaultContainer로 순회한다. 따라서 외부에서 봤을때는 this container에
next chain의 원소들이 복사되어 들어간 것처럼 코드를 작성할 수 있다.
다음 예시를 참고하자.

@code
    nchain chn1; // defaultContainer를 명시하지 않으면 tnmap이 사용된다.
    chn1.add("0", new myNode(0));
    chn1.add("1", new myMyNode(1));
    // chn1은 {0, 1} 상태.

    nchain chn2;
    chn2.add("6", new myNode(6));
    chn2.add("5", new myMyNode(5));
    // chn2는 {6, 5} 상태임.

    nchain chn3;
    chn3.add("2", new myNode(2));
    chn3.add("3", new myMyNode(3));
    // chn3은 {2, 3} 상태임.

    chn1.getNext(); // nullptr 아직 연결 안되어있음.
    chn1.link(chn2); // chn1 -> chn2
    chn2.link(chn3); // chn1 -> chn2 -> chn3
@endcode

위 시점에서, 다음과 같은 도식으로 데이터가 구성되어 있는 상태다.

        ┌─────────────┐      ┌─────────────┐      ┌─────────────┐
        │    chn1     ├─────►│     chn2    ├─────►│    chn3     │
        ├─────────────┤      ├─────────────┤      ├─────────────┤
        │    tnmap    │      │    tnmap    │      │   tnmap     │
        ├─────────────┤      ├─────────────┤      ├─────────────┤
        │"0":myNode(0)│      │"6":myNode(6)│      │"2":myNode(2)│
        │"1":myNode(1)│      │"5":myNode(5)│      │"3":myNode(3)│
        └─────────────┘      └─────────────┘      └─────────────┘

이제 위의 데이터를 접근해보자.

@code
    chn1.len(); // 6
    chn1.getContainer().len(); // 2
    chn2.len(); // 4
    chn2.getContainer().len(); // 2

    // chn1은 chain 3개가 연결된 하나의 큰 컨테이너인 상태.
    // 컨테이너의 add()를 하면 가장 뒤에 추가되므로,
    // myNode(7)은 chn3.getContainer() 에 add 됨.
    chn1.add("7", new myNode(7));
    chn1.rbegin().get(); // myNode(7)를 가리킴.
@endcode


@section iter 기반 link
link는 사실 tnchain 타입으로 link를 하는 게 아니라 @ref iter 기반으로 link를 한다.
실제로 다음 코드를 보자.

@code
    nbool tnchain<K, V, defaultContainer>::link(const ME& new1) { return link(new1.begin()); }
@endcode

tnchain을 넘기면 안쪽에서 begin()을 통해 iter를 꺼내서 link를 시도한다.
그러면 iter를 기반으로 한다는 건 어떤 의미를 가질지, 다음 예시를 보며 생각해보자.

@code
    nchain m;
    m.add("meat", new nInt(1));
    m.add("banana", new nInt(2));
    nchain m2;
    m2.add("apple", new nInt(3));
    m2.add("banana", new nInt(4));
    m2.add("pineapple", new nInt(5));
    nchain m3;
    m3.add("mango", new nInt(6));
    m3.add("melon", new nInt(7));

    m.link(m2.rbegin() + 1); // banana
    m2.link(m3.begin() + 1); // melon
@endcode

위 처럼 작성하면 아래와 같이 데이터가 구성된다.

       ┌─────────────────┐    ┌────────────────────┐      ┌────────────────┐
       │m                ├─┐  │m2                  ├──┐   │m3              │
       ├─────────────────┤ │  ├────────────────────┤  │   ├────────────────┤
       │"meat": nInt(1)  │ │ ▲│"apple": nInt(3)    │  │   │"mango": nInt(6)│
       │"banana": nInt(2)│ └►││"banana": nInt(4)   │  └─►││"melon": nInt(7)│
       └─────────────────┘    │"pineapple": nInt(5)│     ▼└────────────────┘
                              └────────────────────┘

m부터 순회를 한다고 가정했을 때, m 마지막 원소 다음 원소는 m2의 rbegin() + 1 인 "banana"
가 될 것이다. 포인트는 begin() + 1이 아닌 역방향 iter를 link한다는 점이다.
따라서 "banana" 다음으로 순회할 원소는 역방향으로 진전해서 "apple"이 될 것이다.
정리하면 m을 @ref tbicontainable 타입으로만 받는 외부에서는 다음과 같은 하나의 컨테이너라고
생각할 것이다. 이를 테면 다음과 같다.

                               ┌─────────────────┐
                               │       m         │
                               ├─────────────────┤
                               │"meat": nInt(1)  │
                               │"banana": nInt(2)│
                               │"banana": nInt(4)│
                               │"apple": nInt(3) │
                               │"melon": nInt(7) │
                               └─────────────────┘

link가 가진 강력함을 느낄 수 있으면 좋겠다. byeol은 @ref scope를 처리하는 프로젝트인
만큼 데이터의 묶음에 대한 참조를 수시로 변경하고 구성하고 조립하는 일이 빈번하게 발생한다.
이때마다 원소 1개씩 참조를 추가하거나 변경하는 것보다 훨씬 간결하고 최적화된 방법을 link는
가능하게 해준다.




arr 클래스
============
@section native API를 byeol 환경에서도 그대로 사용하게 한다.
byeol 언어는 AST를 그대로 프로그램 실행으로 이용하는 구조이기 때문에 c++ native 클래스를
그대로 managed 타입으로 노출시키면, native API와 managed API가 동일해지므로 이점이 있다.
노출할때는 @ref tbridger를 사용해서 몇 줄만으로도 간단하게 노출 시킬 수 있다.



frame 클래스
============
frame은 현재 실행중인 코드블록에서 접근가능한 symbol을 관리하는 클래스다.
여러개의 scope을 동적으로 chain 하는 방식으로 최적화된 방법으로 symbol 목록을 제공한다.
사전에 @ref scope과 @ref tnchain을 알고 있어야 한다.


@section frame은 함수 호출과 동시에 만들어 진다.
@ref baseFunc이 `eval()` 되면 baseFunc은 scope 소유자인 obj, this, blockExpr에
대해서 각각 @ref frameInteract를 사용해서 `inFrame()` 를 호출한다.
각 클래스의 `inFrame()`은 자신이 가진 scope를 frame에 적절하게 add() 하는 동작을 한다.


@section scope의 연결
baseFunc은 이 모든 frameInteract를 트리거하는 시작점이다. obj, func, blockExpr 순으로 호출한다.
baseObj는 frame 객체를 새로 만들어 frames에 추가하고 자신의 subs()와 `me` 참조자를 넣어둔다.
obj는 baseObj 동작에 더해서 현재 file에 대한 scope도 추가한다. (이때 pack scope도 딸려서 추가된다.)
func은 자신의 scope인 subs()를 frame에 등록하고, args를 frame에 추가한다.
blockExpr은 local scope으로 사용하기 위한 빈 scope을 하나 생성한다.

위와 같은 과정을 거쳐서, func이 `eval()` 될때 새로운 frame객체는 최소 5개의 scope가 등록된다.


@section frame의 탐색
위의 scope 부분만 설명을 보면,
> frame은 scope에 대한 배열을 가지고 있구나
라고 오해할지도 모른다. frame은 @ref node를 상속하므로 subs()를 제공한다.
subs()는 vector<scope> 같은 배열이 아니라 scope 타입으로만 반환하기 때문에 앞서서
여러개의 scope을 연결해둔 scope 객체를 반환하므로, symbol을 찾기 위해 접근할때에는
여러개의 scope이 연결되어 있는게 아니라 마치 처음부터 하나의 컨테이너를 순회하는
것처럼 간결하게 코드를 작성할 수 있다.
이는 @ref scope이 @ref tnchain으로 구현되어 있기 때문에 가능한 일이다.



frames 클래스
=============
하나의 @ref thread에 속한 여러 @ref frame을 관리한다.
byeol에서 모든 코드는 사실상 함수 안에 있다고 봐도 과언이 아니다.
코드를 실행한다는 것은 함수를 실행한다는 것이며, 함수를 실행할때 frame 객체가 생성되어
여러 @ref scope 들을 잘 적층시켜 올바르게 symbol을 읽어올 수 있도록 처리한다.
@ref frame @ref scope이 생소하다면, 먼저 보고 오자.


@section frame의 적층
AST나 @ref frame, @ref closure을 만들때면 필수적으로 복잡한 @ref scope의 구성을 실시간으로
만들 것을 요구받게 된다.
예를들어, 다음의 byeol 코드를 보자.

@code
    IS_DBG := false
    name := "kniz"

    pack test
    age := 57

    def yourObj
        age := 3
        foo(newAge int) void
            age = newAge
            print(age)

    main() void
        name := "unknown"
        yourObj.foo()
        if IS_DBG
            print("I'm $name, $age yo.")
@endcode

main() 함수 안에서 yourObj.foo()를 호출하면 frame은 어떻게 구성되어야 할지
잠시 생각해보자.
main() 함수는 test라는 pack 안에 있으므로, main() 함수가 호출 될때 frame에는
pack scope와 main() 함수scope, main() 함수가 생성한 local scope, 총 3개가 frame에
순서대로 들어있을 것이다. 이 상황에서 yourObj.foo()를 호출하면 어떻게 될까?

정답은 local scope 위에 yourObj의 object scope가, 그 위에 foo() 함수 scope, 그리고
그 위에 foo() 함수가 생성한 local scope가 올라가게 된다.

표로 표현하면 이렇다.

   #          scope     symbol
           ┌─────────┬───────────────┐
        ▲  │  local  │msg("age=3")   │
        │  ├─────────┼───────────────┤
        │  │ foo(int)│newAge int     │
        │  ├─────────┼───────────────┤
        │  │         │foo(newAge int)│
        │  │ yourObj ├───────────────┤
        │  │         │age(3)         │
        │  ├─────────┼───────────────┤
frame #2│  │         │IS_DBG(false)  │
        │  │  file   ├───────────────┤
        │  │         │name("kniz")   │
        │  ├─────────┼───────────────┤
        │  │         │age(57)        │
        │  │         ├───────────────┤
        │  │  pack   │yourObj        │
        │  │         ├───────────────┤
        ▼  │         │main()         │
           ├─────────┼───────────────┤
        ▲  │  local  │name("unknown")│
        │  ├─────────┼───────────────┤
        │  │ main()  │empty          │
        │  ├─────────┼───────────────┤
        │  │         │IS_DBG(false)  │
        │  │  file   ├───────────────┤
frame #1│  │         │name("kniz")   │
        │  ├─────────┼───────────────┤
        │  │         │age(57)        │
        │  │         ├───────────────┤
        │  │  pack   │yourObj        │
        │  │         ├───────────────┤
        │  │         │main()         │
        ▼  └─────────┴───────────────┘

가장 좌측 열은 쌓인 frame를 표현한다. index가 높을 수록 최신 frame이며, 하나의 frame은
하나의 함수 호출시 생성된다고 보면 된다.
각 scope에 대한 분류는 @ref scope를 참조하자.

@remark 중요한 포인트는 frame #2에는 yourObj 바로 밑에 pack scope이 다시 나온다는 점이다.
실제로도 사용자가 yourObj를 `def` 로 정의할때, yourObj의 함수 안에서는 pack에 속한
symbol에 접근이 가능해야 한다는 걸 알 수 있다.


@remark 왜 pack scope을 또 넣어야 하는지 의문을 가질 수 있다.
> 어짜피 frame #1 맨 밑에 pack scope 이 존재하므로 #2 밑에 pack scope를 또 넣어야 하나?
라고 생각 할 수 있다.

하지만 위의 예시의 byeol 코드를 살짝 수정해보자.

@code
    name := "kniz"

    pack test
    def yourObj
        age := 3
        foo(newAge int) void
            name # <--- 이 name은 어떤 값일까?

    main() void
        name := "unknown"
        yourObj.foo()
@endcode

중간의 `name`은 어떤값이 나올지 잠깐 생각해보자.
아마도 `kniz`를 예상했을 것이다. symbol을 탐색할때는 @ref scope에서 다룬 것처럼, @ref node가
sub node를 탐색 할 때처럼 index[0] 에서부터 순차탐색을 한다. (둘다 동일한 클래스를
소유하고 있으니 당연하다.)
이때 중간에 frame#2에 pack scope과 file scope을 제거한다면 다음과 같이 frame이 구성될 것이다.

           ┌─────────┬───────────────┐
        ▲  │  local  │msg("age=3")   │ <--- 여기서부터 아래 방향으로 찾으니,
        │  ├─────────┼───────────────┤
        │  │ foo(int)│newAge int     │
frame #2│  ├─────────┼───────────────┤
        │  │         │foo(newAge int)│
        │  │ yourObj ├───────────────┤
        │  │         │age(3)         │
        ▼  ├─────────┼───────────────┤
        ▲  │  local  │name("unknown")│ <--- 여기서 hit 된다.
        │  ├─────────┼───────────────┤
        │  │ main()  │empty          │
        │  ├─────────┼───────────────┤
        │  │         │IS_DBG(false)  │
        │  │  file   ├───────────────┤
frame #1│  │         │name("kniz")   │
        │  ├─────────┼───────────────┤
        │  │         │age(57)        │
        │  │         ├───────────────┤
        │  │  pack   │yourObj        │
        │  │         ├───────────────┤
        │  │         │main()         │
        ▼  └─────────┴───────────────┘

위의 표처럼, 결과는 main함수 안에 지역변수로 있는 name인 "unknown"이 나올 것이다.
이를 막으려면 나처럼 중간에 pack scope을 끼워넣거나, 아니면 pack scope는 별도의 참조로 두어서
frame #2에 없으면 pack scope에 탐색하는 branching을 하는 코드를 끼워넣는 것 뿐이다.
하지만 if-else 로 scope 탐색하는 장소를 분리시키는 것보다 오직 단 하나의 커다란
배열에서 위에서부터 아래로 순차탐색하는 것이 더 로직이 간결할 것이라는 건 쉽게 납득할 수 있다.

게다가, @ref tnchain은 고유의 link() 를 통해서 위처럼 frame이나 scope을 엮어서
마치 하나의 컨테이너인 것처럼 관리하고 탐색하는 데 특화되어 있다.
이 과정에서 어떠한 symbol이나 scope의 복사도 일어나지 않는다.

chain은 link로 연결할때 하나의 chain 객체만 가능한게 아니다.
여러개의 chain으로 묶인 컨테이너들을 연결하는 것도 가능하기 때문에 @ref parser가
obj를 생성할때 pack과 file을 앞에 chain으로 미리 연결해두면 해당 obj의 scope를
frames에 추가하는 것만으로도 obj와 그 앞에 있는 file, 그 앞에 연결된 pack scope까지
한번에 연결할 수 있다.
그러니 이미 형성된 chain의 일부를 제외해서 별도 참조를 만들고, 그거에 대한 로직도 별도로
만드는 알고리즘은 상대적으로 불리하다.



cppPackLoading 클래스
=====================
@ref slotLoader에 의해 cpp 패키지를 로딩할 때 사용되는 @ref packLoading 중 하나다.
이름 그대로 C++ pack 을 동적 라이브러리 파일에서 로딩하는 역할을 한다.


@section entrypoint
indep 모듈의 @ref dlib 을 사용해서 동적 라이브러리를 로딩한다. entrypoint는 이미 정의되어 있는
ENTRYPOINT_NAME의 값을 사용한다.



packLoading 클래스
==================
@ref slotLoader에 의해 패키지를 로딩할 때 사용되는 추상 클래스다.
@ref packMakable 인터페이스가 핵심 API를 제공한다.
packLoading은 rel(), parse()와 verify() 함수를 제공하며, 이는 @ref autoslot의 상태
와 깊은 관련이 있다.




slotLoader 클래스
=================
외부 pack을 로딩하는 역할을 담당한다. addPath()로 탐색 경로를 추가하고,
`load()` 를 호출하면 pack을 불러올 수 있다.

기본 사용법은 다음과 같다.

@code
    nmap ret;
    errReport report;

    slotLoader()
        .setReport(report) // report 를 넣지 않으면 dumReport가 대신 사용되며 err는 기록되지 않는다.
        .setBaseSlots(*ret)
        .addPath("pack/")
        .load();

    ret.len(); // 로딩된 slot 개수 반환
@endcode


@section manifest와 entrypoint
pack 로딩 중에는 필연적으로 @ref manifest를 파싱한다. 자세한 내용은 manifest 참조.
manifest를 통해 가장 중요한 정보는 endtrypoint다. entrypoint는 pack이 어떠한 종류의
라이브러리를 포함하고 있는지를 나타낸다.
예를들어 pack에 c++ 동적 라이브러리가 포함되어 있다면 entrypoint는 `cpp`가 되며,
byeol 라이브러리라면 `byeol`이 된다.
slotLoader는 manifest를 읽은 후 @ref autoslot을 생성하고 entrypoint에 따라 적절한 @ref packLoading 인스턴스를
autoslot에 추가한다.

@remark 하나의 pack 라이브러리는 여러개의 entrypoint를 가질 수 있다.


@section errReport
@ref errReport는 err 들을 수집해서 관리하는 클래스다.
slotLoader에 errReport 인스턴스를 전달할 수 있으며, 이때 slotLoader가 pack 로딩 중에
발생한 err 들을 errReport에 기록한다.


@remark 경로는 항상 재귀적으로 탐색된다. 즉, 하위 디렉토리에 있는 pack들도 모두 로딩된다.


@remark 파일 탐색, 동적 라이브러리 로딩 등 플랫폼 종속적인 기능들은 indep 모듈에 위임한다.


@remark base slots는 map 컨테이너 타입으로, pack 로딩을 통해 불러온 slot들이 저장된다.



baseErr 클래스
==============
byeol 언어에서의 err 클래스 계통의 가장 base 클래스다. 에러처리에 대한 공통 로직과
인터페이스를 포함한다.


@section byeol 문법상 error 개념과 구현의 괴리
byeol 문법상으로는 에러는 2종류 구분한다. 하나는 known error로 `?`로 표현되며,
다른 하나는 exception으로 errorable 타입으로 명시하지 않는 상황에서 에러가 반환되는
케이스를 exception이라고 한다.

하지만 구현상으로는 둘은 완전히 동일한 에러 객체다. 에러는 @ref parser나
@ref verifier가 발생시킨, native 상에서 발생한 @ref nerr와 byeol 코드로 인해
발생한 @ref err, 2개가 에러의 발생원에 의해 구분되고 있을 뿐이다.


@section err는 frames에 대한 강한 참조를 갖는다.
이 frame을 사용해서 callstack 정보를 제공한다.
@ref frame에서 설명한 것처럼 frame은 함수 호출시 baseObj에 의해서 생성된다.
이후 frame은 @ref frames에 의해서 `del()` 되는데 이때 객체의 강한 참조를 잃어버릴 뿐
heap에서 바로 삭제가 되진 않는다. (이 프로젝트에서 memlite 모듈의 @ref tstr에 의한
레퍼런스 카운팅 없이 직접 heap에서 new/delete를 하는 경우는 극히 드물다.)
그러므로 err가 살아있는 한 참조하는 frame 데이터 또한 유지된다.


@remark err는 @ref errReport와 관련이 깊다. 궁금하면 참조하자.


@section nerr은 주로 core 모듈의 @ref __core_when__ 에 의해서 만들어진다.
다음과 같은 코드로 이뤄진다.

@code
    WHEN_NUL(stmt).exErr(IS_NUL, getReport(), "stmt").ret(blk);
@endcode

위 코드는 stmt가 nullptr일 경우 IS_NUL이라는 에러가 getReport()로 반환되는
@ref errReport 객체에 추가되고 blk를 반환하면서 함수가 종료된다.


@section dumpable과 log
로그는 해당 에러를 clog 모듈을 사용해서 로깅한다.
반면 dump()는 callstack을 포함해서 최대한 많은 정보를 노출한다.


@section errCode
관리를 위해서 nerr는 errCode로 관리된다. nerr는 주로 @ref parser나 @ref verifier에 의해서
생성되는 데, 이는 문법에러가 발생했을때 `Err2203` 과 같이 code 2203를 같이 줌으로써
어떤 에러인지 상세 정보를 쉽게 검색하도록 도움을 주기 위해서다.
errCode는 리터럴 상수로 간단하게 description 문자열도 정의하고 있으니 참고하자.



errReport 클래스
================
@ref baseErr 들을 담아두는 클래스다.
시간이 오래걸리거나 복잡한 동작을 수행하는 로직이 있는 경우 함수의 depth가 매우
깊어진다.
안쪽에서 특정 함수에서 에러가 발생한 경우, 에러가 발생했다는 사실을 기록하고 작업은
최대한 진행하고 싶을때 errReport를 사용해서 에러를 기록한다.


@section 컨테이너
errReport는 거의 모든 기능이 @ref baseErr 객체에 대한 관리이기 때문에 @ref tucontainable
과 유사한 인터페이스를 가지고 있다.


@section noisy
어떠한 errReport는 새로운 err 객체가 add 될때마다 자동으로 log()를 수행하고 싶을 때가 있다.
이때 `setNoisy(true)` 를 지정한다.



sigZone 클래스
=====================
@ref signaler에 RAII를 적용한 클래스다.
sigZone 인스턴스가 정의된 블록문 안의 코드를 실행할 때 signal이 오면 람다를 수행하도록
signaler를 사용한다.



starter 클래스
==============
@ref worker의 일종으로, @ref verifier에 의해 검증이 완료된 AST를 실행한다.
실행 결과 @ref thread에게 exception이 발생되었다면 로그를 덤프하고 exception을 반환한다.
worker가 생소하다면 먼저 참조하자.


@section main 함수 look up
메인 함수의 조건은 다음과 같다.

1. root(pack) 바로 밑에서 찾는다.
2. 이름이 `main` 이어야 한다.
3. 반환형이 void 혹은 int 여야 한다.
4. 메인 함수는 1개 이상의 구문을 가져야 한다.


@section 사용 예시
@ref interpreter와 함께 사용하면 byeol 코드를 파싱해서 실행할 수 있다.

@code
    interpreter ip;
    ip.work();
    if(!ip.isVerified()) return -1;

    str res = starter().setTask(ip.getSubPack()).work();
    if(res)
        if(res->isSub<nInt>()) return *res->cast<nint>();
    return -1;
@endcode



parser 클래스
==================
@ref byeol 파싱 컴포넌트의 진입점 역할을 하며 @ref worker를 상속한다.
`work()`을 통해서 파싱된 결과가 @ref slot으로 반환된다.


@section stela 파서와 유사한 구조
stela 언어 자체가 byeol의 언어이므로 파서 또한 byeol 언어의 파서를 기반으로 하고 있다.
stela 파서는 byeol 파서 대비 덜 복잡하므로 core 모듈을 보기 전에 이 파서 코드를 먼저 살펴볼 것을 권장한다.


@section scanner - bison - parser 구조
flex와 bison을 사용하고 있으며 flex는 lowscanner로, bison은 lowparser로 각각 명명한다.
이 low level인 scanner, parser는 parser 컴포넌트 안에만 존재하는 것으로 외부에서는 일절 노출 되지 않는다.
parser::work() 가 실행되면 lowscanner를 실행시키고, lowscanner는 토큰을 뜯어서 lowparser에게 넘기고,
lowparser는 받은 토큰에 대해 rule이 match 되면 그 이벤트를 다시 parser에게 넘긴다.
그러므로 parser의 `on` 으로 시작하는 함수들은 그러한 이벤트를 handling 하는 함수로, 실제로 어떻게 node를 생성해서
ast를 구축하는 지를 정의한다.


@section lowparser.y의 lifecycle 관리
각 rule에서 parser::onXXXX() 함수들을 호출 하면, 해당 함수내에서는 `new` 키워드로 새로운 객체를
heap에 생성해서 반환하는 경우가 많다. (모든 함수가 그런 건 아니다.)
이렇게 받은 인자를 그대로 @ref tbicontainer 등에 직접 넣으면 괜찮지만, 그렇지 않은 경우는
미리 @ref tstr 등으로 binding을 하지 않으면 메모리릭이 발생하기 딱 좋다.

@code
    // - lowparser.y
    pack: PACK name-access NEWLINE {
        $$ = PS.onPack(*$2); // onPack()은 new pack()을 반환한다.
    }

    compilation-unit: pack defblock {
        tstr<obj> pak($1); // 이렇게 tstr로 바인딩하지 않으면,

        PS.onCompilationUnit(pak.get()); // onCompilationUnit() 안에서 주어진 pak의 값이
                                         // 문제가 있어, 동작이 취소된 경우, heap에
                                         // 생성한 pack 객체는 메모리릭이 된다.
    }
@endcode

이 점은 onXXXX() 같은 함수에 국한 되지 않고, 문자열 token을 받는 경우도 동일하게 적용된다.
다음 코드를 보자.

@code
    // -- lowscanner.l
    <stateString>\"       { // 문자열 scan이 종료되면
        if(!yylval->asStr) yylval->asStr = new std::string(); // string 객체를 new로 생성한다.
        ....
        return STRVAL;
    }

    // -- lowparser.y
        ...
       | STRVAL { // STRVAL이 scanner로부터 넘어오면
        $$ = PS.onPrimitive<nStr>(*$1); // 일단 넘긴다. 프로젝트 내에서 string는 항상 immutable로
                                        // 다루므로 항상 객체가 복제되어 들어간다.
        delete $1; // 객체가 복제되었으니 원본 객체는 메모리를 해제 한다.
@endcode


@section indentation rule
byeol 언어는 offside rule을 적용하므로, indentation에 매우 민감하다.
일반적인 언어와 달리, 개행직후로 몇개의 공백이 있는가를 count 할 수 있어야 하며,
indentation이 확정되어 해당 코드라인이 어느 scope에 속한 것인지가 확정되면 이후로는 공백을 무시해야 한다.
다음 byeol 언어의 예제를 보고, 이 문제에 대해 더 생각해보자.

@code
def A
    foo(val int) void
        if val > 0
          if val < 5
                  print("0 < val < 5")
        print("end of func") # 1)
@endcode

파서가 `print("0 < val < 5")` 를 파싱하고 나서 다음 줄인 `print("end of func")` 를 파싱할때
앞에 공백이 몇개 있는지 세야 한다. 그리고 지금까지 각 scope별 공백 갯수와 비교해서
해당 코드라인이 어느 scope에 속한 것인지를 판단해야 한다.
위 예제를 보면, 우리는 직관적으로 `print("end of func)`이 `if val > 0` 과 같은
공백을 갖고 있다는 점에서, foo() 본문 바로 안에 속한 코드라는 걸 알 수 있다.
그렇다는 건, 이 시점에서 `if val > 0` 안쪽의 scope와 `if val < 5` 안쪽의 scope 2개 모두
종료되었으므로 lowscanner는 lowparser가 `print("end of func")`를 인식하기 전에
scope의 종료를 의미하는 `DEDENT` 토큰을 2개 먼저 추가하여 인식할 수 있도록 만들어야 한다.


@section tokenDispatcher
flex는 yyin 이라는 별도로 지정된 stream 을 통해서 글자를 가져와 token으로 정의한다.
위의 예제를 보다시피, 파싱 도중에 토큰을 추가한다는 것은 이 stream에 특정 문자를 추가하는 것을 의미한다.
기본적으로 이런 경우는 unput을 사용하나, 여러개를 unput 하거나 뒤가 아니라 앞에 push 하는 경우 등에
유연하게 대응하기 위해, lowscanner는 내부적으로 @ref tokenDispatcher를 사용한다.


@section tokenScan
앞서서 indentation을 탐지하는 게 얼마나 중요한지 설명했다. 정확한 공백의 갯수를 셈해야 하기 때문에
@ref normalScan 과 @ref indentScan 2개의 scan 객체를 전환해가며 사용하는 일종의 strategy 패턴을 적용한다.
개행이 탐지되면 indentScan으로 교체해서 정확하게 공백을 count해서 scope를 결정하고,
이후에는 normalScan으로 교체해서 평상시처럼 공백을 다 무시한다.


@section defBlock과 expand
어떠한 byeol 코드는 타입 추론시 순서를 요구한다.

@code
    def myObj
        msg := "I'm $name and $age yo."
        name := "little man #$age"
        age := outerModule.defaultValue + 2
@endcode

위와 같은 코드를 타입추론을 위해 위에서부터 아래로 코드를 평가한다고 해보자.
msg는 name과 age를 참조하는데 name과 age의 타입을 모르므로 실패한다.
name은 age를 참조하는데 age를 모르므로 실패한다.
age는 심지어 외부 모듈의 값을 참조하므로 해당 모듈에 접근해야 한다.
만약 해당 모듈에서 값을 가져왔다고 가정한다면 age는 int 타입임을 알 수 있지만 name과 msg는
타입 확정에 실패한 상태로 진행된다.

위 문제를 어떻게하면 잘 해결할 수 있을까?
가장 먼저, 사용자에게 문법적인 제약을 거는 고전적인 방법이 있다. age, name, msg 순으로 적으라고 하는 식이다.
하지만 함수는 그러한 제약이 없으면서 타입만 그러는 건 좀 우습고, 이 방법은 너무 모던언어스럽지 않다.

다음 방법은 타입 추론시 실패하면 종속성 그래프를 만들어서 타입 추론 순서를 정하는 방법이 있을 수 있다.
이 경우, 최초 순회하며 평가하고 실패한 것 들은 평가 순서를 찾아서 한번더 retry 하는 것으로 완료될 수 있다.

세번째 방법은 현재 사용중인 방법이며, 더 간단하면서도 무식한 방법인데, 이러한 타입추론 표현식이나 구문들을
한곳에 몰아둔 후, parsing이 종료된 후, 1줄이라도 타입추론이 실패하지만 않는다면 무한루프를 도는 방법이다.
가지고 있는 모든 표현식이 타입추론에 실패하거나, 타입추론 표현식이 바닥나며 무한루프를 종료한다.
이 경우 추론 순서를 따지지 않아도 되니 복잡한 알고리즘 없이 간단하게 작성할 수 있지만 속도가 느리다.
개선의 여지가 충분하다.

defBlock은 이러한 역할을 돕는다. defBlock에는 expand, common, scope 3종류의 데이터가 있는데
scope은 parser에 의해서 바로 AST가 만들어지는 node이며, expand는 파싱은 성공했지만 타입추론이 필요하여,
@ref verifier 동작 전에 @ref expander로 넘길 부분이다.
common은 공통 생성자를 위한 부분인데, 이 부분은 따로 후술하겠다.

expand에 대한 자세한 부분은 @ref expander를 참조하자.



tokenScan 클래스
================
@ref parser는 해당 클래스에서 언급한 것처럼 indentation을 정밀하게 측정하기 위해서 scan mode를
동적으로 변경해아 한다.
tokenScan은 그러한 스캔 모드 전략 1개를 담당한다.


@section 명령 token
token 중에는 `SCAN_AGAIN`, `SCAN_EXIT` 등 scanner나 parser에 명령을 주는 토큰 들이
존재한다.
자세한 내용은 `lowparser.y`의 중간의 `// mode:` 단략을 참조하자.


@section isBypass
IndentScan의 경우 대부분의 token을 무시하며 오직 공백이 몇개인지 갯수를 세는 데 집중한다.
하지만 이전 라인에서 여러 token을 push 해둔 상황이라면 내부적으로 bypass 모드로 동작한다.
이때는 indentation 갯수를 세는 동작을 skip 하고 넣어둔 token을 그대로 읽어서 반환한다.



smartDedent 클래스
==================
@ref parser 가 indentation으로 scope을 만들때마다 몇개의 공백이 앞에 있는지를
count 해서 배열로 관리하는 클래스.
예를들어 다음의 byeol 코드를 파싱한다고 하자.
@code
def config
    def device
      name := "my device"
      # 1)
@endcode

만약 1번 위치에서 파서가 파싱중일때, smartDedent는 [0, 4, 6] 으로 내부 배열 값이
구성되어 있다.
즉 가장 바깥의 scope의 공백의 수는 smartDedent[0]인 0이 되며,
가장 안쪽의 scope인 device 의 scope임을 증명하는 공백의 수는 smartDedent[smartDedent.len() - 1] = 6으로
앞에 6개의 공백이 있어야 한다는 걸 의미한다.



expander 클래스
===============
@ref parser에서 명시한 것처럼 현재 사전 타입 추론 알고리즘은 종속성 그래프를 만들지 않고
모든 사전 타입 추론 표현식을 모아둔 후, 반복적으로 타입 추론을 시도하는 방식이다.
이러한 방식을 사용하기 때문에 반복적으로 표현식을 순회하며 사전 타입 추론을 시도하는
동작을 @ref verifier 안에서 한번에 수행하기에는 적합하지 않다.
따라서 verifier로 검증하기 전에 expander로 사전 타입 추론을 완료해 둘 필요가 있다.

기본 동작은 @ref visitor에 기반하므로, 사전에 visitor를 숙지하고 오는 게 좋다.


@section 타입 추론이 필요한 표현식의 정의
기본적으로는 사용자가 타입을 명시하지 않은 모든 표현식이 여기에 해당된다.
하지만 그렇다고 해서 타입을 명시하지 않은 모든 표현식을 다루는 건 아니다.
타입이 없으며, 해당 symbol이 obj @ref scope에 존재하는 경우에만 사전 타입 추론이 필요하다.
다음 byeol 코드 예시를 보자.

@code
def myObj
    age := 57 # 1) 타입 추론
    foo() int
        name := "kniz" # 2) 역시 타입 추론
        return name.len()
@endcode

1의 age와 2의 name은 모두 타입 추론이 필요하지만 오직 1만 사전에 타입 추론을 수행한다.
2는 영향력이 없기 때문이다. 즉, foo() 함수 내부에서 name은 지역변수이므로
verifier가 foo() 함수 내부에서 타입 추론을 수행하면 충분하다.


@section 사전 타입 추론 알고리즘
parser는 사전 타입 추론이 필요한 표현식(property 혹은 함수)를 만나면 해당 표현식을
소속된 객체의 `@expand` 라는 함수에 넣어둔다.
expander는 visitor를 통해서 주어진 root origin obj 를 모두 순회하며 이때 `@expand`
함수가 존재하는지 체크한다.
존재했을때 expand 시 사용할 context를 생성해 `_stack`에 add 한다.

모든 visitation이 종료되면 다음 과정을 거쳐서 사전 타입 추론을 수행한다.
1. 만약 `_stack`이 비어있다면 타입 추론을 종료한다.
2. 모든 `_stack` 각 원소에 대해 @ref frame을 준비하고 @ref verifier로 해당 표현식을 검증한다.
3. 검증이 성공하면 `eval()` 을 통해서 타입을 추론을 완료한다.
4. 실패하면 다음 원소로 넘어간다.
5. 모든 원소에 대해 한번씩 타입추론을 시도했을때, 1개라도 성공했다면 다시 1번으로 돌아간다.


@section 타입 컨버전스
최적화 목적으로 사전 타입 추론을 위해 visitation을 할때 @ref getExpr를 @ref origin
객체로 교체하는 작업을 수행하는데 이를 타입 컨버전스라고 한다.
컨버전스시 바로 origin으로 교체가 가능한 경우도 있지만, 사전 타입 추론이 완료되어야
교체가 가능한 경우도 있다.
visitatation 도중 getExpr가 origin으로 교체되지 않은 경우 `_cons` 에 저장해 두었다가
타입 추론이 완료된 후에 교체 작업을 1회 시도한다. 이 경우에도 실패할 경우는 그냥 무시할 뿐
에러는 발생하지 않는다.



tworker 클래스
==============
tworker는 대량의 배치 작업을 수행하는 데 최적화 되어있다.
@ref errReport로 이 과정에서 발생하는 에러를 수집할 수 있으며 다양한 flag들을 지정해서
작업 중 일부 동작을 변경시킬 수도 있다.
@ref verifier, @ref visitor, @ref parser등 큰 작업을 수행하는 클래스 들은 tworker기반으로
돌아간다.


@section work와 task
tworker는 말그대로 `work()`를 하기 위해 존재한다. 이때 작업의 대상이 되는 input을
`task`라고 한다.
작업전에 `_prepare()`가 호출되며 작업이 종료되면 `_onEndWork()`가 호출된다.


@section errReport
대량의 작업을 깊은 함수 depth를 동반하면서 수행해야 하므로, 콜스택 깊은 곳에 있는
에러를 충분히 탐지하기 위해서는 errReport를 통해서 이를 수집할 수 있어야 한다.
tworker는 `setReport()`를 통해서 외부로부터 errReport 객체를 넣을 수 있다.
errReport를 할당하지 않을 경우 @ref dummyErrReport가 대신 들어간다.


@section log flag
tworker는 작업 도중에 로깅을 위한 다양한 flag를 가지고 있다.

* LOG_ON_EX:    에러 발생시 한줄 로그를 남긴다.
* DUMP_ON_EX:   에러 발생시 callstack을 포함한 @ref err객체를 dump 한다.
* GUARD:        함수가 시작되고 끝날때 로깅한다.
* INTERNAL:     에러나 GUARD를 제외한 로그를 로깅한다.
* LOG_ON_END:   작업이 모두 완료되면, 그간 수집한 err를 모두 `log()`로 한줄 로그를 남긴다.
* DUMP_ON_END:  작업이 모두 완료되면, 그간 수집한 err를 모두 `dump()` 한다.



visitor 클래스
==============
byeol에서는 AST를 중점적으로 다루기 때문에 visitor를 자주 사용하게 된다.
이때 순회하는 방법과 순회시 @ref node를 visit했을 때의 동작을 서로 분리하기 위해
visitor이 적극적으로 활용된다.


@section 순회
항상 전위 순회를 따른다. 후위 순회를 하도록 변경은 불가능하다.
visit()은,
  1. 현재 찾은 node를 방문 (onVisit())
  2. 다음 하위 node를 순회 (onTraverse())
  3. 현재 찾은 node를 떠남 (onLeave())

3개의 단계로 이뤄져 있다.


@section accept를 통한 downcasting
visitor는 onVisit(T&) 과 같이 많은 구체 타입에 대한 방문을 표현하는 virtual function을
다수 가지고 있다.
반면 onTraverse에서 탐색시에는 주로 @ref node의 `subs()`를 통해서 @ref tbicontainable
인터페이스를 사용하기 때문에 node 타입을 사용하게 된다. 그래서 어디선가는 node 타입을
@ref nInt나 @ref defNestedFuncExpr과 같이 구체타입으로 downcasting을 해야한다.
이를 위해 node의 `accept()` 라는 virtual 함수를 호출 한다. 예시를 보자.

@code
    void defNestedFuncExpr::accept(const visitInfo& i, visitor& v) {
        v.visit(i, *this); // visitor::visit(const visitInfo&, defNestedFuncExpr&) 호출
    }
@endcode

가상함수 accept()가 호출되면 안에서 *this를 통해 구체타입으로써 역으로 visitor의 visit()을
호출하는 식이다.
이를 위해 visitation에 참여하는 모든 node의 파생클래스는 `accept()` 라는 virtual 함수를
override 해야 하는데, 이 과정을 쉽게 하기 위해서 VISIT 매크로를 사용한다.
실제로 다음과 같은 선언을 종종 볼 수 있다.

@code
    class _nout slot: public node {
        BY(CLASS(slot, node), VISIT()) // <---

    public:
@endcode

만약 node 파생클래스 임에도 `accept()`를 override 하지 않았다면, `onTraverse(node&)`가
대신 사용되며, 이걸로도 충분한 경우에 해당된다.


@section 중복 방문 제거
AST는 참조가 서로 되어있는 경우도 종종 발생한다. 이 경우 아무런 예외처리 없이 순회하면
이미 방문했던 node를 다시 방문하면서 무한 루프에 진입한다.
visitor는 `_visited` 라는 map을 소유하고 있다. 이를 통해서 visit()이 호출 되었을 때
이미 방문한 node인지를 판단해서 예외처리를 해주고 있다.
이 방문 기록 정보는 매번 visitor가 방문을 시작하기 직전에 초기화된다.
만약 재방문이 가능하도록 하고 싶다면 `setReturnable(true)`로 값을 변경해주자.



thread 클래스
=============
thread는 하나의 프로그램 실행 흐름을 표현한다. 현재는 단일 스레드만 지원하고 있다.
thread는 @ref frames와 @ref errReport를 가지고 있어, 프로그램을 실행시 @ref frame
을 구성하고 실행 도중 발생한 @ref err을 수집할 수도 있다.


@section builtin
builtin pack은 byeol 언어에서 기본적으로 제공하는 타입/함수 들이다.
별도의 manifest 선언 없이도 항상 접근 가능하다.
standard pack과도 비슷하지만 이는 byeol 코드로 작성된 엄연히 구분되는 pack으로 되어있다.
그러나 builtin pack은 전부 c++ native 클래스를 @ref tbridger를 활용해 노출하는 형태로
되어있다.
여기에 속한 타입들은 `int`, `str`, `arr`, `err`, `print()` 등 아주 기본적인 symbol 들 뿐이다.


@section 싱글톤 속성
thread는 `static thread& get()` 을 제공한다. 이를 통해 @ref scope나 @ref expr들이
현재 활성화된 thread 객체에 접근한다.
만약 기본 thread를 사용하지 않고 직접 thread 인스턴스를 만들어서 프로그램을 실행할 때는
thread객체를 등록하고, 프로그램 종료시 원본 thread 인스턴스로 교체시켜주는 작업이
필요하다.
이를 편하게 하기 위해 @ref threadUse를 사용한다.

@code
    if(main.canEval(a)) {
        threadUse thr(getReport());

        // 새로운 thread로 doSomething()...
    }
    // 다시 빠져나오면 원본 thread 인스턴스로 교체 된다.
    // 블록문에 들어가기 전의 프로그램 실행 상태로 복원된다.
@endcode

위 예제를 보다시피 threadUse는 생성과 동시에 내부에서 thread 객체를 자동으로 생성까지
해준다.



verifier 클래스
===============
@ref visitor 기반의 코드 검증을 담당한다. byeol 언어는 인터프리터의 구조를 띄고 있지만
언어 자체는 강형 타입을 사용하고 컴파일을 실행하는 것처럼 사전에 에러를 도출한다.
verifier는 그 기능의 핵심을 구현한다.
@ref parser와 @ref expander로 최종 생성된 AST를 실행하기 전에 에러는 없는지 확인한다.


@section 이해 난이도
verifier는 다양한 모듈을 사용하는 `core` 모듈 중에서도 고급 클래스에 해당하므로,
여러 클래스에 대해 사전에 알고 있어야 한다.
아마도 이 프로젝트에서 가장 마지막 시점에서야 이해가 되는 클래스 중 하나일 것이다.
@ref node, @ref visitor 뿐만 아니라 @ref expr이나 WHEN 매크로를 다 알고 있어야
이해가 쉽다.


@section visitor 기반
onTraverse는 visitor에서 알아서 채워주므로, verifier는 onVisit과 onLeave시
어떻게 해야 하는지에 대해서만 정의해두고 있다.


@section eval과 infer
프로그램의 실행은 결국 각 @ref node의 eval()로 이뤄지지만, verifier는 실행한 런타임
값은 관심이 없다. 오직 실행이 가능한가, 지정한 표현식의 결과가 정의된 property의 타입과
묵시적 변환이 허용되는 가와 같은 `타입 매칭`에만 관심이 있다.
node의 `infer()`는 타입 추론 기능을 수행하는 것으로 실행하면 값은 모르지만 결과 타입을
origin 객체로 반환하는 함수다. 값을 계산하지 않으므로 eval() 보다 더 빠르다.
이제 감이 왔겠지만, verifier는 eval()보다는 infer()를 중점적으로 사용한다.

@code
    void me::onLeave(const visitInfo& i, assignExpr& me, nbool) {
        ....
        str left = me.getLeft().infer() OR.myExErr(me, LHS_IS_NUL).ret();
        ....
        str right = me.getRight().infer() OR.myExErr(me, RHS_IS_NUL).ret();
        ....
    }
@endcode

위의 예시처럼 eval() 대신 infer()를 주로 사용한다.


@section 많은 코드 라인을 가진 파일
verifier는 가장 LOC가 많은 파일 중 하나다. 이때 코드들은 크게 3 종류로 분류된다.

* 검증을 위한 사전 작업
* WHEN 매크로를 사용한 실제 검증 로직
* 각 단계별 상세 로깅


@section 단계별 상세 로깅
visitor는 타입당 1개의 onVisit() 함수만 가질 수 있다. 그러나 verifier는 하나의
타입이 주어졌을때 검증해야 하는 케이스가 대부분 2개 이상이다.
그러니 잘못하면 하나의 onVisit() 함수는 여러개의 검증 로직으로 뒤범벅 되어 구분이
어려워 진다.
단계별 상세 로깅이란, 이를 도와주는 코드로, 검증 타겟이 되는 객체에 대해 진행하게 될
검증 로직이 무엇인지를 로그를 남기는 역할을 한다. 예를 들어,

@code
    // verifier가 assignExpr 객체에 대해 검증하는 경우:
    void me::onLeave(const visitInfo& i, assignExpr& me, nbool) {
        _GUARD("onLeave(assignExpr&)"); // _GUARD는 assignExpr에 대한 검증이 시작됨을 로깅한다.

        // 첫번째 step: evalType을 set한다.
        _STEP("set evalType");

        str left = me.getLeft().infer() OR.myExErr(me, LHS_IS_NUL).ret();
        const ntype& ltype = left->getType();
        str right = me.getRight().infer() OR.myExErr(me, RHS_IS_NUL).ret();
        const ntype& rtype = right->getType();
        WHEN(rtype.isSub<retStateExpr>()) .myExErr(me, CANT_ASSIGN_RET).ret();
        WHEN(!rtype.isImpli(ltype)) .myExErr(me, TYPE_NOT_COMPATIBLE, rtype, ltype).ret();

        ....

        // 두번째 step rvalue를 검사한다.
        _STEP("checks rvalue");
        const getExpr& lhs = me.getLeft().cast<getExpr>() OR.myExErr(me, ASSIGN_TO_RVALUE, me.getRight(), lhs).ret();

        // 3번째 step
        _STEP("checks that you can't assign to a func");
        str lhsEval = lhs.infer();
        WHEN(baseFunc::isFuncButNotClosure(*lhsEval)) .myExErr(me, ASSIGN_TO_FUNC).ret();

        // 4번째 step
        _STEP("checks that try to assign to a const variable");
        WHEN(util::checkTypeAttr(lhs.getName()) == ATTR_CONST) .myExErr(me, ASSIGN_TO_CONST, lhs.getName()).ret();
    }
@endcode

위와 같이 하면 각 코드 뭉치가 그나마 잘 구분되며, 로그를 봐도 디버깅이 좀 더 수월하다.

> Nov 18 2025  20:02:13 I verifier  <onLeave#85> '' assignExpr@assignExpr: onLeave(assignExpr&)
> Nov 18 2025  20:02:13 I verifier  <onLeave#87> '' assignExpr@9a50: step#1 --> set evalType
> Nov 18 2025  20:02:13 I getExpr   <_get#50> getExpr: looking for 'frame.AGE'
> Nov 18 2025  20:02:13 I getExpr   <_onGet#58> @getExpr frame.sub("AGE", {})
> Nov 18 2025  20:02:13 I node      <operator()#79> sub: [1/13] AGE --> me@fc80
> Nov 18 2025  20:02:13 I node      <operator()#79> sub: [2/13] AGE --> AGE@46c0
> Nov 18 2025  20:02:13 I verifier  <onLeave#133> '' assignExpr@9a50: step#2 --> checks rvalue
> Nov 18 2025  20:02:13 I verifier  <onLeave#136> '' assignExpr@9a50: step#3 --> checks that you can't assign to a func
> Nov 18 2025  20:02:13 I getExpr   <_get#50> getExpr: looking for 'frame.AGE'
> Nov 18 2025  20:02:13 I getExpr   <_onGet#58> @getExpr frame.sub("AGE", {})
> Nov 18 2025  20:02:13 I node      <operator()#79> sub: [1/13] AGE --> me@fc80
> Nov 18 2025  20:02:13 I node      <operator()#79> sub: [2/13] AGE --> AGE@46c0
> Nov 18 2025  20:02:13 I verifier  <onLeave#140> '' assignExpr@9a50: step#4 --> checks that try to assign to a const variable


중간 중간 나오는 node나 getExpr 태그의 로그가 어떤 검사 단계중에 발생한 것인지 명확하다.
참고로 _STEP 매크로는 verifier의 구현 파일에서만 유효하며 해당 함수내의 몇 번째 단계인지
자동으로 count해서 로그를 보여준다.


@section WHEN 매크로를 사용한 검증
verifier는 `if (!check) return res;` 와 같은 검증 코드가 매우 많은 클래스다.
그래서 verifier에는 수많은 WHEN 매크로가 존재할 수 밖에 없다.


@section verifier vs starter
@ref starter는 프로그램을 직접 실행한다. verifier는 검증만 수행한다. 둘의 가장 큰 차이점은
starter가 `eval()`로 표현식을 실행할 때, verifier는 `infer()`로 타입정보만 가져온다는 점이다.
하지만 그렇다고 해서 verifier가 starter와 동일하게 수행해햐아 하는 몇가지 작업이 존재한다.

* 우선은, @ref frameInteract를 사용하는 것이다.
  타입이 존재하는지, 현재 접근 가능한지를 알아내기 위해서는 @ref obj @ref scope이나
  func scope을 실제로 frame에 등록해야만 한다.
  주로 onVisit() 에서 특정 객체에 대해 inFrame()을 호출했다면 onLeave()에서는 같은
  객체에 대해서 outFrame()을 호출하고 있을 것이다.

* property를 실제로 정의한다.
  값은 비어있지만 property 자체는 정의를 해야, 해당 property가 중복은 아닌지,
  없는 property를 접근한 것은 아닌지 검사가 가능해진다.

* generic 클래스를 실제로 생성한다.
  그래야 generic 클래스 검증이 가능해진다.



generalizer 클래스
==================
@ref visitor 기반의 generic타입 생성을 담당하는 클래스다.
주로 @ref getGenericExpr에서 사용하므로 해당 클래스를 먼저 참조하자.


>       ┃                 ┣━[0] @9068 boo() int
>       ┃                 ┃  ┗━[0] codes blockExpr@e190
>       ┃                 ┃     ┗━[0]  int = 3
>       ┃                 ┣━[1] @5a40 @ctor() myObj
>       ┃                 ┗━[2] @5c08 @ctor(rhs myObj) myObj
>       ┣━[1] @6160 @ctor() SomeGeneric<T myObj>
>       ┗━[2] @6328 @ctor(rhs @incomplete SomeGeneric) SomeGeneric<T myObj>

가장 중요한 부분은 첫 줄로, SomeGeneric이라는 genericOrigin 인스턴스 안에 `myObj`라는 key로
SomeGeneric<myObj>이라는 origin 객체가 들어있다는 부분이다.
generalizer는 SomeGeneric<T>로부터 SomeGeneric<myObj>를 만드는 용도로 사용되며
이때 단순히 `args가 T인 getExpr`객체를 찾으면 이를 `args가 myObj인 getExpr`로 교체하는 방식을
모든 node에 걸쳐서 수행할 뿐이다.


@section generic 타입이 만들어지는 흐름
위의 예시에서 `main()` 함수의 print(SomeGeneric<MyObj, int>().foo()) 는 다음과 같은 AST로 표현될 수 있다.

> evalExpr@09a0 = frame.print(str)
>    ┗━[0] subject getExpr@4610 = frame.print(str)
>       ┣━[0] me frame@2d20
>       ┗━[1] subArg FBOExpr@cd58 = FBOExpr("FBOExpr") + str("str")
>          ┣━[0] lhs FBOExpr@cc90 = str("str") + asExpr("asExpr")
>          ┃  ┣━[0] lhs str = "value is "
>          ┃  ┗━[1] rhs asExpr@bd10
>          ┃     ┣━[0] me evalExpr@0848 = evalExpr.foo(myObj)
>          ┃     ┃  ┣━[0] me evalExpr@06f0 = frame.SomeGeneric()
>          ┃     ┃  ┃  ┗━[0] subject getGenericExpr@47d0 = frame.SomeGeneric(myObj)
>          ┃     ┃  ┃     ┗━[1] subArg getExpr@46f0 = frame.myObj
>          ┃     ┃  ┗━[1] subject getExpr@48b0 = SomeGeneric<T myObj>.foo(myObj)
>          ┃     ┃     ┣━[0] me SomeGeneric<T myObj>@3970
>          ┃     ┃     ┗━[1] subArg getExpr@4990 = frame.myObj
>          ┃     ┗━[1] as str = ""
>          ┗━[1] rhs str = ""

중간에 getGenericExpr이 보일 것이다. @ref verifier나 @ref starter에 의해 해당 클래스가
infer() 될 때 genericOrigin을 가져와서 타입파라메터를 인자인 `myObj`를 넘겨서 eval()를 호출한다.
이때 genericOrigin은 generalizer를 사용하여 타입파라메터가 myObj인 origin 객체를 생성해서 반환하게 된다.
자세한 내용은 genericOrigin을 참조하자.



genericOrigin 클래스
====================
@ref 기본적으로 origin과 같은 역할을 수행하는 클래스이지만, generic을 지원한다는 점과
이 인스턴스 자체가 origin을 담당하는 게 아니라 필요에 의해 origin을 생성/관리 한다는 점이 다르다.


@section 동작 방식
genericOrigin은 map으로 origin 객체를 관리하고 있다. 여기에 key로 `myObj`가 없는 경우
원본 origin 객체인 _org를 deepClone해서 새로운 @ref origin 객체를 만든다. 그리고
그 객체에 generalizer를 넣어서 기존에 getExpr(args = T)로 되어있던 부분을 getExpr(args = myObj)로
인자 T를 모두 myObj로 교체하는 작업을 수행한다.
교체된 origin은 subs()에 등록되어, 이후 호출시 key가 같은 경우는 generalizer 없이 바로
반환되도록 한다.



getGenericExpr 클래스
=====================
generic 클래스의 참조를 담당하며 generic 타입 생성의 진입점을 담당한다.
내부적으로는 @ref genericOrigin에게 generic 타입을 줄 것을 요청하며, genericOrigin은
해당 타입에 대한 generic이 있다면 그걸 바로 주고, 없다면 @ref generalizer를 통해
generic 타입을 생성 후, 그 새로운 인스턴스를 반환한다.
자세한 내용은 @ref genericOrigin과 @ref generalizer를 참조하자.



srcSupply 클래스
================
@ref parser에서 사용되는 클래스로, parser에 입력되는 코드를 어떠한 형태로 제공할지를
추상화한다.
예를들어 파일로써 제공하는 방법도 있지만, 버퍼에 담아서 줄 수도 있고 stream으로
주는 방법도 있을 것이다.



graphVisitor 클래스
===================
@ref visitor 기반의 AST 로깅 클래스로, task 주어진 root @ref node를 순회 하면서
상세 정보를 모두 로깅한다.
@ref interpreter에 의해서 디버그 빌드에서 사용되거나 @ref defaultSigZone에 의해서
crash 가 발생하면 출력되거나 @ref logStructureFlag에 의해서 @ref interpreter나
@ref starter로 하여금 graphVisitor를 사용하도록 flag를 set 된다.


@section 읽는 법
다음과 같은 byeol 코드가 있을때,

@code
    def myObj
        foo() void
            print("hello")

    main() void
        myObj.foo()
@endcode

아래와 같이 AST 로그가 나오게 된다.

> ┗━[0] #root slot@88c0
>    ┣━[0] myObj myObj@cc98 [complete]
>    ┃  ┣━[0] @6f80 foo() void
>    ┃  ┃  ┗━[0] codes blockExpr@b6a8
>    ┃  ┃     ┗━[0]  evalExpr@d8e0 = frame.print(str)
>    ┃  ┃        ┣━[0] subject getExpr@4020 = frame.print(str)
>    ┃  ┃        ┃  ┣━[0] me frame@96c0
>    ┃  ┃        ┃  ┗━[1] subArg str = "hello"
>    ┃  ┣━[1] @1110 @ctor() myObj
>    ┃  ┗━[2] @12d8 @ctor(rhs myObj) myObj
>    ┃  ┗━[0] callComplete evalExpr@da38 = myObj.@ctor()
>    ┃     ┗━[1] subject getExpr@4100 = myObj.@ctor
>    ┣━[1] @72f8 main() void
>    ┃  ┗━[0] codes blockExpr@b7a0
>    ┃     ┗━[0]  evalExpr@db90 = myObj.foo()
>    ┃        ┣━[0] me getExpr@42c0 = frame.myObj
>    ┃        ┗━[1] subject getExpr@43a0 = myObj.foo
>    ┣━[2] @14a0 @ctor() {default}
>    ┗━[3] @1668 @ctor(rhs {default}) {default}

이 중에서 한 줄을 떼어서 각 정보를 설명해보자.

> ┗━[0] #root slot@88c0

* 모든 node는 누군가의 sub node다. 따라서 `[0]` 부분은 자신의 parent node의 몇번째
자식인지를 인덱스를 표시한다.

* `#root`는 해당 node에 붙은 이름이다. 만약에 @ref origin객체라면 byeol 코드로 사용자가 입력한
객체 명이 들어갈 것이고, @ref getExpr같은 경우라면 c++ 상으로 literal로 지명된 해당 클래스의
멤버변수 명이 들어가게 된다.

* `slot@88c0` 부분은 해당 객체의 식별값이다. 앞의 `slot`은 이 `#root`라는 이름이 붙은
node가 실제로는 @ref slot이라는 클래스의 인스턴스임을 알려준다. 뒤의 `@88c0`은
`indep` 모듈의 @ref platformAPI의 `toAddrId()`로 부여받은 addrId 값이다.
자세한 내용은 platformAPI를 참조하자.

* `[complete]`는 해당 origin 객체가 완전객체임을 알려준다.

* `= frame.print(str)` 은 해당 node가 @ref expr일때 그 표현식을 알아보기 쉽도록
한줄에 표현한 것이다.
