이제부터 각 클래스들에 대해서 자세한 주석을 추가하려고 해.
먼저 draft_guide.txt에 있는 내용을 모두 읽고 이해해.
그 파일에는 한글로 다음과 같은 포맷으로 작성이 되어 있어.
입력 예:

    indep 모듈
    ##########

    fsystem 클래스
    ==============
    fsystem은 지정한 폴더에서 파일을 재귀적으로 탐색하는 간단한 클래스다.
    윈도우와 posix 계열 운영체제에서 모두 사용가능한 플랫폼 독립적인 API를 제공한다.
    핵심 API는 iterator 클래스를 통해 이뤄진다.

    사용 예제는 아래와 같다.
    @code
    auto e = fsystem::find("../your/path");
    while(e.next()) { // 모든 파일을 탐색하면 false를 반환한다.
        const std::string& path = *e; // 찾은 파일의 경로
        if(*e == "../your/path/child/helloWorld.cpp") // 항상 상대경로를 사용한다.
            doSomething(e->getDir()); // 찾은 파일의 folder 경로를 반환한다.
    }
    @end code

    @section 섹션1
    섹션1의 내용은 다음과 같다.
    섹션1의 그 다음 내용.

    빈줄이 1개 있으면, 섹션1 단락이다.


    이렇게 빈줄이 2개 이상 나오면 더이상 섹션1이 아니다.

    @remark 적용시 이러저러한 점을 주의해야 한다.
    remark도 section과 마찬가지로 빈줄1개 이하까지는 같은 단락으로 취급한다.

    즉, 아직도 remark 단락.


    그리고 빈줄이 2개 나왔으니 이거는 remark 단락이 아니다.


    cpIter 클래스
    =============
    문자열에 대해서 codepoint 기반의 iteration을 담당한다.
    주로 @ref nStr 에서 UTF8 unicode와 같은 multibyte 문자열을 순회할 때 사용한다.



    clog 모듈
    #########

:입력 예시 끝

나는 위처럼 클래스의 핵심 내용을 정리해서 적었으니까, 너는 그걸 바탕으로 영어로
번역 한 뒤, 이 프로젝트의 hpp, cpp, inl 파일들에 알아서 잘 doxygen 문법의 주석을 달아.
이때 다음과 같은 규칙을 지켜줘.

1. ########## 와 같은 라인이 나오면, 그 윗줄이 모듈명이라는 뜻이다.
그 이후로는 다시 ###### 가 나올때까지 해당 모듈 안의 있는 클래스들에 대해서만 입력이 들어온다.

2. ======== 와 같이 나오면, 그 윗 줄이 클래스 이름이라는 뜻이다.
위의 예시로 예를들면, indep 모듈안의 `fsystem` 이 니가 주석을 달아야할 클래스명이 된다.
이 fsystem은 앞서 제시한 모듈 안에서 찾으면 된다.

3. ######로 찾은 module과, ====== 로 찾은 클래스를 찾아 실제 수정할 헤더파일을 열면,
   거기에는 이미 doxygen 주석이 달려있을 것이다. 그러나 일부 주석은 `///` 로만 시작할 뿐
   doxygen 문법으로 안되어있는 경우도 있다. 이러한 경우도 이후 나올 규칙에 의해
   적절하게 doxygen 문법을 쓰도록 바꿔야 한다.
   아무튼, 해당 파일의 씌인 주석 내용을 다 이해하고 다음 입력을 읽는다.

4. `@ref <클래스명>`는 doxygen의 문법 @ref를 사용하라는 뜻이다.

5. `@section 섹션1` 은 말그대로 doxygen 문법으로 @section 섹션1로 섹션을 만들라는 내용이다.
   doxygen 문법에는 참고로, @section 의 단락은 개행후 글을 쓰거나 빈줄이 한개만 나오는 경우는
   동일한 section 단락으로 간주한다.
   빈줄이 2개 이상일 경우만 section 단락이 종료된 걸로 취급한다.
   내가 쓴 입력도 같은 문법을 따른다.

6. `@remark` 가 나오면 이 역시 말그대로 doxygen 문법의 @remark를 쓴다는 얘기다.
   @section과 마찬가지로 동일한 단락 규칙을 따른다.
   즉, 빈줄 1개 이하는 동일한 단락. 2개 이상부터는 단락 종료로 취급한다.

7. @code 와 @codeend 역시 doxygen의 문법을 그대로 사용한다.
   그 안에는 c++ 코드가 예제로 들어가는데, 그 곳의 한글이 있다면 번역을 해야 한다.

8. 그 밖에도 니가 적절히 판단해서, 내가 준 입력의 의도에 반하지 않는 선에서는
   doxygen 문법을 추가 사용해도 괜찮다.

9. 하나의 class 입력이 끝나면, 내가 입력해준 내용과, 3번에서 이미 씌여져 있는 doxygen
   주석을 비교해서 중복된 내용은 제거하고, 만약 서로 모순 되는 내용이 있다면
   항상 내가 방금 입력해준 내용을, 이미 씌여진 주석보다 우선한다.
   그렇게 해서 하나의 완전한 내용을 만든다.

10. 9번의 결과에 한글이 있다면 영어로 번역한다.

11. 이후 10번의 결과를 doxygen 주석으로 만든다.
    doxygen 주석은 다음과 같은 포맷을 따른다.

    doxygen 주석 결과의 예시:
        /// @ingroup meta
        /// @brief Base class for runtime type information in byeol language
        /// @details Provides fundamental type metadata and operations.
        /// Returns ttype<type> as result of getType() for type introspection.
        ///
        ///
        /// @section Usage
        /// bla bla bla.
        /// this is example:
        /// @code
        ///     // some c++ example
        /// @endcode
        ///
        /// @remark when you use above API, you need to care about ...
        ///
        ///
        /// @remark type is a dangerous class.

12. 프로젝트의 column의 limit는 80 ~ 120 이다.
    소프트캡 80, 하드캡 120.
    절대로 120을 넘으면 안된다.
    11번의 결과가, 파일에 작성할때 열이 120을 넘기전에 개행을 꼭 한다.

13. 12번 결과를 출력한다.

질문이 있다면 먼저 질문해. 이해가 완료되었다면 다 이해가 되었다고 답해.
