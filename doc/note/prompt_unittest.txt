이제부터 각 모듈에 대한 유닛테스트 코드를 작성하려고 해.
테스트 구성을 피라미드로 구성하려고 해.

- 단순 unittest: 60%
- 통합 unittest: 30%
- 완전한 e2e: 10%

위 피라미드 구성을 엄격하게 지키자는 건 아니라는 걸 명심해. 단지 대략적인 테스트 구성의
이상점을 논한 것 뿐이야. unittest를 더 많이 작성해야 한다는 걸 기억하라는 것 뿐이지,
실제 테스트케이스의 종류를 다 분석해서 정확하게 저 퍼센트에 들어맞는지를 조사하라는 게
아니야.


# 공통 목표
* 각 모듈의 커버리지는 80%을 목표로 작업. 커버리지는 code cov로 확인하는데, ./build/builder.py cov
  명령어로 수행하면 커버리지 report 파일이 생성돼.
  이 파일을 통해서 어느 파일을 중점적으로 더 테스트해봐야할지를 알 수 있어.
* 테스트 라이브러리는 gtest를 사용하고 있어.
* 위의 피라미드 구성이 되도록 테스트를 추가해야 돼.
  절대로 이미 만들어진 테스트를 삭제해서 구성비를 달성하려고 하면 안돼.
  현재는 통합 unittest나 e2e과 엄청 많은 상태야.
* 각 테스트 구성군(unittest, e2e, integration)은 각각 module 폴더별로 나누어져 있어.
* test 용 파일은, 프로덕션 코드와 구분하기 위해 .cc 확장자를 사용해.
* 하나의 클래스에 대해서는 하나의 .cc 파일만 존재해야 돼.
* 한번 작업할때는 한번에 하나의 모듈을 80% 이상으로 올릴데만 집중해. 동시에 여러 모듈의 파일을 올릴려고 하지마.
* 그러니 builder.py cov 명령으로 어느 모듈이 커버리지가 더 필요한지 확인해 봐야겠지.
  하지만 시작하기 전에, 사용자에게 `직접 커버리지를 조사해볼까요? 아니면 작업할 모듈을 알려주실래요?` 라고 한번 물어봐.


# 단순 unittest란?
* 클래스 1개를 대상으로 가지고 있는 public 멤버변수나 멤버함수를 테스트 하는게 목적이야.
* 가능하면 mock은 사용하지 않되, 함수가 mock이 없으면 안되고, 매우 중요하거나 본문이 길
  mock을 해서라도 테스트를 해야 돼. 이런경우는 몇 없을 꺼야. 이런 함수를 발견하면
  내게 mock을 사용해서 unittest code를 짜도 좋을 지 먼저 물어봐야 돼.
* 이 테스트의 가장 큰 목적은 integration test나 e2e에서 나올 문제를 미리 찾아내는 게
  목적이야. 그래서 빠른 디버깅이 되도록 하고 싶어.
* 이 테스트 들은 module/test/case 안에 모듈별로 위치하고 있어.
  단, core의 경우는 integration 테스트는 module/test/case/core/syntax 폴더 안에 있어.
  즉 core의 unittest는 module/test/case/core 폴더 바로 밑에 있는 것들이야.
* unittest 파일은 항상 `.cc` 확장자로 끝나.


# 너의 목적
* 공통 목표를 달성하면서 단순 unittest를 더 작성하는 게 목표야.
* 질문이 있다면 먼저 물어봐.
