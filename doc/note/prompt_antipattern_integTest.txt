# Byeol 언어 안티패턴 테스트 케이스 작성 프롬프트

## 목적
byeol 언어 문법을 처음 접한 초보자가 **문법적으로는 올바르지 않지만** 창의적으로 시도할 수 있는 코드 패턴을 찾아, 이러한 안티패턴에 대해 시스템이 **exception 없이 적절한 에러를 반환하는지** 검증하는 테스트 케이스를 작성한다.

## 테스트 케이스 작성 규칙

### 1. 파일 위치 및 명명
- 위치: `module/test/integ/core/` 디렉토리
- 파일명: `antipatternIntegTest.cc` (또는 관련 기능별로 분리)
- 테스트명: `TEST_F(antipatternIntegTest, 설명Negative)`
  - 반드시 마지막에 `Negative` 접미사 붙일 것

### 2. 기본 구조 템플릿
```cpp
TEST_F(antipatternIntegTest, callCompleteWithAssignmentNegative) {
    make()
        .negative()  // ← 필수: 로그 최소화
        .parse(R"SRC(
        def myObj(a = b)  # ← 안티패턴 코드
            age int
        main() void
            myObj.age
    )SRC")
        .shouldParsed(false);  // ← parser에서 실패 예상
}
```

### 3. 검증 단계 선택
- **Parser 단계 실패**: `.shouldParsed(false)`
  - 명백한 문법 오류 (예: `def foo(int a)`, `a := := 5`)

- **Verifier 단계 실패**: `.shouldParsed(true).shouldVerified(false)`
  - 문법은 맞지만 의미론적 오류 (예: 타입 불일치, 존재하지 않는 심볼)

### 4. 필수 제약사항
- **Exception 발생 금지**: 모든 안티패턴은 graceful하게 에러 반환해야 함
- **negative() 호출 필수**: 로그 출력 최소화 (verbose 모드 제외)
- **에러 확인**: 에러가 발생하는지만 확인, 특정 errCode는 검증하지 않음

## 안티패턴 카테고리

### Category 1: 객체 정의 (defObjExpr)
초보자가 다른 언어 경험을 바탕으로 시도할 수 있는 잘못된 패턴:

```cpp
// 1.1 callComplete에 잘못된 표현식
def myObj(a = b)           // 할당 연산자
def myObj(a + b)           // 산술 표현식
def myObj(foo())           // 함수 호출
def myObj(a := 5)          // 변수 선언

// 1.2 타입 선언 위치 오류 (다른 언어 스타일)
def myObj int age          // C/C++ 스타일
def myObj: age int         // Python 스타일
def myObj { age int }      // C/Java 스타일

// 1.3 중복 정의
def myObj
    def myObj              // 내부에 같은 이름 객체
    age myObj              // property와 타입 이름 충돌
```

### Category 2: 함수 정의 (defFuncExpr)
```cpp
// 2.1 파라미터 선언 오류
def foo(int a)             // 타입이 앞에
def foo(a, b int)          // 일부만 타입 지정
def foo(a + b int)         // 표현식을 파라미터로

// 2.2 반환 타입 오류
def foo() ret int          // 'ret' 키워드 사용
def foo(): int             // 콜론 뒤 타입만
def foo() -> int           // 화살표 문법

// 2.3 함수 본문 오류
def foo()                  // 본문 없음
def foo(): :               // 빈 inline block의 중첩
def foo() void::           // 콜론 중복
```

### Category 3: 변수 선언 및 할당
```cpp
// 3.1 선언과 할당 혼동
a = 5                      // 선언 없이 할당
a := := 5                  // := 중복
a int := 5                 // 타입과 := 동시 사용
const a = 5                // const 키워드 (byeol에는 없음)

// 3.2 타입 추론 오해
a :=                       // 우변 없음
a := void                  // void 타입 할당
a := b := 5                // 연속 할당
```

### Category 4: 제어문
```cpp
// 4.1 조건문
if a = 5                   // 비교 대신 할당
if (a == 5)                // 괄호 사용 (byeol에서 불필요)
if a == 5: : print("a")    // inline block 중첩

// 4.2 반복문
for a in 1..10             // Python 스타일 (byeol은 'a := 1..10')
while true:                // 조건만 있고 본문 없음
```

### Category 5: Generic & 타입
```cpp
// 5.1 Generic 오류
def MyGeneric<T, T>        // 같은 타입 파라미터명
MyGeneric<>                // 빈 타입 파라미터
MyGeneric<int, str>()      // 파라미터 개수 불일치

// 5.2 타입 캐스팅 오류
a as                       // 타입 없이 as
a as as int                // as 중복
a is                       // 타입 없이 is
```

### Category 6: 스코프 & 접근
```cpp
// 6.1 잘못된 접근
myObj..property            // 점 중복
myObj.                     // 점 뒤 아무것도 없음
.myObj                     // 점으로 시작

// 6.2 Modifier 오해
public def foo()           // public 키워드 (byeol 문법과 다름)
private age int            // private 키워드
protected override foo()   // modifier 중복 오류
```

### Category 7: 표현식 체이닝
```cpp
// 7.1 잘못된 체이닝
a...b                      // 점 3개
a?.b                       // optional chaining (byeol에 없음)
a!.b                       // 강제 unwrap (byeol에 없음)

// 7.2 연산자 오류
a +++ b                    // 연산자 중복
a = = b                    // 등호 사이 공백
a <=> b                    // 존재하지 않는 연산자
```

### Category 8: 문자열 & 리터럴
```cpp
// 8.1 문자열 템플릿 오류
msg := "$"                 // $ 단독 사용
msg := "$$name"            // $$ 중복
msg := "$name$"            // 끝에 $

// 8.2 배열 리터럴
arr := [1, 2, 3,]          // trailing comma
arr := []                  // 빈 배열 (타입 추론 불가)
```

## 작성 예시

```cpp
#include "test/byeolIntegTest.hpp"

using namespace by;

namespace {
    struct antipatternIntegTest: public byeolIntegTest {};
}

// Category 1: 객체 정의
TEST_F(antipatternIntegTest, callCompleteWithAssignmentNegative) {
    make()
        .negative()
        .parse(R"SRC(
        def myObj(a = b)
            age int
        main() void: myObj.age
    )SRC")
        .shouldParsed(false);
}

TEST_F(antipatternIntegTest, callCompleteWithArithmeticNegative) {
    make()
        .negative()
        .parse(R"SRC(
        def myObj(a + b)
            age int
        main() void: myObj.age
    )SRC")
        .shouldParsed(false);
}

// Category 2: 함수 정의
TEST_F(antipatternIntegTest, paramTypeBeforeNameNegative) {
    make()
        .negative()
        .parse(R"SRC(
        def foo(int a) void
            a + 1
        main() void: foo(5)
    )SRC")
        .shouldParsed(false);
}

TEST_F(antipatternIntegTest, returnTypeWithRetKeywordNegative) {
    make()
        .negative()
        .parse(R"SRC(
        def foo() ret int
            5
        main() void: foo()
    )SRC")
        .shouldParsed(false);
}

// Category 3: 변수 선언
TEST_F(antipatternIntegTest, assignWithoutDeclareNegative) {
    make()
        .negative()
        .parse(R"SRC(
        main() void
            a = 5  # := 없이 = 만 사용
    )SRC")
        .shouldParsed(true)
        .shouldVerified(false);  // parser는 통과, verifier에서 실패
}

TEST_F(antipatternIntegTest, doubleColonEqualNegative) {
    make()
        .negative()
        .parse(R"SRC(
        main() void
            a := := 5
    )SRC")
        .shouldParsed(false);
}

// Category 4: 제어문
TEST_F(antipatternIntegTest, ifWithAssignmentNegative) {
    make()
        .negative()
        .parse(R"SRC(
        main() void
            a := 5
            if a = 10  # == 대신 = 사용
                print("wrong")
    )SRC")
        .shouldParsed(true)
        .shouldVerified(false);
}

// Category 5: Generic
TEST_F(antipatternIntegTest, genericDuplicateTypeParamNegative) {
    make()
        .negative()
        .parse(R"SRC(
        def MyGeneric<T, T>
            value T
        main() void: 0
    )SRC")
        .shouldParsed(true)
        .shouldVerified(false);
}

// Category 6: 스코프 & 접근
TEST_F(antipatternIntegTest, doubleDotsAccessNegative) {
    make()
        .negative()
        .parse(R"SRC(
        def myObj
            age := 5
        main() void
            myObj..age  # 점 2개
    )SRC")
        .shouldParsed(false);
}

// Category 7: 표현식 체이닝
TEST_F(antipatternIntegTest, tripleOperatorNegative) {
    make()
        .negative()
        .parse(R"SRC(
        main() void
            a := 5
            b := a +++ 3  # +++ 연산자
    )SRC")
        .shouldParsed(false);
}

// Category 8: 문자열
TEST_F(antipatternIntegTest, stringTemplateDoubleDollarNegative) {
    make()
        .negative()
        .parse(R"SRC(
        main() void
            name := "world"
            msg := "$$name"  # $$ 사용
    )SRC")
        .shouldParsed(true)
        .shouldVerified(false);
}
```

## 주의사항
1. 모든 테스트는 **exception 없이** 정상적으로 에러를 반환해야 함
2. **negative() 호출 필수** - 로그 최소화
3. parser 실패 vs verifier 실패를 명확히 구분
4. 초보자 관점에서 **충분히 시도할 법한** 패턴만 포함
5. 너무 명백한 오류(예: `asdfasdf`)는 제외
