# [o] 중간평가를 지원한다. when을 지원한다.

* 일단 지원하지 않는게 좋다는 결론이 나왔던 기능인데, 이 기능과 문법을 다른 문법을 해결하는데도 재사용이 가능한지 한번 체크해보자.
* 일단 이런 아이디어다.

```go
return a.getIntent(manager.translate(a.startResult(a, b), c.mgr(), d.age.foo(), e) // 가 있을때,
	if $2.state != "stable": null // $2는 위에서 2번째 인자인 a.startResult(..)의 평가값을 의미한다.
	if $startResult.res == "failure": print("damn!"); null // $startResult는 위의  startResult() 함수의 결과값을 의미한다.
	// 만약 startResult()가 2개 있다면, 윗줄의 코드는 에러로 판단한다.
```

* 위처럼 작성하는 아이디어였다. 임시 변수를 자동으로 만들어주면, `사용자가 일일이 변수를 만드는 수고를 덜지 않을까` 해서 만든 거였다.
* [d] 문제: 인자가 많을 경우 `$5` 로 해버리면 어느 값을 의미하는 것인지 한참 찾게 된다. => **일단은 이렇게 지원하지 않는다. 몇번째 인자인지 바로 파악이 어렵다.**
	* 그래서 코드의 양은 줄어들지라도 가독성이 좋아지는 것은 아니다.
	* [d] IDE가 지원을 해주는 걸로 퉁쳐서 넘어간다?
		* [u] 그래도 IDE를 전제로 해서 언어 스펙을 짜면 안되는 거 아닌가?
	* [ ] 그러면 함수호출을 인자로 넣은 부분만 만들 수 있다고 한다면? 보통 2개의 함수를 인자로 넣는 경우는 잘 없잖아?
		* [ ] 문제: 함수 호출해서 그 결과를 받아서 또 호출을 한 걸 인자로 넣는 경우는 어떻게 되는가? 위에서 `d.age.foo()` 부분이다.
			* d는 변수이므로 암시적 변수를 만들 수 없다.
			* `$age`를 하면
		* [ ] 문제: 함수 호출 마져 2개가 있는 경우는 어떻게 되는가? -> 쓸 수 없다?
* [x] 문제: 이게 잘 사용될까? => **if 문에 중간값이 사용된 경우, 해당 중간값이 값으로 도출된 시점에서 해당 if문이 실행되어야 한다.**
    * 이게 좀 구현이 어려운 부분인데,
    	1. 해당 if문에 어떠한 중간값이 사용되었는지를 알아야 하고
    	2. 해당 if문에 사용한 중간값이 모두 eval 되었는지를 판단할 수 있어야 한다.
    * 불가능한 걸로 보이진 않는다. 코틀린은 하고 있으니까. 다만 어려운 거지.
    * 변수/프로퍼티에 대해 `$`를 하면 에러다. 이 경우는 그냥 프로퍼티 이름을 쓰세요.
    * 마지막으로 반환되는 함수에 대해 $ 할 수 있다. 물론, 의미는 없으므로 경고는 내보내줄 수 있다.
    * `.`으로 계속 연결되는 함수가 있는 경우, 그 마지막 함수의 이름에다가 `$` 을 넣을 수도 있다.
        ```go
        a.getC().getD().getE()
            $getC // ok
            $getD // ok
            $getC.getD() // 이렇게 할필요가 없다. 이렇게 하면 getD()를 한번더 호출한 것이다.
        ```
    * 1번에 대해서 edge case를 다뤄보자.
        ```go
        foo(a.getC().getD(), e)
            when !$getC.isActive(): ret $getD.value // getC와 getD가 사용되었다. 그런데 getD가 더 나중이므로,
                                                    // getD까지 평가되면 이 구문이 실행된다.
        ```
    * 중간변수는 null로 평가될 수 있는 여부를 고려해야 한다.
        ```go
        foo(a.getC()?.getD(), e)
            when $getD?.isActive: .... // $getD는 d? 타입이다.
        ```
* [x] 만약 중간값 평가 중에 다시 중간값 평가를 시도한다면? => **문제 없어보인다.**
    ```go
    foo(a.getC().getD(), e) // foo
        when !$getC().isActive() // foo?  foo와 null이 있으므로.
            foo(globalC.getD(), e) // foo 타입
                when $getD.value < 5: ret null // foo?가 아닌 이유는 여기서 ret를 하기 때문에.
        when e < 5: null // null
    // 위 statement의 최종 평가된 타입은 foo?
    ```
* [x] if로 빠진 경우, 값의 평가는 어떻게 되는가? => **kotlin처럼 TypeInference 된다**
	* 쉽게 생각한다면, 해당 라인을 대체하는 거라고 생각할 것이다. *그리* 대부분은 이렇게 해도 된다. 하지만 변수 정의 같은 경우는 안되잖아?
    	```go
    	// 케이스1:
    	a := foo(a.getC().getD(), e)
    		if $getC.state != STABLE: ??
    		
    	// 케이스2:
    	foo(a.getC().getD()), e)
    		if $getC.state != STABLE: ret// 하고 싶은 것 "이 함수를 건너뛰어라."
        ```
	* [d] **1. 이 문장이 속한 블록 문을 벗어난다** 고 한다.
		* 그러면 이러한 모든 if 문이 블록문을 벗어나게끔 하면 되는건가? 아니면 이 케이스만 적용되는 건가?
	* [d] **2. nullable로 평가한다.** 고 한다.
	* [u] **3. if에서 반환한 값들에 대한 inference**를 수행한다. ret가 된다면 non-nullable로 추론한다.
    	* 예를 들면,
        	```go
        	foo(d D, e int) foo
            	....
            // 일때,
        	a := foo(a.getC().getD(), e) // foo
                when $getC.state != STABLE: null // foo?
            a is foo?

            a1 := foo(a.getC().getD(), e) // foo
                when $e > 5: ret // ret를 하면 이 block을 벗어나게 되므로, foo가 된다.
            a1 is foo
            ```

> 예전 결론:
> 	1. on은 예외처리로만 사용한다. 1줄에 대한 처리만 지원한다.
> 	2. $ 중간값 평가는 지원한다. 단, $가 사용가능해지는 건, 해당 라인 수행이 모두 끝난 뒤다. 전이 아니라. `이전`이 되버리면 scope문제, return 문제, 변수정의 문제 등이 불거져 나온다. 가능은 하겠지만 문법에 예외가 많아 우아하지 않는 것.
> 	3. try-catch를 제외한 예외처리(파라메터 조건처리, 한줄 스킵, 나머지 라인을 모두 스킵하는 케이스 등)은 if-else를 사용하라.	

* [x] switch를 대신할 수 있는가? => **패턴매칭은 별도의 키워드를 쓴다**

* 거의다 괜찮다. 근데 한가지 문제점이 있다.
* [x] `for문, if문같은 블록문에서는 on이 사용될 수 없다`에서 블록문의 기준이 무엇인가? 단순히 모든 블록문은 아니다. => **정의가 아닌stmt의 newline indent후 등장한다.**
    * 공통점이나 특징을 좀 뽑아볼까?
        * 함수의 블록문에서는 바로 등장하지 못한다.
        * if의 then 혹은 else 블록문 안에서도 바로 등장하지 못한다.
    * [*] 정의가 아닌 stmt에서 newline indent 후 등장이 가능하다. 추측컨데, 구현시에는 `onStmt := onStmt가아닌_일반stmt newline indent whenblock` 처럼 파싱패턴을 정의하면 되지 않을까?
        * `onStmt가 아닌 일반 stmt` 를 정의하는 게 쉽지 않을 것이다.

    * 왜 switch가 되는지를 검토를 해봐야 하냐면, 일반적으로 on은 **중간값이 사용된 경우, 해당 중간값이 나온 시점에서 평가**가 원칙이기 때문이다.
    * [x] 또 다른 문제는 when의 용례다. => **when은 최종 결과값을 대상으로한 패턴매칭이다.**
        1. when 은 case처럼 `if it ==` 가 앞에 있는 것처럼 취급해야 하는가?
        2. 아니면 on 처럼 if 만 있는 것처럼 취급해야 하는가?
        ```go
        a.status
            when ACTIVE, INPROGRESS: ... // if it == ACTIVE || it == INPROGRESS 라는 뜻이다.
            when DEACTIVE: ...
            else: ...

        a.getC().status
            when $getC?.visible == false // if $getC?.visible == false 라는 뜻이다.
        ```
        * [u] 중간평가가 사용되면 2처럼, 아니면 1처럼 판단한다? => **가능해보인다. 구현이 어렵지만**
            * 위에 예제는 잘 적용이 된다.
            * 그러나 반례는 없는지 더 찾아보자.
                ```go
                // #1
                a.foo(b, c) // f를 반환했을때
                    when true: // 최종 결과값이 true냐는 뜻이다.

                // #2
                def f: ....
                foo(b1 b, f1 f) f
                main() void
                    f := ... // ok. 지역변수 f가 객체 f보다 scope에서 우선된다.
                    foo(b1, f)
                        when f: // 1: 최종 결과값이 f객체냐는 뜻이다.
                        when a: // a == true 라는 뜻이다? ==> 아니. when에 올 수 있는 키워드는 최종값 혹은 중간값이 나와야 한다.
                                // 중간값이 없는 이상, 이것은 최종값이 a 냐는 물음이어야만 한다.
                        when f: // 2: 인자 f가 true냐는 뜻이다? ==> 아니. 중간값이 없으므로 최종값이 f냐는 뜻이다.

                ```

        * [u] 중간평가를 의미할때와 결과값을 의미할때를 키워드를 추가하지 않고구분한다. => **중간값이 사용되면 해당 중간값이 match될때라는 뜻이다.**
            * [d] `$ret` 같은 걸 사용한다. 이는 결과값을 의미한다. => **이건 채택한다.**
                ```go
                foo(b1, f)
                    when $ret == ACTIVE || $ret == DEACTIVE || $ret == INPROGRESS || ..... // 이런 경우는 불편하다.
                ```
        * [d] 새로운 키워드를 추가한다. => **가장 확실하지만, 일단은 키워드를 줄여보자.**
            ```go
            foo(getA().getB().getD(), f)
                on $getD != null
                    if $getD.visible == true
                        doSomething()
                when ACTIVE, DEACTIVE, INPROGRESS
                    ....
            ```
            * 이제 최종결과값인지 중간값인지가 명확해졌으므로 괜찮긴 하다.
            * 하지만 가능하면 새로운 키워드는 넣고 싶지 않은데.
            * 게다가 중간값을 사용하는 경우 어짜피 pattern matching은 사용할 수 없다. if만 된다. 어떠한 인자를 가리키는 건지를 명시해야 하기 때문이다.
                ```go
                foo(getA().getB().getD(), f)
                    when ACTIVE, DEACTIVE // 인자 f에 대한 pattern matching을 쓸 순 없다는 것.
                ```
                * 즉, when이 pattern 매칭이라면, if와는 구분해야 한다.
                * 일반인자는 if만을 지원하는 것이며, 결과값은 when이 지원된다.
                * 들여쓰기로 if, when을 쓰는 것은 새로운 기능이며 중간 평가를 하는 것이다.
                * 중간 평가 중에는 `$` 를 쓸 수 있게 된다.
                * [d] 그러면 인자를 대상으로 한 중간평가는 `if` 로 하고 싶어지는 충동을 느끼게 된다. 잘될까? => **안된다. 헷갈리고, 구현도 어렵다.**
                    ```go
                    foo(getA().getB().getD(), f)
                        if $getB.update().visible == true
                            if $update == null // 바로 중첩된 중간값 평가는 헷갈리기 쉽다.
                                ...
                            ...

                            doSomething(a.update().visible)
                                if $update == null
                                    ....
                        // 아니 사실, 중간평가는 쓸때 굳이 if가 필요한가?
                        $getB.update()
                        // if와 when이 섞이니 헷갈리긴 한다.
                        when SUCCESS
                            ....
                        $getB.close()
                        when FAIL // 만약 FAIL이었을 경우, 위의 $getB는 호출안되는 건가?
                            ...
                    ```
                    * 중간평가에 일반 코드도 나올 수 있다고 할 경우, 가장 큰 문제는 순서 문제다.
                        * 그리고 코드 독해도 너무 난잡하다.
                        * 이렇게 하고 싶은 경우라면 중간평가를 쓰지 말고, 변수를 만드는 편이 더 좋은 것 같다.
                        * 즉, 중간평가는 모든 시나리오를 커버하는 만능이 아니다.
                        * 어떤 코드를 수행하고자 하는데 최종적으로 그 코드가 평가되기 직전에 먼저 수행되는 것들을 인자선언없이 편하게 해결하고자 한다는 것에 집중해야 한다.
                        * when은 패턴매칭으로 함수의 결과를 패턴매칭한다. 결과가 이미 나온걸 한다는 점이다.
        * [u] 프로퍼티도 `$`를 붙일 수 있도록 한다. => **$를 넣었는가로 중간평가인 if인지를 구분하려는 의도였으나 새로운 키워드를 넣는게 좋겠다.**
            ```go
            foo(getA().getB().getD(), f)
                on $getD != null
                    ...
                on $f // f는 중간값이 아니다. 그냥 프로퍼티다. 그러니 여기에서는 `f` 가 맞다.
            foo(getA().getB().getD(), getA().f.view.isUpdate())
                on $f != null // ok. 이건 맞다.
            ```
> 중간평가 정리:
>     1. 중간평가란 정의 블록문이 아닌, 일반 블록문/on에 항상 사용할 수 있는 편의 문법이다.
>     2. `$` 를 앞에 둬서 메소드/프로퍼티의 중간값을 사용할 수 있다.
>     3. 중간값은 어디까지나 표현식의 일부로써 등장했을때 사용할 수 있는 것이다.
>          foo(getA().b.isUpdate(), f) // 가 있을때,
>              on $getA // ok 이고,
>              on $b // ok 이지만,
>              on $f // err다. f는 중간값이 아니다. 프로퍼티 그 자체일 뿐.
>     4. 만약 한줄에 같은 함수 호출이 2개 이상 있을 경우, 현재 문법상으로 `$` 만으로 이 2개 중 하나를 구분하는 것은 불가능하다. 이런 경우 변수를 미리 만들자.
>
>  on 정리:
>    1. 블록문이 아닌 일반 코드 라인 밑에 들여쓴 후 on을 사용할 수 있다.
>        즉, for문, if 문같은 블록문을 가지고 있는 곳에는 on을 사용할 수 없다.
>    2. 정의문에는 사용이 일반적으로 불가능하다. 하지만 예외로 할당정의문이 있다.
>         a := .......
>         처럼 되어있는 경우, on의 반환값은 `......` 에 해당한다.
>         이는, 정의문은 표현식이 아니기 때문이다. 표현식이 아니므로 `a := ??` 자체가 무언가의 값을 표현할 수 없다.
>         할당정의문은 표현식이 아니기 때문에 `foo(a := ...)` 같은 코드도 존재할 수 없다.
>         따라서 할당정의문이 나왔다면, 반드시 rhs 부분에 on에 대한 최종평가값이 들어가도록 **쉽게** 구현이 가능해진다.
>         a int
>             on 3
>         같은 정의문은 1줄이지만 의미가 없기 때문에 파싱 에러로 간주한다. 할당정의문만 1줄짜리 정의문 중에서 예외인 것이다.
>    3. on에 중간값이 있다면, 중간값이 나온 시점에 바로 해당 on의 평가에 들어간다.
>    4. on에 중간값이 없다면, **위 코드의 최종값**에 대한 pattern matching이 적용된다.
>    5. on에서 실행되는 코드와 on을 가지고 있는 trigger statement와 다른 scope에 위치한 것이다.
>         on에서 ret 하면 그 값이 trigger statement 평가값으로 영향을 준다.
>
>    is:
>        on 처럼 is 또한 패턴매칭에 쓰일 수 있다.
>        , 로 연결하는 것도 가능하다.


* * *
# [o] 인자 뒤에 `?` 만 붙이면, 해당인자가 null이 아닐때 해당라인이 실행되게 한다.

* safe-navigation은 여러모로 편한데, 불편한 경우가 간혹 있다.
* 그것은 nullable 객체의 메소드를 호출할때가 아니라 nullable을 인자에 넣어야 하는 경우. 예를 들어보자
```go
a.b.c?.foo()?.doo() // 이럴때는 편하다. 그런데,

getAOrNull()?.let {
	foo(a) // 인자로 null이 아닌 걸 넣을 때는 좀 불편하다. 특히, 인자가 2개 이상이라면..
	doSomething(a)
},
```
* 이걸 해결하기 위해서 뒤에 ?를 붙이는 문법을 지원하고자 한다. 그러면 이렇게 사용할 수 있다.
```go
foo(getAOrNull()?, getB()?) // 2개 중 하나라도 null인 경우 실행하지 않는다.
```
* * *
# [o] null체크는 어떻게 하는가? => **nullable인 경우 if (a) 처럼 할 수 없다. null체크 한답시고 if (a)도 안된다.**

* 쉽게 생각하면 C++처럼 생각하기 쉽다.
```go
a := getAOrNull()
if a
	print("a is null!")
```
* [x] 그런데 a가 bool? 이라면 어떻게 되는 거지?
    * 코틀린은 에러가 발생한다. if (a) 처럼 쓰지 말고, if (a == false) 처럼 쓰라고 한다.
    * [x] 다른 언어는? => **Swift도 마찬가지다. 따라가야 겠지.**

> 정리:
>     null체크를 하려면 if a == null 처럼 해야지, c++처럼 `if a` 식으로 할 수는 없다.
>     bool? 타입일 경우 if a 처럼해버리면 에러다. if a == true 처럼 해야 한다.
* * *
# [o] on을 switch, try-catch 양쪽에 모두 사용되도록 쓸 수 있나? => **예**

* on으로 빠져버리면 원래의 context로 복구가 안되어야 한다. 예를 보자.
```kotlin
try {
	val visible = getView(someId).visibility
	visible = false
} catch (e: NameNotFoundException) {
	return false
}
```

* try 블록이 있기 때문에 try 안에서 만든 변수는 밖에다 영향을 끼치지 못한다. 이걸 자연스럽게 이해가 된다.
* 그런데 `on` 방식은 사실상 블록을 없앤 거기 때문에 이 부분에서 괴리가 오게 된다.
* [x] 어떻게 하면 자연스럽게 사용자가 `아 on 에서 만든 변수는 밖에다가 영향을 미치지 못하는 구나` 하고 인식하게 할 수 있을까?
	* 내가 하고자 하는 것은 `on`을 패턴매칭이라는 기능으로 만들어 버리는 것이다.
		* 이 패턴 매칭을 exception에서 사용하든, switch로 사용하든 둘다 사용이 가능하도록.
        * [x] 새로 변경된 `on` 에 대해서 요약하면,
            1. 블록문에는 on을 사용하지 못한다.
            2. on은 trigger statement와 다른 scope에 속한다.
            3. `$`가 사용되지 않을 경우, trigger statement의 최종값을 사용한다.
            4. 최종값을 사용한 경우는 trigger statement가 전부 실행되고 나서 해당 on이 평가된다.
            5. 정의문에는 on은 사용될 수 없지만, def assignment 예외적으로 trigger statement로 사용 된다.
            6. def assignment의 경우 rhs 부분이 trigger statement가 된다.
	```go
	a := status // defAssignment의 경우 rhs 부분이 trigger가 된다.
		on CREATED, PROGRESS // $가 없으므로 status의 최종평가값이 == CREATED냐는 패턴매칭이 된다.
			doSomething() // doSomething()의 반환값이 status에 평가값이 된다.
			// fallthrough가 되진 않는다.
		on DONE: ....
		else
			....
		// [?] finally가 필요한가?
	doFinal() // 여기도 실행이 되야 하는 거겠지.

	visible := getView(someId).updateVisibility()		​
    	is NameNotFoundException // 별다른 타입 명시가 없어도 모든 타입은 에러타입에 대한 합타입이다.
			// 블록문 처럼 되어있지만 on의 블록문은 외부와 구분되지 않는다.
			// 즉. visible이 존재하는 블록에서 이 구문을 실행하는 것과 같다.
			ret
	visible = false
	```

* 변수의 정의를 expression으로 한다는 게 이렇게나 문제를 낳다니.

* * *
# [x] 여러개의 메시지를 처리하는 함수를 만들면 무슨 이득이 있을까? => **큰 이득이 없다**

* 객체는 이미 여러개의 메시지를 처리한다. 생성자 오버로딩을 통해서.
* [d] 그렇다면 함수 오버로딩 또한 `메시지를 여러개 처리하는 composition메소드를 만드는 것`라고 볼 수 있을까?
    * 다시말하면, 예전에는 객체 안에 함수가 담기는데, 일반 함수도 있고, 오버로딩 된 함수들도 있었다.
    * 오버로딩된 함수들은 객체 바로 밑에 있을 뿐이지, 얘네들을 묶어서 하나로 관리하고 이러한 구조가 아니었다.
    * 이것들을 하나로 묶는 방향으로 접근했을때 과연 문법적/개념적 인 혁신이 일어날 수 있는가?
        * 문법적으로만 본다면
            * 오버로딩된 함수들끼리의 공통점은 함수명 뿐이다.
            * 그러니 줄일 수 있는 부분도 함수명 뿐이다.
            * 문법적으로는 큰 이득은 없다.
        * 개념적으로 본다면
            * 메시지를 하부 원소에 redirect 해주는 거라고 볼 수 있다.
            * 이거는 사실상 composition을 생각할때 나왔던 아이디어다.
            * 현재로써는 도입이 어렵다.

* * *
# [o] 정의는 Expression이 아니다? => **네. 아니다.**

* 변수의 정의를 expression으로 했을때의 demerit가 너무 많긴 하다.
    * 정말로 온갖 문법에서 에러가 발생한다.
    * 게다가 변수의 정의가 함수 인자 깊숙이 나올 수 있으므로 한눈에 파악이 어려운 곳이 많다.
* 정의는 origin객체의 정의든 여러가지 있으므로 `이것들도 포함해서 모두 expression이 아니다..` 라고 해야만 할 것이다.
* 그리고 다른 expression 기반 언어를 보더라도 변수의 정의까지 expression으로 한 경우는 드물다.
* if 문에서는 약간의 이득을 볼 수 있는 경우가 있었다. 예를 들면,
	```go
	view := getView(someId)
	if view.visible != false
		doSomething(view)
	// 이걸 한번에 쓰고 싶은 충동이 가끔 생긴다.
	// 그래서...
	if (view := getView(someId)).visible != false
		doSomething(view)
	// 그런데 보다시피 문법이 더럽다.

    // 물론 비교적 깨끗한 경우도 있다.
    when(a := getFoo())
        is Foo: ....
        is Boo: ....
    a.doSomething()
	```
	* 물론 보기에 더럽다. 그러니 지원하지 않는 것도 괜찮은 생각이 들었던 거다.
	* [x] 지원하지 않는다고 쳐도, 이 코드를 더 간단하게 줄이는 게 가능하다.
	```go
	if getViewBigFunctionOhYeah(someId).visible != false
		doSomething($getViewBigFunctionOhYeah) // 암시적 중간 변수 정의로 간략하게 사용이 가능해졌다.

    // 2번째 케이스의 경우에는 pattern matching 문법을 조금 바꾸면 가능해진다.
    a := getFoo()
        is Foo:
            ...
            return // 여기서 return을 하지 않으면 a 타입은 foo?가 된다.
        when is Boo:
            ...
            return
    a.doSomething()
	```

### 정의를 expr로 해주는 다른 언어들은 뭐가 있을까?

* kotlin
    * assignment는 expr 아님
    * 그런데 when 안에서는 변수 정의를 할 수 있다. if안에서는 안된다. *이거 뭐야. 에휴 역시 일관성 없는 코틀린*
    ```kotlin
    when (val f = foo()) {
        ....
    }
    ```
* Expression based 라고 자칭하는 Rust는 역시 변수 정의는 지원하지 않음.

* [*] 결론: 굳이 지원할 필요를 모르겠다.

* * *
# [o] err에 대한 type inference를 지원해야 한다.

* namu에서는 `?`는 null이 아니라 err에 대한 합타입을 의미한다.
* 그러므로 순수타입보다는 이 합타입으로 로직이 빠지는 경우가 상대적으로 더 많을 것이다.
* 그러니 이에 대한 대비책으로 smartcast를 지원해주는 게 좋을 것으로 보인다.
* 물론 쉽지는 않을 것이다. 하지만 구현 난이도를 제외하고 순수하게 내가 만든 문법과 harmony를 이루는, 개념적으로만 이 문제를 바라본다면, 이 기능은 반드시 들어가야만 한다.
* 일단 저 수준 (앞에서 `if res is err` 해두면 합타입이 아니라 순수타입으로 타입 추론) 으로 구현하는 것을 1차 목표로 한다.
* if 외에 다른 케이스들은 뭐가 있는지 철저하게 다른 언어들을 벤치마킹 해보자.
* * *
# [o] 실제 예제 적용

* 비교적 짧아진 코틀린 코드를 놓고, namu 코드로 얼마나 개선되는지 확인해본다.
* 필요하면 새로운 아이디어를 제시한다.

* [u] 케이스1
    ```kotlin
    repo.getBy(STABLE).apply {
        if (isNotEmpty()) {
            updateData(this[0].id)
        }
    }

    // 좀 더 짧게?:
    repo.getBy(STABLE).apply { if (isNotEmpty()) updateData(this[0].id) }
    ```
    * 내꺼
    ```go
    if repo.getBy(STABLE).isNotEmpty()
        updateData($getBy[0].id) // 중간값 표현

    // 나도 좀 더 짧게:
    if repo.getBy(STABLE).isNotEmpty(): updateData($getBy[0].id) // kotlin을 아무리 짧게 해도, 내께 훨씬 짧다.
    ```
    * 끝내준다.

* [u] 케이스2 => **큰 차이 없다**
    ```kotlin
    binding.mainView.messageButton.run {
        text = context?.getString(R.string.my_example_message)
        visibility = View.VISIBLE
        setPadding(1, 1, 1, 0)
    }
    ```
    * 내꺼
    ```go
    with binding.mainView.messageButton
        text = context?.getString(R.string.my_example_message)
        visibility = View.VISIBLE
        setPadding(1, 1, 1, 0)
    ```
* * *
# [o] 함수의 반환형은 inference 하게 해달라. ==> **안된다. 람다만 된다.**
* [u] 파싱이 되는가? ==> **네**
* [u] 가장 큰 문제는 함수 호출과 구분이 더더욱 힘들어진다는 것이다. ==> **빈 함수는 존재하지 않거나, 별도의 방법으로 빈 함수를 표현한다면 가능하다**
    * [x] `빈 함수는 존재하지 않는다` 라고 가정하면? ==> **2번의 케이스는 사용자가 직접 채운다.**
        * 일단 함수 body가 없는 경우는 2가지 다.
            1. abstract func을 정의하는 경우
            2. call시 에러는 발생하고 싶지 않지만, 정말로 채울 body가 없는 경우  ==> **생각해보니, 다른 언어에서도 이 경우에는 직접 개발자가 채우도록 한다. 키워드를 추가하는게 아니다.**
        * 1번의 경우에는 키워드를 추가하든, `= null` 을 넣든 해야 한다.
    * [v] 가장 큰 문제는 구현이다. 왜냐하면 verification 단계에서 반환형을 알 수 있으니까. ==> **할당 정의문에서 하듯이 하면 되긴 할 것이다. 큰 문제는 아니라고 본다.**
        * 파싱할 때는 반환형을 `나중에 채울께` 라고 mark 해두고, verification할때 함수 body를 하나하나 eval하면서 `return` 혹은 `last stmt`로 반환형을 확정짓는 구현이 필요할 것이다.
* [u] 가능은 하다. 그러다 하지 않을것이다. 퍼포먼스가 너무 많이 요구된다.
    * 현재 알고리즘으로는 종속성을 풀기 위해서 무한루프를 돌아야 한다.
    * 함수의 반환형을 특정하려면 결국 함수 전체를 돌아봐야 한다.
        * 맨 마지막 코드, 어딘가 구석에 있을 return 을 찾기 위해.
    * 그런데 문제는 함수의 본문 중에는 수없이 많은 종속성이 있다는 것이다. 즉 풀어야할 종속성이 기하급수적으로 늘어나게 된다.
    * 그러니 하지 않겠다.
* [x] 그런데 느리다면서 람다는 왜 해주냐?
    * 람다는 TypeInferece로 돌리지 않을 것이다.
    * 람다는 반드시 함수호출 안에 인자로 넣어야 한다.
    * 그러니 함수의 param에 정의된 함수타입의 반환형을 그대로 넣어줄 것이다.
    * TypeInference가 아니니, 무한루프를 돌릴 필요도 없어지는 것이다.
> 요약:
>        함수의 반환형에 대한 Inference는 지원하지 않는다. 매우 느려지기 때문이다.
>        단, 람다는 예외다. 람다의 반환형은 호출될 함수의 param의 함수타입의 반환형에서 그대로 가져올 것이다.
* * *
# [o] verifier는 겉타입과 속타입에 대한 정보를 가지고 있어야 하고, 이걸로 에러검출을 할 수 있어야 한다. ==> **str의 type으로 사용한다**
* 현재 verifier는 진짜 타입과 겉 타입이라는 구분이 없다. 상속이 없었기 때문에 subtyping이 없었고, 그래서 겉타입이라는 게 없이 무조건 진짜타입으로 다 타입비교를 해왔다.
* 하지만 이제부터는 verifier는 참조자를 만들면서 속타입과 겉타입에 대한 정보를 기록해둬야만 한다.
* 예를 보자.
```go
def A
    foo() void: ....
def B A
    foo() void: ....
a := A()
b := B()
a = b // (1) ok
b = a // (2) err
a = B() // (3) ok
a = A() // (4) err
```
* 현재의 알고리즘은 참조자라는 개념이 없어서 실제 타입만으로 에러검출을 시도한다.
* 그래서 `a = A()` 코드를 보았을때 verifier는 a가 가리키는 실체타입은 B()이므로 B.isSuper(A) 가 되어서 에러로 판단되게 된다.
* 따라서 반드시 참조자의 타입정보를 어딘가에는 보관을 하고 있어야 한다.
* 어디다 할까?
* [?] 1안: 참조자를 하나 만든다. refer로
* [u] 2안: str을 이용한다. ==> **add(K&, str) 를 추가하고 get()의 반환타입을 str로 변경**
    * 먼저 분석을 해보면
        * 현재의 알고리즘은
            ```cpp
            typedef tstr<V, TACTIC> wrap;
            typedef std::multimap<K, wrap> cmap;
            typedef tnmap<node, immutableTactic> scope
            ```
        * 에서 볼 수 있듯, scope 안에 이미 str이 고정되어 들어있고,
        ```cpp
            class tnmap {
                nbool add(const K& key, const V& new1) override;
            };
        ```
        * 처럼 tnmap은 str에서 값을 꺼내서 add 하도록 API가 되어있으므로 외부에서 str의 타입을 scope 안에있는 str로 전달할 방법이 없다.
        * 다만 str의 type은 operator=() 시마다 매번 복사되도록 되어있으므로 add시 값을 전달할 방법만 제공한다면 나머지는 거저 먹을 수 있을 것으로 보인다.
    * 따라서 수정안은 이렇다.
        1. `tnbicontainable/tnucontainable::add(const K& key, const str wrap)` 을 구현한다. 이제 외부에서 container의 str의 type을 조작할 수 있게 된다.
        2. verifier는 defAssign, defType등의 문법이 사용되었을때는 add(key, str()) 를 호출하도록 한다. 이때 str은 물론 typeInference로 유추한 type 정보를 가지고 있어야 한다.
        3. assign 같은 문법에서는 절대로 add(key, str()) 호출하지 않는다. 기존대로 add(key, \*str) 을 하도록 한다.
        4. 이제 str은 타입정보를 가지고 있으므로 str을 반대로 container에서 꺼낼 방법을 제공해줘야 한다.
        5. 많은 생각을 해본결과, 역시 container::get() 은 V& 가 아니라 str이 나가는게 좋다는 결론에 다다랐다. 이유가 있는데,
            1. node::sub()가 사실상 str로부터 type 정보를 꺼내기 위한 많은 경로의 대부분을 차지 한다.
            2. 따라서 node::subAsStrType()을 만들고, 외부에서 껀 by 껀으로 type정보를 필요로 하는 부분이면 subAsStrType() 을 사용하도록 할 수도 있겠으나,
            3. 그렇게 하면 node::sub() 를 통하지 않는 많은 경로도 다 찾아야 하고, node::sub(조건절lambda) 같이 variant sub 함수를 참조하는 경우를 위해서 다 바꿔줘야 한다.
            4. 그러니 C++ 코드를 작성할때만 좀 귀찮으면 되니거니까. 이렇게 하고 함수를 일원화 합시다.
> 요약:
>     str을 통해서 겉타입을 표현한다.
>     str이 만들어지는 모든 경로에 겉타입을 뭐로 할 것인지를 고려해야 하기 때문에 생각보다 매우 큰 수정사항이다.
>     단적으로 예를 들면, `a + 5` 라는 구문이 있을 때. 결과가 담길 str은 tstr\<node\> 여선 안된다. a + 5를 돌린 결과가 flt라고 하자. 그러면 tstr\<flt\>가 만들어져야 한다.
* * *
# [o] 용어의 통일: slot --> pack ==> **slot 대신 pack이라고 이름붙이고, pack은 obj에서 상속받자.**
* 구현을 보면 pack을 대신해서 slot을 대대적으로 쓰고 있는데 slot은 node 상속받고 있다.
* slot은 obj \_pack이라는 걸 가지고 있고 이것을 proxy로 하고 있는데 그냥 pack을 obj에서 상속받으면 되는 걸로 보인다.
* * *
# [o] covariant를 어떻게 구현할까? ==> **비교적 쉽게 가능하다.**
* 일단 예제부터 보자. 다음을 구현할 수 있으면 된다.
```go
def A: foo() A: ...
def B A
    foo() B: ...
    koo() void: ...
a A
b B
a1 A := A()

a.foo() // 반환타입 A
b.foo() // 반환타입 B
a1.foo() // 반환타입 A
a = b // ok
a.foo() // 반환타입 A, 실제 객체 B
a.koo() // err
```
* 어떻게 구현하면 좋을까?
* [u] 1안: 현재의 subtyping verification 알고리즘을 바로 적용해본다. ==> **큰 무리 없이 현재 알고리즘이 covariant를 지원하는 걸로 보인다.**
    * verification 단계에서는 sub type을 엄격하게 따지지만, 실제로 run 할때는 그냥 subs() 해서 가장 최신 함수를 호출하기만 하는 방식이다.
        * 이 경우 `a.foo()`, `b.foo()` 는 각각 의도한 대로 된다.
        * verifier는 두번째 `a.foo()`를 만나게 되고 a의 참조자는 A 이므로 A scope안에 foo()가 있는지를 찾을 것이다. 즉 문제는 없다. 2번째 `a.foo()`가 끝나더라도 a는 여전히 A다.
        * verifier는 이후 `a.koo()`를 만난다. a는 여전히 A 타입이기 때문에 A에는 koo()가 없으므로 에러가 된다.
        * verifier가 `b.foo()`를 만났을 때 b는 B타입이라고 했으므로 B로 추출된 scope에서 foo()의 반환타입을 찾는다. 이는 B다.
    * 이처럼 verification에는 문제가 없다. 실행은 어떻지?
        * 2번째 `a.foo()`를 실행하는 시점에서 a가 A타입이건 B타입이건 신경쓰지 않는다. a참조자가 가리키는 객체에게 foo()라는 함수를 subs() 위에서부터 찾아서 실행할 뿐이다.
        * a는 실제로 B객체이기 때문에 b.foo()가 실행된다. 이건 override 기능이다.
# [o] 생성자는 상속되어서는 안된다. 어떻게 해결하지? ==> **생성자는 일반 함수 였다. 단, verifier는 origin객체에 대한 기반타입의 생성자호출은 에러로 간주한다.**
* 바로 예제를 보자.
    ```go
    def A
        me(): ....
    def B A
        me(a int): age = a
        age := 0
    b := B() // 현재 코드에서는 에러가 아니다.
    ```
    * 본래 B()는 B 객체 안에 정의되지 않았으므로 에러가 나야 하지만,
    * 현재는 생성자는 그냥 member로써 취급하고 있기 때문에 subs() 안에 들어가 있다.
    * 이 상태에서 상속을 하게 되면 B에는 me() 와 me(int) 2가지가 존재하게 된다.
    * 그러니 B()라고 해도 에러는 아닌 것이다.
    * [d] 1안: 생성자는 static이다.
        * 개념적으로 본다면 사실 이게 맞다.
        * 대신 이렇게 하면 static을 어떻게 표현하냐는 문제가 남는다. 우리는 static은 with로 하기로 했는데 말야..
        * [x] 억지로 하면 어떻게든 할 수는 있을 것이다. ==> **근데 역시 이런 방법은 더럽다. 가능하면 피하고 싶다.**
            * 가장 쉬운 방법은 생성자만 별도로 관리하는 static subs를 담는 배열을 origin object 안에 두는 거지.
            * 아니면 with안에 생성자를 만들어 두도록 하는 syntactic sugar를 만들어 볼 수도 있다.
            * 어쨌든 복사객체 안에는 생성자가 없고, origin 객체에만 생성자가 있도록 해둔다면 verification시 에러를 탐지해낼 수 있다.
    * [u] 2안: 코드를 사용하는 사용자 관점에서 개념적으로 생각해볼까? ==> **verifier는 생성자를 호출할 때, 주어진 타입에 상위생성자를 호출하진 못하게 한다.**
        ```go
        def A: me(): ....
        def B A: me(a int): ....
        a A := get(randomVal)
        get(val int) A
            val
                on 1: return A()
                else: return B(0)
        a()
        a(a)
        ```
        * a()의 타입은 뭐지? ==> **정답은 A** 이다.
        * static이란 **thisptr가 없고** 그리고 **override가 불가능한** 함수다.
        * 무슨말인가 하니, 일반 함수를 만들었는데 그 함수는 thisptr를 사용하지 않았고 override도 하지 않았다면 함수 작성자 입장에서는 static 인 것과 마찬가지란 얘기다.
            * 물론 함수 호출자 입장에서는 차이가 있다. 근데 이건 아무튼 넘어가자. 지금은 작성자 입장이 중요하니까.
        * 따라서 마지막 a()를 했을 때, a가 A 였다면 결과는 A::me() 가 호출되는 게 맞다.
        * [x] 그런데 a가 B(0) 였는데 a()를 호출했다면? ==> **B()가 생성된다. 아주 중요한 점은 verifier는 A타입으로 인식해야 한다.**
            * 생성자가 static이 아니라 일반 함수라면 파생클래스에서 기반 클래스 메소드를 호출할 수 있어야 한다. 그러니 이 경우는 A()가 반환된다.
            * 그리고 A()는 복사생성자가 아니라 가상생성자처럼 동작할 거기 때문에 괜찮다. 찜찜한가? 그러면 명확하게 origin obj를 사용해서 생성자를 호출하면 될일이다.
        * 그런데 a 가 A() 였는데 a(a)를 호출한다면?  당연히 A()가 타입이 된다.
        * [x] 그러면 a가 B(0) 였는데 a(a)를 호출한다면? ==> **B(0)를 참조하는 A 타입** 이다.
            * 가상복사생성자가 되지만 a의 타입은 A 이므로 B()가 들어간 A가 되어야 할 것이다.
            * 복사생성자는 override를 하는 경우도 종래의 언어에서는 흔하다!
        * [u] 생성자의 반환타입은 어떻게 되는가? ==> **covariant 구현방법을 따르면 된다. 해당 구현 알고리즘은 별도 항목 참조**
            * 문제 정리
                * 즉 A의 생성자는 A를 반환한다. B의 생성자는 B를 반환한다.
                * 생성자는 overriding이 되어있다.
                * 위의 예에서 A(5)을 호출하면 에러가 된다. verifier는 A타입의 scope만 추출할 것이고 거기에는 me(int)가 없으니까.
                * A객체를 A타입으로 보고 me()를 호출하면 A::me()가 될 것이다. 아무런 문제가 없다.
                * B객체를 A타입으로 보고 me()를 호출하면, B::me()가 수행될 것이다. 그러나 A타입의 참조자가 생성되어야 한다.
            * [u] 1안: 생성자도 override가 가능한 일반 함수로 본다. ==> **covariant 를 그대로 따른다. **
        * [u] 문제의 핵심인 생성자 상속을 해결해보자. ==> **verifier는 origin객체에 대한 직접적인 기반타입의 생성자 호출은 에러로 간주한다.**
            * 문제 설명
                * 생성자는 일반함수다. 그러니 상속이 가능하다.
                * 상속이 된다는 말은 A와 상속한 B가 있을 때, B객체는 B()도 가지고 있지만, A()나 A(int)도 가지고 있다는 뜻이다. 그리고 실제로 가지고도 있다.
                * 다음 예제를 보자.
                    ```go
                    def A
                        me(): ..
                        me(n int): ...
                    def B A
                        me(): ...
                        me(n flt): ...
                    a A
                    b B
                    a1 A := b

                    a() // A::A()
                    a(5) // A::A(int)
                    b() // B::B()
                    b(5) // err. run은 가능하지만 verifier는 b의 타입인 B에서 (5)가 없으므로 에러를 내보낸다.
                    b(3.5) // B::B(flt)
                    a1() // verifier는 A::A()가 있으므로 pass, 실제로는 B::B() 호출
                    a1(5) // A::A(int)가 호출
                    a1(2.5) // err. A scope에는 A(flt)가 없다.

                    // 반면..
                    A() // A::A()
                    A(2) // A::A(int)
                    B() // B::B()
                    B(2) // err가 되야 한다.
                    B(2.5) // B::B(flt)
                    ```
            * [u] 1안: verifier는 origin 객체에 대한 기반타입의 생성자 호출은 에러로 취급한다. 실제 호출은 가능한 구조이지만 말이다. ==> **OK**
> 요약:
>     내 언어의 `생성자`란 그냥 일반 함수다. static이 아니다.
>     origin 객체 A에 대한 복사객체 a가 있을 때,
>         1. A()를 하면 언제든지 객체 A가 생성된다.
>         2. a()를 하게 되면 A의 구체타입 중 하나인 객체가 생성된다. A일 수도, A의 파생객체일 수도 있다.
>             일종의 가상생성자다. 이 동작이 안 든다면, a() 대신 A()를 하면 될 일이다.
>     생성자는 일반함수이므로 override도 가능하고, Covariant도 지원 된다.
>     단 verifier시 origin 객체에 대한 직접적인 생성자 호출을 발견하게 되면, 그 생성자가 기반객체의 생성자일 경우 에러로 간주한다.
>     구조적으로는 물론 호출이 가능하지만 말이다.
* * *
# [o] 상속으로 origin객체를 정의할 때 표현식을 통해 완전 객체를 만들 수 있어야 한다. ==> **지원한다. parsing에서 만들어진 객체를 preEval단계에서 생성자를 호출시킨다.**
* 생각해보자. 상속을 처리할때 다음과 같은 코드가 가능해야 한다.
```go
def A
    me(newAge int): age = newAge
    age := 0
def B A(5) // <-- B완전객체는 만들어지고 나서 A(5) 생성자를 통과한다는 뜻이다.
    ....
```
* B는 기본 생성자다. 그러니 `def B` 뒤에 괄호가 없어도 완전객체가 될 수 있는데, 아쉽게도 A는 완전객체가 아니다.
* 그러므로 `A(5)`의 의미는, 5를 인자로 줘서 B를 완전객체로 만들려는 것이다.
* [u] 언제 B객체를 만들어야 하지? 누가 만들어야 하지? 어떻게 만들지? ==> **완전객체를 만드는 알고리즘을 따른다.**
    * 요구사항을 좀 더 그러모아 보자.
        * 아래 항목에도 나오겠지만 with를 통해서 static을 해결하려는 시도가 있다. 이 경우 scope을 건드리게 된다.
        * 상속도 있다.
        * member의 초기식도 있다. `a := foo(5)` 같은.
        * 그리고 이 완전객체 초기식도 있고.
    * 쉽게 생각해보면 3 중 하나다.
        1. verification 이전에 만든다.
        2. verification 도중에 만든다.
        3. verification이 끝나고 실행 중에 만든다.
    * 하지만 쉽게 예상이 되듯이, 처음부터 만들어 놓고 들어가면 참 편하다.
    * 객체의 member가 아니라 pack의 member라면 초기식이 지금도 존재한다.
    * 프로그램이 시작될 때 먼저 동작하도록 구현이 이미 되어있다.
    * 이게 동작할 수 있는 이유는, parser가 끝난 시점에서 이미 `실행은 가능한 상태`가 되기 때문이다.
    * verifier는 동작 중에 새로운 타입을 추가하거나 함수의 signature를 바꾸거나 하지 않는다. 함수의 body는 바꿀 수 있어도.
    * 게다가 다음의 초기화 식들이 순환 참조를 띄고 있는 경우도 해결 할 수 있어야 한다.
        ```go
        def B A(1)
            ...
        def A C(0)
            ...
        def C
            with b := B()
        ```
    * `만약 빈공간을 만들면서 상속관계를 만든다` 가 안된다고 한다면, 남는 것은 `객체를 만들어 놓고, 상속관계는 나중에 완성한다.` 만 남는다.
* [d] 1안: 어떻게든 Parser가 객체를 만들때 상속관계를 구축해놓는다.
    * 가장 큰 문제는 Parser가 동작할 시점에는 B를 미리 생성할 수 없다는 것이다. A가 이미 parsing 되었는지 모르니까.
        * B를 발견 했을 때 A의 빈공간(scope)은 남겨두고 거기 위에 B를 올려서 B를 일단 먼저 채우는 방식을 쓰면 어떨까 싶기도 하겠지만,
        * A를 나중에 발견했을때 거기에 property가 나오면 처리가 곤란해진다. 만약 그렇게 한다고 해도, 단순한 방법으로는 안된다.
* [d] 1\`안: 1안을 응용한다. Parser는 각 객체와 딱 상속 관계 까지만 놓고, verification을 가기 전에 상속을 완성한다.
    * Parser가 만드는 상속관계는 완벽하지 않다. 어디까지나 부모가 누구인지, scope이 chain된 정도만 된다.
    * [?] 이 scope을 어떻게 구성하냐가 첫번째 관건이다.
    * 또 다른  문제는 상속시 표현식을 쓸 수 있다는 점이다.
        * Parser가 만들어낸 상속을 표현한 객체와 상속 초기화 표현식을 돌려서 나온 것은 엄연히 다른 객체다.
        * [?] 아니면, 동일한 객체로 만들 방법이 있는가? Parser가 만들어낸 상속을 표현한 객체를, 상속 초기화표현식에 넣고 돌릴 수 있는가?
* [u] 2안: Parser는 객체만 만든다. verifier를 가기 전에 상속관계를 구성한다. ==> **이미 preEval단계가 추가되었으니, 이걸 이용한다.**
    * 일단 PASS가 늘어난다. 느리다는 것이다.
    * 그리고 초기화 표현식에서 다시 아직 상속 관계가 구축되지 않은 객체를 참조하고 있을 경우가 있기 때문이다.
    * 그리고 이 의존이 순환참조를 띄는 경우도 존재할 것이다.
    * 알고리즘적으로 풀기가 좀 어렵다는 걸 알 수 있다.
    * PASS를 늘려서 푸는 게 맞지, 이런식으로 의존관계를 풀 수 없다.
    * 그러니 Parser를 돌릴때(즉, 1 PASS일때)를 이용하는 게 맞아 보인다.
* [d] 3안: 애초에 상속시 초기화 표현식 기능을 제공하지 않는다. ==> **기본생성자는 따로 두고, 완전객체를 만들때는 별도로 만들고 싶어지는 경우가 생길것이다. 완전객체는 복사객체와 다르니까. 그러니 이렇게는 안된다.**
    * [u] 기존 기능으로 대체가 안되는가? ==> **된다. 하지만 사용성에 문제가 생길 수 있으니 지원해야 한다.**
        ```go
        def A
            me(newAge int): age = newAge
            age := 0
        def B A(5) // <-- 이게 무슨 의미일지 잠시 생각해보자.
            ....
        def C A
            me(): super(5) // 이거랑 같은 거 아냐??
        ```
        * 좀 다르다고 생각할지도 모른다. 그러나 완전객체가 만들어지는 규칙을 다시 곱씹어보면 말이 된다.
        * 완전객체는
            1. 객체명 뒤에 소괄호를 쓰거나,
            2. public 기본 생성자가 존재할 경우에 해당한다.
        * 따라서 위의 코드는 `def C() A` 와 같은 것이다. C는 완전 객체다. 굳이 `def C A(5)` 같은 표현식 기능을 제공할 필요가 없다.
        * 물론 완전객체를 언제 만드냐는 게 있지만, 별도의 항목에서 생각할 것이다.
* * *
# [o] 최적화 코드를 돌리는 방법은? ==> **interpreter를 이용해서 최적화 버전을 돌린다. 차후에 여유가 생기면 VM을 만드는 걸 고려해본다.**
* Why?
    * 최적화 코드란, verification과 편집이 끝난, 일종의 release 버전 코드다. 실행코드다. 즉 비가역적 코드다.
    * 돌리기만 할 수 있으면, 그리고 돌리는 과정이 매우 빠르면 좋다.
    * 의존성 정보를 수집하지 않아도 된다.
    * 어떻게 이러한 데이터구조를 define을 할지 방향을 정하고,
    * 실행하는 방법에 대한 큰 그림을 정한다.
* [d] 1안: 이 비가역적 코드는 일종의 바이트코드로 만든다. ==> **결국 가야할 길은 많는 것 같다. 부트스트래핑은 지원할 생각이 없다. 그리고 지금 하기에는 너무 할일이 많다.**
    * 그러면 이 바이트 코드를 돌리는 VM도 만들어야 한다. 즉 일이 배가 되는 것이지.
    * 장점은
        1. 속도가 빠르다.
        2. 부트스트래핑이 가능하다. VM은 C++로 짜야겠지만. 결국 C++코드가 있는 거기때문에 진정한 부트스트래핑은 아니다.
    * 단점은
        1. 배보다 배꼽이 더 크다: 개발속도가 더 느려진다. 할일이 2배가 된다.
* [u] 2안: 1안을 나중에 가고, 일단은 현재구조에서 최대한 최적화 한다. 나중에 없앨 생각을 하고 만든다.
    * 나중에 덜어내고 1안으로 가려면, 그게 가능한 구조를 그리면 될 것이다.
    1. 넣었다가 뺐다가 가능하고
    2. 최적화는 확실히 되고.
    * 그러면 어떻게 하면 좋을까?
    * 현재 구조는 verifier, interpreter, parser, loweventer.
    * [u] 최적화는 AST를 어떻게 저장하냐는 것이다. AST채로 저장하고 읽을 수 있으면 그게 베스트일 것이다. ==> **2진으로 저장하고 읽어 들인다.**
    * [u] AST자체는 검증이 끝났어도, 시스템 내에 AST를 verification 당시에 있던 모듈이 설치되어 있는가는 알 수 없다. 방법은 3가지다. ==> **최적화파일을 만들때 어떠한 버전의 외부 Module을 참조하는지도 다 기록해둔다.**
        * [d] 1안: 역시 AST 채로 읽었어도 verification을 한다.
            * 이때 외부 모듈에 한해서만 verification을 할 수 있나?
        * [d] 2안: 검증하지 않는다. 대신 런타임 에러를 내보낸다.
        * [u] 3안: 최적화 파일에 어떠한 버전의 Module을 사용하는지도 다 기록해둔다.
            * 해당 파일을 실행할 때 해당 module이 시스템에 설치되어있는지 확인해서 경고 혹은 에러를 내보낸다.
    * [u] 그러면 구조는 어떻게 될까? ==> **interpreter를 이용한다.**
        * 요구사항 정리하자.
            1. 최적화 파일은 AST로 memory에 로드된다.
                * AST로 serialization은 신규 구현이다.
            2. Module이 시스템에 설치되어있는지만 확인할 뿐, verification은 돌리지 않는다.
                * 이 기능은 최적화 파일이 아닌, src와 manifest 채로 load할때는 필요로 하는 코드가 된다.
                * 일단 드는 생각은 verifier에서 돌리면 될 것 같다. verifier는 즉, moduler를 내부에서 접근한다.
                * interpreter는 src 묶음과 manifest 2개를 받아들이는 함수와 최적화파일을 받아들이는 함수. 2개를 추가해야 한다.
> 요약:
>     제대로된 방법은 VM과 바이트코드를 만드는 방법이다. 하지만 지금 하기에는 시간이 너무 걸린다.
>     VM을 만들어도 부트스트래핑을 할지는 고민을 따로 해봐야 한다.
>     일단 그때까지는 최적화된 AST를 serialization, 2진모드로 읽고 저장하는 방식을 택한다.
>     이 최적화파일은 모든 src로부터 나온 AST정보와 manifest 정보 2개가 하나에 들어있어야 한다.
>     manifest를 load할때 module간 의존성도 load가 된다. verifier에서 의존성 정보를 만들지 않는다.
>     이때 manifest에 명시된 외부Module이 시스템(moduler)과 비교해서 에러 혹은 경고를 내보낸다. 이는 최적화파일에서도 동일하게 동작한다.
>     interpreter는 load(srcs, manifest) 함수와 load(최적화파일) 2개 함수가 추가한다.
* * *
# [x] verifier는 타입만 확인하나? 아니면 지금처럼 객체를  직접 만드나? ==> **그냥 객체 생성하자.**
* 지금은 객체를 직접 만들면서 검증한다.
* 하지만 보통은 타입만 추출한 후, `타입에 이러이러한 sub가 있는가?` 를 위주로 검증한다. 객체를 만드는 작업은 분명히 비용이 추가로 발생하니까.
* 다음이 요구사항이다.
    1. 지금은 아직 **ttype과 orgObj를 매핑해주는 방법** 이 없다. 이게 우선 구현이 되어야 하고
    2. str로부터 항상 객체를 꺼내면 안된다. str.getType()을 가져와서 이 타입의 orgObj를 가져와서 여기다 대고 뭔가를 해야 한다.
    3. 각 함수나 변수등 str을 반환하는 것들마다 세심하게 type 처리를 해줘야 한다.
    4. 그리고 실제로 객체가 생성되지 않도록 해줘야 한다.
    5. 객체에 대고 getEval()을 함부로 호출할 수 없다. 실제로 코드를 돌려버리기 때문이다. 이게 가장 애매한 부분이다.
        * 우리가 이렇게 하는 것은 코드를 돌리지 않기 위함이다. 그래서 비용을 아끼자는 것이지.
        * 그런데 일부 코드는 verifier입장에서 돌려보지 않고는 판단할 수 없는게 있다.
            * 예를들면 typeInference
        * 아마도. 아마도 아마도. getEval()의 반환값을 ttype으로 해버리고, 모든 getEval()을 getEvalType()으로 변경하면 될 것이다.
        * 그리고 arr도 node 대신 type을 인자로 받도록 수정해야 하고.
        * asImpli(node&) 도 asImpli(type&) 이 되어야 한다. 이게 또 문제다.
            * type은 native의 type이었다. mgd의 타입은 node 였다.
            * 뭐가 문제인지 알겠지? mgd의 타입을 type의 파생클래스로 만들 수 있어야 한다는 점이다.
1. [?] #typeObj를_통한_최적화 ==> **실패...**
    * 위의 요구사항을 제시된, **ttype과 orgObj 매핑** 에 대한 해결책이다.
    * 이 매핑정보는 오직 verification 단계에서만 필요하다는 점을 이용한다. 우리는 이미 --> #with_동작_최적화_가능 에서 결정을 했다. 알고리즘을 요약하면,
    1. preEval에서 임의의 객체 A에 대한 orgObj를 만든다. 완전이든 불완전이든, 초기식 + with까지 expand된다.
        1. 헷갈릴까봐 첨언하면, 초기식과 with는 모든 생성자 앞에 복붙된다. 즉 org가 아닌 객체 B에 접근하는 순간 모든 B객체는 with, 초기식을 eval 한 상태라는 것이다.
            그러니 verification할때도 그렇게 해야지.
        2. verification에서 이 orgObj들을 가지고 검증한다.
        3. verification이 끝나면 모든 orgObj들을 setState(verified)로 변경한다.
            1. 이때 각 orgObj::setState(VERIFIED)가 호출되면 preEval에서 생성된 **초기식, with** 부분을 싹 날리고 시작한다.
            2. 날리는 방법은 해당 객체에서 define한 subs()가 나올때까지, subs().popTop() 하면 된다.
            3. 즉, orgObj는 해당 객체를 만들때 define한 자신의 바로 직계subs 들에 대한 ptr를 따로 들고있어야 한다는 얘기다.
    * [d] verification에서 불완전 orgObj에 접근했는지, 아니면 복제된 객체에 접근했는지 어떻게 구분할까? ==> **해결이 어렵다...**
        * 무슨 소린가.. 싶다면 다음 코드를 볼까?
            ```go
            def A
                age := 0
            def B
                me(n int): age = n
                age := -1
            foo(b B)
                b.age // 1
                B.age // 2
            ```
        * 1과 2를 verification 한다고 해보자. 어떤 AST일까?
            * getExpr(getExpr("b"), "age")
            * getExpr(getExpr("B"), "age")
        * verifier는 속도최적화를 위해서 **타입(즉, str::type) 을 다뤄야 하지, obj 객체를 다뤄서는 안된다**. 그게 내가 지금 하려는 거니까.
        * 그러면 어떻게 되는가? verifier::onVisit(getExpr& e) 가 들어와서 e.getName() 해서, b 혹은 B가 나오겠지.
        * 양쪽 이름을 가지고 scopeStack에 질의하면 binding이 안된 str을 하나 받을 것이고, 거기서 str.getType()을 할 것인데, 양쪽 모두 B가 나오니 문제다.
        * 구분을 하려면 추가 정보가 있어야 한다 ==> 그런데 str에는 추가정보를 넣기가 힘들다 ==> 그러면 orgObj에만 binding을 하라고 할까? ==> 그런데 그럴바에는 그냥 객체를 항상 복제해서 binding하라고 하는게
          코드 유지보수면에서 좋을 수 있다.
        * 왜냐하면 객체생성시의 퍼포먼스는 어짜피 최적화가 매우 들어가야 하는 부분이기 때문에.
        * 자바는 똥컴에서도 75000개 객체를 1초안에 만든다. 그정도는 아니어도 객체 생성때문에 지장이 생겨서는 안된다. 그정도로 최적화가 어짜피 들어가야 한다.
        * 즉 유지보수면에서 이건 안하는게 좋겠다. 그냥 객체 만들자.
> 요약:
>     가능은 할것으로 보인다. 하지만 굉장히 힘들 것이다.
>     기반에 제공해야하는 API는
>         1. mgdType을 node가 아니라 type으로 관리할 수 있도록 mgdType 클래스를 만들기. 그리고 이게 type시스템에 포함되도록, 즉, mgdType.isSub(type) 이 가능하도록 할 것.
>         2. getEval은 node가 아니라 type이 나가도록 할 것.
>         3. type을 넣으면 orgObj가 나오게 할 것.
>         4. orgObj.getType()을 하면 mgdType이 나가게 할 것.
>     등이다.
>     이 기능의 핵심은 객체 생성을 안해서 최적화 하겠다는 것이다.
>     그런데 그렇게 하려면 해결이 어려운 문제가 있다는 걸 알게 되었다.
>     그리고 객체 생성은 어짜피 굉장히 빨라야 한다. 최적화가 강하게 들어가야 한다.
>     그러니 굳이 이렇게까지 유지보수어렵게 최적화를 해야할 부분은 아니다.
* * *
# [o] #with_동작_최적화_가능 ==> **생성자에다가 with구문을 복붙해버린다.**
* why?
    * with의 동작은 가장 무식한 방법으로 하면, 직접 delegation 함수를 일일이 만드는 것이다. 이를테면,
    ```go
    def A
        foo() void: ...
    def B
        with a A
        // foo() void: a.foo() 가 추가된다.
    ```
    * 구현은 비교적 심플해진다. 하지만 이렇게 하면 3가지 문제가 있다.
    1. B타입을 fix하려면 A가 먼저 fix되어야 한다. 강한 의존성문제가 생기는 것이고, 현재까지 의존성문제의 유일한 해결방법은 될때까지 무한루프를 도는 것 뿐이다.
        그러니 초기식Expr을 하는 시점에 with도 같이 해야만 한다.
    2. 코드가 boilterplate 된다.
    3. 실행시 결국은 a.foo()로 redirection 되므로 속도가 떨어진다.
    * 그러니 다른 해결방법을 찾아보자는 것이다. 정 없으면 저렇게 해야지 뭐.
    * 혹, `preEval 단계에서 B의 objScope에 a.foo() 함수를 넣으면 되는게 아니냐` 싶을 지도 모른다.  그렇게 하면 안된다.
        #with를_구현할때_sub의_함수를_그대로_넣으면_안되는_이유
        * with는 모든 객체마다 각기 다른 sub 객체를 redirection 하는 것이기 때문에, 객체가 복제되면 expand되는 sub도 저마다 달라진다.
          무슨 말이냐면 다음 코드를 보자:
          ```go
          def A
               foo() void ...
           def B
               with A() // 이름은 random 이름 \_\_\_random_unamed_variable_def_b_@ 처럼 지어진다.
           b := B()
           b.foo() // b.a.foo()가 된다.
          ```
          이 코드를 보고 with의 동작을 어떻게 하면 더 최적화 할 수 있을까? 생각해보자.
          그러면 객체 b의 subs.add("foo", sub("b").sub("a").sub("foo")) 로 해버리고 싶다는 충동을 느낄 것이다.
          그러나 이렇게 하면 안된다.
          a는 b에 속한 member node다. 즉 b의 복제인 b2가 만들어지면, b2안에 있을 a도 엄연히 새로 복제된 a2여야 한다.
          그리고 a2와 a는 같은 타입의 객체이지만 a2 != a 여야 한다.
          그러니 b2.subs.add("foo", sub("b2").sub("a").sub("foo")) 라고 다시 바인딩을 해줘야 하는 것이지.
          그러니 이러한 최적화는 안되겠다는 걸 알 수 있다. 무식하게 getExpr("foo", getExpr("a", getExpr("b"))) 와 같이 함수를 하나 만드는 게 좋다.
          즉, 함수내에서 with를 쓰면 scope만 하나 더 올리면 된다.
          그러나 def 안에서 with를 쓰면 동작이 완전히 달라지게 된다. scope에 의존할 수 없으므로.
1. [d] with를 생성자 시점에서 expand한다. ==> **별반 차이가 없다. 상속이 끼어들면 머리가 복잡해진다. chain이 깊어지므로 속도가 정말 빠른지도 의문이다.**
    * with를 실행하는 코드를 생성자에 넣는 것이다.
    * parser가 with를 받으면 아마도, withExpr(someExpr) 처럼 되어있을 것이다.
    * 생성자에는 me도 업데이트가 되어있을 테고, withExpr(someExpr)를 그대로 생성자 앞부분에 넣어놓기만 하면 된다.
    * 물론, verification 가기전에 타입은 만들어 둬야 하므로 someExpr이 defAssign 인지, defVar인지는 downcast해서 거기서 타입과 변수명을 꺼내서 sub로 넣어두기는 해야 한다.
    * 장점
        1. 기존의 withExpr을 그대로, 정말로 그대로 사용할 수 있다.
        2. 코드 양이 제일 적어보인다.
    * 단점
        1. 함수안에서 실행하는 withExpr은 block문을 갖는다. 그러니 withExpr을 그대로 쓸 수 없다. withExprForCtor 같은 걸 만들어야 겠지.
        2. 동적인 withExpr의 동작은 어디까지나 scope을 하나 더 올리는 것이다. 즉 정적으로 검사하는 verification 단계에서도 with를 실행해야 한다.
        3. 즉 실행에 있어서는 코드가 작아보이지만, 검증에 있어서는 별반 차이가 없다.
        4. 실행속도가 정말 빠른가? chain이 깊어지기 때문에 탐색에 시간이 더 걸릴지도 모른다.
        5. 게다가 with를 적용한 클래스를 상속하게 되면 어떻게 되는가? orgObj는 with가 적용된 상태인가? ctor을 통과해야만 with가 되는가? 머리가 복잡해진다.
2. [d] 직접 delegation 함수를 하나하나 만든다. ==> **일일이 하나씩 만들기에는 양이 많고, prop같은 경우는 객체가 복제되면 새로 바인딩을 해줘야 한다.**
3. [u] 1안으로 돌아간다. ==> **생성자에서 withExpandOnlyExpr로 chain을 걸어버린다.**
    * [x] 다른 언어들은? ==> **GO는 지원한다.**
        * [x] 코틀린은 어떻게 되나? ==> **해당되지 않는다. interface만 허용하는데 interface는 prop을 만들 수 없다.**
        * GO는 된다.
    1. 똑같이 delegation함수를 쓰면 되게 끔 만들어본다. property에 대한 delegation을 만든다.
        * 이렇게 되려면 어떠한 참조자에 값을 쓰는 행동을 expr을 통해서 일괄적으로 수행하게끔 할 필요가 있다. 생각을 좀 해보자.
        * 일반적인 a int 변수가 객체 안에 있다고 하자. 이 a에게 3을 넣는 과정은 어떻게 되지?
            * assignExpr에서,
            ```cpp
            iter e = _getScopeIterOfLhs(); // e exists. verified.
            str ret = _rhs->as<node>();
            e.setVal(*ret);
            ```
            * iter는 scope의 iter다. 이는 원본 element의 str에 대해 binder::bind(node&) 를 호출한다.
    2. [d] proxyTactic를 만들어본다. ==> **객체를 복제할때마다 모든 property를 찾아서 proxyTactic을 넣어야 하니 좀 어렵겠다.**
        * 겉으로 보면 binder인데, 여기에 대고 bind() 하거나 get()을 하면 어딘가에 있는 다른 binder()로부터 가져오거나 set을 하는 것이다.
        * 이렇게 하면 withExpr에서 proxyTactic으로 값을 넣기만 하면 된다.
        * 문제는,
            1. [x] proxyTactic으로 scope에 add 하는 방법은?
            2. [x] 정의블록문에서 with가 나온 경우 원본 binder를 어떻게 찾아내지? 어떻게 이 동작이 복제객체가 나올때마다 동작하게 할 수 있지?
    3. [u] 생성자에서 with를 동작시켜버린다. ( == chain을 걸어버린다)
        * with를 걸지 않았던 이유는 매번 객체를 만들때마다 하기가 싫어서였으나.
        * 지금은 이 요구사항때문에 어떻게 하더라도 추가비용이 발생할 수 밖에 없게 되었다.
        * 그러면 가장 쉽게 만들 수 있는 방법은 생성자 맨 앞에다가 withExpandOnlyExpr을 넣어두는 것이다.
            * withExpr은 기본적으로 블록문을 받는다. 이건 일종의 다른 버전이다.
        * 주의할 점은 밑에 나오는 with구문이 더 높은 우선권을 갖는다는 것이다. 위에 있는 with구문에 의해서 생성된 delegation 함수나 prop을 덮어버린다.
        * 덮어버릴때 경고로 나가게할 것인지 아닌지 결정해보자.
            * golang은 내보내지 않는다.
            * with한 객체가 with를 소유한 orgObj과 겹치는 부모클래스가 있을때만 경고를 내보내는 것도 괜찮은 것 같다. 왜냐하면 이 경우 매우 많이 겹치게 되니까.
            * 아니면 verbose 모드일때 겹친 sub들을 쭉 출력내는 것도 괜찮다.
        * 장점
            * scope을 바꾸는 것이므로, 객체 생성시에만 변경되면 이후로는 구조의 변화가 없다. 그리고 그 변경이 적은 코드의 양으로 실현된다.
            * 구조가 단순하다. proxyTactic이라느니 이런 것들이 일체 없다. 기존에 있던 chain을 하나 더 거는 것 뿐이다.
            * 함수도, prop도 한번에 해결된다. 어썸.
        * 단점
            * 속도가 느릴 수 있다. 생성자 동작이 느려지는 것이다.
        * withExpandOnlyExpr은 다음처럼 생성되고 verification 되고 동작한다.
            * withExpandOnlyExpr은 expr을 인자로 하나 갖는다.
            * 파싱단계: 다음 중 하나의 패턴으로 사용자가 코딩해놓았을 것이다.
                * with a := Person()
                * with Person()
                * with a
                * with a Person
                1. 파서는 위의 구문을 expr로 만들어서 @preCtor에 expr을 감싸는 withExpandOnlyExpr을 만들어서 넣어둔다.
            * preEval단계
                1. withExpandOnlyExpr을 만나면, 안에 있는 expr이 위의 4가지중 어느 패턴인지 파악한다.
                    * defAssignExpr 일 경우
                        1. 변수명 `a` 와 lhs `Person()` 2개로 분리한다.
                        2. lhs를 eval한 타입과 `a`로 일단 objScope에 빈 `str` 바인더를 만들어 추가해둔다.
                        3. `a = Person()` 에 해당하는 assignExpr를 초기식 배열에 넣어둔다.
                        4. `withExpandOnlyExpr(getExpr(a))` expr을 초기식배열에 넣어둔다.
                    * runExpr의 경우
                        * Person()은 객체를 만드는 별도의 expr 같아 보이지만 실체는 그냥 함수를 호출한 것에 불과하다.
                        * 그러니 함수를 호출한 케이스와 동일하게 취급한다.
                        1. 초기식 배열에 `withExpandOnlyExpr(runExpr(getExpr("Person"), {}))` 을 넣어둔다.
                    * getExpr()의 경우
                        1. 초기식 배열에 `withExpandOnlyExpr(getExpr("a"))` 를 넣어둔다.
                    * defVarExpr의 경우
                        1. 변수명 `a` 와 lhs `Person` 2개로 분리한다.
                        2. lhs를 eval한 타입과 `a`로 일단 objScope에 빈 str 바인더를 만들어 추가해둔다.
                        3. `a = Person()`에 해당하는 assignExpr를 초기식 배열에 추가한다.
                        4. `withExpandOnlyExpr(getExpr(a))` expr을 만들어 초기식 배열에 추가한다.
                2. 초기식 배열은 이 withExpandOnlyExpr을 가진 orgObj가 모든 preEval이 끝나면 그 orgObj의 모든 생성자 앞에 복붙 될 것이다.
            * 실행단계: 생략
> 요약:
>  func같은 경우는 한번 만들어지면 객체간에 공유되고, 다른 함수로 assign도 안되므로 정적이다.
>  이 경우는 일일이 delegation func을 orgObj에 만드는 것이 권장된다. 그렇게 하면 복제객체를 만들어버리면 더이상 추가 작업이 필요없으니까.
>  문제는 prop에 대한 delegation이다. prop은 객체가 복제될때마다 얘네도 복제된다. 즉 동적이다. 종래의 delegation func 과 성격이 맞지 않는다.
>  그러므로 어쩔 수 없이 생성자마다 뭔가의 작업을 해줘야만 한다.
>  그리고 어짜피 작업을 해줘야 한다면, withExpr일 때가 가장 재사용성도 높고 코드의 양도 적으면서 prop, func 한번에 해결이 가능하다.
>  다음 알고리즘처럼 동작하자.
>
    * withExpandOnlyExpr은 expr을 인자로 하나 갖는다.
    * 파싱단계: 다음 중 하나의 패턴으로 사용자가 코딩해놓았을 것이다.
        * with a := Person()
        * with Person()
        * with a
        * with a Person
        1. 파서는 위의 구문을 expr로 만들어서 @preCtor에 expr을 감싸는 withExpandOnlyExpr을 만들어서 넣어둔다.
>
    * preEval단계
        1. withExpandOnlyExpr을 만나면, 안에 있는 expr이 위의 4가지중 어느 패턴인지 파악한다.
            * defAssignExpr 일 경우
                1. 변수명 `a` 와 lhs `Person()` 2개로 분리한다.
                2. lhs를 eval한 타입과 `a`로 일단 objScope에 빈 `str` 바인더를 만들어 추가해둔다.
                3. `a = Person()` 에 해당하는 assignExpr를 초기식 배열에 넣어둔다.
                4. `withExpandOnlyExpr(getExpr(a))` expr을 초기식배열에 넣어둔다.
            * runExpr의 경우
                * Person()은 객체를 만드는 별도의 expr 같아 보이지만 실체는 그냥 함수를 호출한 것에 불과하다.
                * 그러니 함수를 호출한 케이스와 동일하게 취급한다.
                1. 초기식 배열에 `withExpandOnlyExpr(runExpr(getExpr("Person"), {}))` 을 넣어둔다.
            * getExpr()의 경우
                1. 초기식 배열에 `withExpandOnlyExpr(getExpr("a"))` 를 넣어둔다.
            * defVarExpr의 경우
                1. 변수명 `a` 와 lhs `Person` 2개로 분리한다.
                2. lhs를 eval한 타입과 `a`로 일단 objScope에 빈 str 바인더를 만들어 추가해둔다.
                3. `a = Person()`에 해당하는 assignExpr를 초기식 배열에 추가한다.
                4. `withexpandonlyexpr(getexpr(a))` expr을 만들어 초기식 배열에 추가한다.
        2. 초기식 배열은 이 withexpandonlyexpr을 가진 orgobj가 모든 preeval이 끝나면 그 orgobj의 모든 생성자 앞에 복붙 될 것이다.
>      3. verification에 들어가기 전에 orgobj가 어떠한 함수나 prop을 expand했는가를 확정지어야 한다.
>      5. preeval단계에서 초기식을 무한루프를 돌면서 확정짓는 동안에 이 withexpandonlyexpr이 가진 expr도 eval을 할 수 있는지 체크해야 한다.
>      6. eval이 가능한 순간 eval로부터 객체를 가져와서 withexpand 해버린다.
>
>  * verification 단계
>      1. withexpand, 상속, 초기식의 타입까지 다 구현이 된 상태로 검증에 들어간다.
>      2. 검증이 끝나면 pack.org객체_리스트[] 순회하면서 setstate(verified)로 변경한다.
>          1. orgobj는 verified가 들어오면 검증을 위해서 넣어두었던 불완전한 데이터를 버리고 초기화단계에서 생성자가 호출될 거란 믿음을 가지고 준비를 해야한다.
>          2. 그러니 orgobj는 자신의 subs()를 날리기 시작하는데 subs().top()이 orgobj 자신의 container가 아닐때까지 pop()을 계속 한다.
>          3. 정상적이라면 withexpand를 하기 전 상태로 돌아가 있을 것이다.
>          4. 이후 실행단계에서 생성자가 withexpand를 하면서 정상적으로 초기화된다.
>
>  * 실행 단계
>      1. 객체가 먼저 복제된다.
>      2. 생성자가 호출된다.
>      3. 초기식과 더불어 withexpandonlyexpr이 실행된다.
>      4. withexpandonlyexpr::run(expr)은 다음처럼 실행된다.
>          1. expr로부터 node를 가져온다.
>          2. node.subs()를 scopes(== chain)라고 한다.
>          3. scopes.link(me.subs()) 한다. 이제 scopes.subs() --> me.subs() 로 연결이 된 상태다.
>          4. me.subs() (== me.\_subs)를 scopes로 교체한다.
>              1. 이 교체하는 함수는 private여야 할 것이고, withexpandonlyexpr은 friend 가 되어야 할 것이다.
* * *
# [o] 의존성 해결 선형 알고리즘 ==> **kotlin처럼 의존성 문제를 해결한다. 알고리즘이 아니라 동적으로 돌려서 해결하는 것이다.**

* Why?
    * 의존성 문제란 특정 심볼 A가 있을 때, A자신 혹은 A가 가진 하위 sub들이 심볼B에 의존하는 것을 말한다.
        * 다음 예제를 보자.
        ```go
        def A
            b B?
        def B
            c := globalGetC(0) // 강한의존. 반환타입=C?
            koo() A?: null // 약한 의존.
            foo(d D?) void // 약한 의존.
                d?.boo() // 약한 의존.
        globalGetC(n int) // 반환타입=C?
            if n == 0
                C()
            else
                null
        def C
            foo() void: ...
        def D
            boo() void: ...
        ```
        * 의존성에는 약한 의존과 강한 의존이 있다.
        * 강한 의존은 의존하는 타입이 fix되어야 내 타입이 fix되는 것으로 AST후보군을 일단 생성하는데 있어서 종속적이다. 즉, 이 의존성이 해결되어야 preEval단계가 종료된다. 그리고 verification으로 들어갈 수 있다.
        * 약한 의존은 verification에서 검증하면 되는 의존성 문제다.
    * 의존성 여부를 미리 알아두는 것은 여러모로 이득이 된다.
        1. preEval, verification 단계에서 어짜피 순회를 통해서 의존성 관계를 수집한다.
        2. CREPL에서도 이 의존성 관계를 알고 있어야 부분 compile이 가능해진다.
        3. 현재는 무한루프를 통해서 의존성 문제가 발견되지 않을때까지 계속 돌리는 알고리즘이다. 의존성관계 정보를 수집하지 않는다.
            그러니 실패할지를 모르기 때문에 계속 try를 하는 방법이므로, 느리다.
        4. 에러가 발생한 경우, 어떠한 의존관계가 있어서 문제가 된건지 그래프로 표현할 수 있다.
    * 고로, 이 부분을 해결해두면 속도나 C-REPL문제를 해결할때도 상당히 도움이 될 것이다.
    * 추가 요구사항
        1. 의존성 정보를 수집하는 문법에는 뭐가 있나? ==> **origin obj의 defAssign, defVar, funcParam, funcReturn, withExpr, inheritance. 일단 강한의존 6개. 나머지는 약한 의존**
            * 강한 의존은 type이 fix되지 못하는 것들을 말하기 때문에 sub variable로 있는 것 들은 모두 강한 의존이다.
            * 상속도 강한 의존이다.
            * def 객체에 바로 with를 사용하는 경우 강한 의존이다.
            * 초기식에 다른 객체/함수를 참조한 경우, 이는 강한 의존이다. ==> **해당 함수의 반환형이 어떤 타입의 변수를 정의한 것인지에 대한 영향을 주므로**
            * 함수의 반환값 혹은 파라메터는 약한 의존이다. (중첩함수 포함)
            * 함수 내부의 로컬 변수 정의, 함수호출, 객체생성 등은 약한 의존이다.
        2. 항상 의존성 관계를 수집해야 하는 것은 아니다. 편집이 끝나고 최적화도 끝난, 돌리기만 하는 코드라면 이게 필요 없다. ==>
            * **최적화 코드는 interpreter를 통해 비가역AST로 돌린다. 별도 항목으로 선 논의함**
            * 최적화와 비최적화 모두 interpreter를 통하지만 최적화는 parser도, verifier도(onVisit(manifest)제외) preEval도 통하지 않는다.
            * 그러니 저 3개 중에 하나를 택해서 의존성 정보를 파악해서 넣으면 좋다.
* [x] 의존성 정보는 일반적으로 각 어떤 class로 저장되어야 할까?, 어디서 만들까? 어디에 저장할까? ==> **preEval단계에 interpreter에 저장된 depSolver객체를 preEval로 보낸다.**
    * 쉽게 생각하면 *누가*, *누구를* 2개의 정보만 담고 있으면 될 것 이다.
    * 이왕이면 node 자체를 가리키면 좋을 것이다. 그러니,
        ```cpp
        struct dependency {
            // to가 fix되어야 from도 fix될 수 있다.
            str from;
            str to;
        };
        ```
    * 요구사항고찰
        1. 검색이 쉬워야 좋을 것이다.
        2. 실행 시에는 필요가 없다. 즉 최적화 시에는 필요가 없다.
        3. 위 요구사항을 고찰해보면 node::getDependents() 같은 함수를 node에 두면 안된다는 것이다. 항상 필요한 게 아니므로.
        4. preEval은 preEval 동작을 위해서 어쩔 수 없이 의존성 여부를 검사한다.
        5. verifier는 의존성 정보를 통해 올바른 함수나 검사한다. 의존성 정보를 만드는 곳이 아니다.
        6. pack 간의 의존성 여부는 2개로 구분된다.
            1. pack간의 순환참조가 있는가? ==> **실행시 문제가 되는 것은 아니다. pack을 만드는 시점에서 결함을 찾아내야했어야지. 그러니 이때는 이건 무시한다.**
            2. pack 참조하는 특정버전의 pack이 시스템에 설치되어 있는가? ==> **이건 여태 의존성과는 다른 종류/알고리즘 으로 검출해야 하는 것이다. 그러니 역시 무시한다.**
            * 따라서 pack간의 의존성은 deps 클래스를 통해서 검출하거나 veriifer를 통해서 할 필요는 없다는 걸 알 수 있다.
            * interpreter가 manifest를 load할때 시스템에 특정 버전의 pack이 설치 되었는지를 verification하면 된다.
        7. [d] depSolver 클래스를 만든다. ==> **밑에 나오지만, 이 방법은 잘못된 방법이었다.**
            * dependency 전반을 담당한다.
            * dependency 정보를 기록한다.
            * 의존성 정보는 map<str, narr> 가 된다. 중요한 점은 key인 str이다. 이 str은 unique obj만 가리키는 것으로 간주한다. node 간의 onSame() 을 잘 구현해 놓아야 겠지?
            * get()/operator[]\(node&\)  호출하면 narr&로 참조하는 node들이 쭉 나온다.
            * struct elem
                * str parent; // map의 key와 같다.
                * narr to;
            * elem에 대해 map API를 제공한다. get(), iterator(), remove() 다 된다.
            * setErrReport() 와 getErrReport() 2개 모두 제공한다.
            * 2가지 함수를 제공한다.
                1. 모든 Tree를 순회해서 적절한 load sequence를 narr로 반환한다.
                    * **narr solveLoadSeq() const** // size 0이면 에러
                        * 여기서의 map은 양방향 Tree를 만드는 것이다.
                    * 강한 의존만 고려한다.
                1. 하나의 node의 데이터를 변경했을 때 이것에 영향을 받는 node들을 의존 관계에 역방향으로 narr에 담아 반환한다.
                    * **narr solveDepSeq(narr changed)**
                    * 예를들어 A --> B --> C --> D,       A --> E --> C    2개가 있다고 하자.
                    * 여기서 C, D를 변경한 경우, {B, A, E} 이렇게 3개가 이런 순서로 담겨져서 나온다.
                    * 외부에서 B부터 다시 verification하고나서 C를 하라는 뜻이다.
                    * 약한/강한 의존 모두 고려한다.
                    * 탐색 할때 순환 참조가 나와도 에러는 아니다. 이미 반환할 narr에 들어가 있는 경우 그냥 ignore 하고 다음 node로 넘어가면 된다.
        1. 의존성 정보는 interpreter가 갖는다.
        2. packScope를 만들때 시스템의 모든 pack이 들어가도록 하면 안된다. manifest에서 명시한 버전의 특정 pack만 넣도록 해야 한다.
            그리고 이렇게 함으로써 올바른 버전의 pack의 API를 호출했 는지를 verifier가 확인할 수 있게 된다.
* [x] 어디서 의존성 정보를 만들까? ==> **나중에 나오는데, 의존성 정보를 만들어서는 안된다. 알고리즘적으로 의존성 문제를 해결 할 수 없다.**
    1. [d] parser ==> **eval을 돌려야 하므로 안된다.**
        * 가능하기만 하면 가장 좋은 장소다.
        * 게다가 loweventer는 on....() 함수들은 이런걸 처리하기가 딱 좋다.
        * 문제는 parser할 당시에 A --> B 라고 하자. 이걸 알았어도 B가 아직 없을 수 있다는 점이다.
        1. [d] 그러면 B를 만들어 둔다. ==> **어디에 만들어야 하는지 모른다.**
            * 중첩객체인지, pack에 있는 객체인지, 외부 모듈인지 알 도리가 없다.
        2. [d] `A --> B` 라고 기록만 한다. parsing이 끝나고 적절한 str로 채운다. ==> **적절한 str을 가져오려면 역시 scope에서 가져와야 겠지? 그러면 eval을 돌려야 한다는 뜻이다.**
    2. [u] preEval == **소거법으로 여기밖에 없다.**
    3. [d] verifier ==> **안된다.**
* [x] 상속한 경우 의존성 판단은 어떻게 되는가? ==> **동적의 성격을 갖는다. 즉 돌려봐야 안다.**
    * 문제 이해를 위해 다음 코드를 보자.
        ```go
        // 예1
        def A
            d := getD()?.aOfC // A'
        def B A
        def C
            a A := B()
        def D
            aOfC := C().a // A
        getD() D?: D()
        getD2() D?: null

        // 예2
        def A C
            c C := B()
        def B C
            c C := foo(E.val)
            d D // d := D() 와 같은 것이다. 따라서 preEval 단계에서는 str<D> 로만 채워놓으면 된다.
        def C
            boo() E: ...
        def E
            val := 0
            c := if val == 0 // C?
                null
            else
                C()
        foo(n int): E
        ```
        * [x] A, B와 C의 관계는 어떻게 되는가? 이때의 의존성 정보는 어떻게 저장되는 거지?
            * 예제1
                * 수집단계
                    * A --> A (약)
                    * A --> D (강)
                    * B --> A (강)
                    * C --> A (약)
                    * C --> B (강)
                    * D --> A (약)
                    * D --> C (강)
                * 해결단계
                    1. 강의존 해결: D A B C (OK) ==> **마지막 줄 D --> C 때문에 순환참조라는 걸 알 수 있다.**
                        1. A(from) --> D(to) 가 있을 경우, D A 순으로 저장해야함.
                        2. 그러니 기존 원소목록에서 D를 찾고 그 뒤에 A가 이미 있는지 찾기.
                        3. 없을 경우 D 바로 뒤에 A insert 넣기
                        4. 있는데 뒤가 아니라 앞에 있다면 순환참조 에러!
                        5. 참고로 이 기존 원소목록은 추가가 잦기 때문에 linkedlist가 적당하다.
                        6. 참고로 A --> A (강) 처럼 자기자신인데 강이면 무조건 에러. 순환참조임.
                        7. 해결된 의존은 제거.
                    2. 약의존 채워넣기
                        1. A --> A (약) 처럼 자기자신인데 (약) 이면 무시.
                * 검증단계 OK
                * preExecution 단계
        * [*] 하지만 위의 알고리즘은 결정적으로 d := getD() 부분에서 한계점이 있다는 걸 알 수 있다.
            * getD()는 D? 인데 안에서 null만 항상 나가도록 구현한 경우, 순환참조는 발생하지 않는다.
            * 즉 타입만으로 순환참조인지 알 수 있는 방법은 없으며, 실제로 돌려봐야 한 다는 것이다.
        * [*] 요약하면, 알고리즘적으로 의존성을 풀 방법은 애초에 존재하지 않는다. 돌려봐야 안다.
* 그럼 어떻게 하는가?
* 이 사실을 limitation으로 인정하고 kotlin 과 같은 방법으로 해결한다.
    1. 초기식은 생성자에서 호출되는 것과 같은 것이다. ==> **prototype 성격이 옅어진다고 아쉬워할지도 모르지만 사용자 입장에서는 이렇게 하는게 더 직관적일 수 있다.**
    2. 매번 객체가 만들어질때 초기식이 수행되고 나서 생성자가 불려진다.
    3. 단점은, 순환참조 에러가 런타임에 발생한다는 것이다.
    4. 또 하나는
* 사용성 입장에서 본다면 코드 돌리기전에  초기식이 내포하게될 순환참조 에러를 알려주는 게 좋다고 생각할 것이다.
* 문제는 뭐냐면 이런 종류의 에러는 정적에러가 아니다. 돌려봐야 안다. 그러니 엄밀하게 말하면 일단 돌려보고 Exception이 나가는게 맞다.
* 하지만 또 다른 문제는 뭐냐면, 완전객체는 자동으로 생성되므로, **어떤 객체부터 생성해야 하는가** 를 계산하기 전까지는 알 수 없다는 것이다.
* [u] 코틀린 처럼 해결 가능한 방법이 있다.
    * 실행 단계에 들어선 후, origin 객체에 최초로 접근한 순간 해당 origin 객체가 완전객체일 경우 초기화&생성자를 돌리는 것이다.
    * 보다 범용적으로 하려면 완전객체에 대해 subs()를 호출한 순간에, 자기자신이 아직 초기화가 안되어있다면 생성자를 돌리는 것이다.
    * [x] verification단계에서는 origin객체에 대해 subs()를 호출해도 초기화를 하면 안된다. 실행단계에서 호출했을때만 동작해야 한다. 어떻게 할까? ==> **orgObj::getState()를 사용한다.**
        1. interpreter는 verifier, parsing으로부터 결국은 최상위 pack 객체를 주고 받는다.
        2. pack객체에는 포함하는 모든 origin 객체들을 배열로 담아두게 한다. 중첩 객체들들도.
        3. orgObj는 obj에서 상속한다.
            1. orgObj는 \_state enum 값이 추가된다. 그리고 rel(), init(), getState(), verified() 4가지 함수도 추가된다.
                1. RELEASED ==> subs()시 아무런 동작도 하지 않는다.
                2. PARSED ==>  위와 동일.
                3. VERIFIED ==> subs()가 호출되면 org의 생성자를 호출한다. 모든 orgObj는 생성자를 호출하기위한 tstr\<callExpr\>를 가지고 있다.
                4. LINKED ==> 최종 준비상태. subs() 들어가도 더이상 호출되지 않는다.
        4. pack또한 orgObj에서 상속받는다.
            1. autoslot --> autopack으로 이름 변경한다.
            2. autopack은 자체의 state 대신에 orgObj의 state로 리팩토링한다.
        5. orgObj는 이제 완전객체 초기식코드를 tstr\<callExpr\> 타입으로 1개 갖는다.
        6. parsing 단계
            1. 초기식은 전부 별도의 @preCtor 에 넣어둔다.
            2. 생성한 originObj도 pack.orgObj\[\]에 담아둔다. 이때 \_state는 VERIFYING으로 parser가 만들어줬을 것이다.
            3. 생성자 코드는 정상적으로 파싱한다.
            4. 완전객체를 만들기 위한 초기식코드를 파싱해서 originObj에 넣어둔다.
        7. preEval 단계
            1. pack.origin\[\] 순회하면서 각 객체에 대해,
                1. @preCtor의 모든 코드를 루프를 돈다:
                    1. 코드로부터 eval한 타입, 변수명과, 초기화식을 각각 분리한다.
                    2. eval타입을 변수명과 str의 \_type을 eval한 타입으로 넣어둔다.
                    3. 초기화식을 별도의 배열에 모아둔다.
                    4. 코드를 eval 하는 과정에서 실패할 수 있다. 의존성 문제는 돌려봐야만 풀수 있기 때문에 이 경우에는 일단 break를 한 뒤에 다른 객체들의 @preCtor 코드를 eval한 후, 이 코드를 다시 try해봐야 한다.
                2. @preCtor 루프가 끝나면 초기화식배열을 이 객체의 모든 생성자의 앞부분에 복붙해둔다.
                3. @preCtor 제거한다.
                4. 해당 객체의 verified()를 호출한다. 상태가 VERIFIED로 이전된다. 이제 subs()를 호출하는 순간 orgObj::onInit()이 불려진다.
                5. 이 과정을 pack.orgin\[\]의 모든 객체들이 전부 @preCtor이 사라질때까지 무한히 반복한다. 단 루프를 1회 돌았는데 @preCtor을 가진 객체들의 size 값이 루프 돌리기전과 동일한 경우는 순환참조 에러다.
        8. execute 단계
            1. 이제 메인코드를 돌다가 orgObj::subs()를 호출한 순간 함수 안에서, `LINKED` 인가를 따져서 아닐 경우 초기식 코드를 돌릴 것이다.
* [*] 즉 verification에서는 사실 타입으로만 저장되어있고, 해당 타입이 제공하는 sub가 무엇이 있느냐만 알면 된다는 걸 알 수 있다.
> 요약:
> 0. 의존성 문제는 동적이다. 돌려봐야 한다. 그러니 알고리즘적으로 해결이 불가능하다.
> 1. 그러나 돌리는 과정의 알고리즘을 다음과 같이 좀 더 최적화 한다.
> 2. interpreter는 verifier, parsing으로부터 결국은 최상위 pack 객체를 주고 받는다.
> 3. pack객체에는 포함하는 모든 origin 객체들을 배열로 담아두게 한다. 중첩 객체들들도.
> 4. orgObj는 obj에서 상속한다.
>     1. orgObj는 \_state enum 값이 추가된다. 그리고 rel(), init(), getState(), verified() 4가지 함수도 추가된다.
>         1. RELEASED ==> subs()시 아무런 동작도 하지 않는다.
>         2. PARSED ==>  위와 동일.
>         3. VERIFIED ==> subs()가 호출되면 org의 생성자를 호출한다. 모든 orgObj는 생성자를 호출하기위한 tstr\<callExpr\>를 가지고 있다.
>         4. LINKED ==> 최종 준비상태. subs() 들어가도 더이상 호출되지 않는다.
> 5. pack또한 orgObj에서 상속받는다.
>     1. autoslot --> autopack으로 이름 변경한다.
>     2. autopack은 자체의 state 대신에 orgObj의 state로 리팩토링한다.
> 6. orgObj는 이제 완전객체 초기식코드를 tstr\<callExpr\> 타입으로 1개 갖는다.
> 7. parsing 단계
>     1. 초기식은 전부 별도의 @preCtor 에 넣어둔다.
>     2. with구문도 @preCtor에 넣어둔다. withExpr안에는 defAssignExpr이나 defVar가 들어있을 것이다.
>     3. 생성한 originObj도 pack.orgObj\[\]에 담아둔다. 이때 \_state는 VERIFYING으로 parser가 만들어줬을 것이다.
>     4. 생성자 코드는 정상적으로 파싱한다.
>     5. 완전객체를 만들기 위한 초기식코드를 파싱해서 originObj에 넣어둔다.
> 8. preEval 단계
>     1. pack.origin\[\] 순회하면서 각 객체에 대해,
>         1. @preCtor의 모든 코드를 루프를 돈다:
>             1. 코드로부터 eval한 타입, 변수명과, 초기화식을 각각 분리한다.
>             2. eval타입을 변수명과 str의 \_type을 eval한 타입으로 넣어둔다.
>             3. 초기화식을 별도의 배열에 모아둔다.
>             4. 코드를 eval 하는 과정에서 실패할 수 있다. 의존성 문제는 돌려봐야만 풀수 있기 때문에 이 경우에는 일단 break를 한 뒤에 다른 객체들의 @preCtor 코드를 eval한 후, 이 코드를 다시 try해봐야 한다.
>                 주의할 점은, 다른 객체들로 가야한다는 것이다. 이 객체의 다음 코드로 루프를 돌면 안된다. 초기화식과 with식의 순서는 매우 중요하다. 앞서 초기화한 값으로 다음 초기화구문을 초기화하는 코드도 있을 수 있기에.
>             5. 코드가 with인 경우,
>                 1. with가 만들게될 타입을 찾는다.
>                 2. 해당 타입의 orgObj이 PRE_EVALUATED상태인지 체크한다.
>                 3. 아니라면 이 withExpr은 그대로 preCtor에 남기고 패스한다.
>                 4. 맞다면, with가 감싸는 정의문Expr을 eval을 해봐야한다.
>                 5. 잘 되면, 해당 withExpandOnlyExpr은 성공했다고 마킹하고 어딘가에 저장한다. 저장할때, 반드시 코드에 명시된 순서를 지켜야 한다. 위에 있으면 먼저 with expand되어야한다.
>                     그리고 @preCtor에서 제거한다.  절대로 이 시점에서 scope.add를 해버리면 안된다. --> #with를_구현할때_sub의_함수를_그대로_넣으면_안되는_이유
>                 6. 상황에 따라 경고나 에러를 내보낸다.
>         2. @preCtor 루프가 끝나면, @preCtor의 모든 코드를 제거했는지 체크한다.
>         3. 남아있다면 continue한다. 다음객체를 읽는 것이다.
>         4. 모두 제거했다면 이 객체는 볼일 다봤다. 정리를 해주자.
>             1. 앞서서 마킹해두었던 이 객체의 withExpandOnlyExpr들을 전부 pop해서 실행시켜준다. 그리고 순차적으로 위에서 아래로 with expand 한다.
>                  주의할 점은, objScope이 가장 위에 오고, 밑으로 withExpandOnlyExpr들이 와야한다는 점이다.
>                  objScope에 직접 명시한 함수들은 conflict을 제거하기 위한 것이기 때문에 verifier단계에서는 with들보다 먼저 탐색되어야 한다.
>             2. 초기화식배열을 이 객체의 모든 생성자의 앞부분에 복붙해둔다.
>             3. @preCtor 제거한다.
>             4. 해당 객체의 verified()를 호출한다. 상태가 VERIFIED로 이전된다. 이제 subs()를 호출하는 순간 orgObj::onInit()이 불려진다.
>         5. 이 과정을 pack.orgin\[\]의 모든 객체들이 전부 @preCtor이 사라질때까지 무한히 반복한다. 단 루프를 1회 돌았는데 @preCtor을 가진 객체들의 size 값이 루프 돌리기전과 동일한 경우는 순환참조 에러다.
> 9. execute 단계
>     1. 이제 메인코드를 돌다가 orgObj::subs()를 호출한 순간 함수 안에서, `LINKED` 인가를 따져서 아닐 경우 초기식 코드를 돌릴 것이다.
* * *
# [o] tcppBridgeObj는 obj 상속해선 안된다. ==> **필요없는 기능, LSP위반 등등 때문에 상속관계를 없애자.**
* obj는 \_share, \_own 등이 있고 run()이 구현되어있고 등등 있다.
* tcppBridgeObj는 run()은 필요하지만 \_share, \_own은 필요없어서 \_sub를 직접 만들고 있다.
* 그러다보니 단적으로 말해서 LSP가 위반하는데, 예를들어 obj::subs()는 obj에 있는 \_subs를 반환하지만 tcppBridgeObj::subs()는 tcppBridgeObj의 \_subs를 내보낸다. 이 과정에서 chain같은 것도 없다.
* 누가봐도 급하게 변경하다보니 상속을 한걸로 보인다. 뒤에 나오는 생성자호출과 @new문제 해결을 위해서도 상속관계를 해제하고 중복을 없애야 한다.
* * *
# [o] 생성자 호출과 객체생성을 분리하는 방법은 무엇인가? ==> **baseObj::run()은 객체생성후 생성자호출, func(CTOR_NAME)::run(args)는 생성자만 호출**
* why?
    * 지금까지는 `생성자호출 == 객체 생성` 이었다.
    * 그러나 `orgObj 생성`등 다른 문제해결을 하다보니 생성자 호출과 객체 생성은 앞으로 별개로 취급해야 한다.
    * 문제는 코드상으로 보면 `foo()` 처럼되어 있는데 foo가 객체인지 함수명인지 파싱단계에서는 알 수가 없다는 점이다.
    * 지금까지는 파싱단계에서 AST를 거의 완성해놓는 것을 목표로 하고 있기 때문에, 이걸 preEval에서 판단하려고 하면 추가적인 부하가 걸린다.
    * 어떻게 하면 파싱단계에서 이문제를 해결할 수 있을까?
    * [x] Parser가 이 객체를 만들텐데, parsing 당시에는 `A()` 만 보일뿐인데 이게 함수인지 ctor인지 알수가 있나? ==> **없다**
        * parsing할때는 runExpr(currentFrame, getExpr("_A_"), args("")) 으로 일단 넣어두는 것이다.
        * A는 runExpr이 파싱되고 나서 뒤에 나올지도 모른다.
        * 그러니 verifier 단계에서 runExpr라는 걸 알 수 있게 된다.
* [d] 1안: runExpr.isForCtorOnly 를 추가한다. runExpr.run()을 할때 생성자를 호출하려고 하면 안에서 obj생성하지 않는다.
    * 즉, `생성자 호출과 일반함수 호출은 구분이 필요하다` 라는 입장이며, 이 구분을 `실행단계`에서 하겠다는 것이다.
    * 흉측하다.
    * 매실행시마다 판단해야 한다. 모든 함수호출에 대해 부하가 걸린다.
    * 하지만 verifier단계에서 AST를 변경할 필요는 없다.
* [d] 2안: verifier단계에서 runExpr를 보고, ctor을 가리키고 있는 거라면 runCtorExpr()로 교체한다.
    * 즉, `생성자 호출과 일반함수 호출은 구분이 필요하다` 라는 입장이며, 이 구분을 `검증단계`에서 하겠다는 것이다.
    * [x] verifier단계에서 visiting 하는 obj를 변경하는게 가능한가? ==> **안된다면 runExpr.isForCtorOnly를 만들면 된다.**
* 추가 요구사항고찰
    1. AST 변경을 도중에 하지 않았으면 좋겠다.
    2. 동적으로 해결하지 않았으면 좋겠다.
* [u] 3안: mgdCtor 클래스는 생성자코드만 실행하는 방법을 run()으로 제공한다. ==> **객체::run()은 객체생성,생성자호출을,  CTOR_NAME::run()은 생성자호출만 담당**
    * 생성자만 실행하는 것은 정상적인 상황이 아니다.
    * 객체를 복제하고 생성자도 실행하는 것은 일반적인 상황이다.
    * 파서는 생성자는 미리 정해진 `@ctor` 같은 이름을 붙여서 orgObj에 넣어둔다. 이를 응용해서 구분한다.
    1. [d] `@ctor` 와 `@new` 함수 2개를 각각 만든다.
    2. [d] `@new`라고 인자와 함게 호출하면 obj은 `@ctor`이름으로 인자를 받을 수 있는 함수가 있는지 체크한다. ==> **subs()로 보면 `@new` 라는 함수는 없다. **
    3. [d] 모든 obj는 `@new` 라는 유일한 함수를 하나 갖는다. 2안과 유사하다. 다만 체크하는 주체가 함수인 것이다.
        * @new.canRun()을 하면 `me`에서 `@ctor`을 찾아서 인자를 넣어도 되는지 여부를 반환한다.
        * [d] 문제는 canRun()은 stackFrame에 영향을 주지않기 때문에 `me`가 주어지지 않는다. 어떻게 me 정보를 알 수 있지? ==> **args를 통해 자연스럽게 알게되었다.**
            1. [d] 외부에서 @new에 맨 앞 인자는 `obj`라고 한다.
                * 이렇게 되면 @new를 호출할때 obj를 채워줄 것이다.그리고 뒤에는 생성자에 넣을 인자를 쭉 넣고.
                * 이제 @new는 안쪽에서 args의 맨앞에 있는 obj를 꺼내서 obj.canRun(args2)를 해주면 된다.
                * 하지만 이렇게 하면 주어진 args를 다시 반으로 나눠야 한다. 나눠서 canRun()을 호출하기전에는 @ctor.run(arg2)을 해도 되는지 모르기 때문에 반드시 args를 args[0]과 args[..]으로 나눠봐야 한다.
                * @new를 하게 되면 무조건 속도가 부하가 걸리는 셈이다.
            2. [d] sub()를 호출하면 @new일때만 맨 앞에 this를 넣어둔다.
                * 이 방법도 결국 1과 마찬가지로 @new로 전달할때 주어진 args 맨앞에 this를 넣은 새로운 args를 생성해서 보내야 한다. 계속 args객체를 만들어야 하는 셈.
    4. [u] obj::canRun()은 내부에서 CTOR_NAME::canRun()으로 redirection 된다. ==> **obj::run()은 객체 생성후 생성자호출, CTOR_NAME::run()은 생성자만 호출**
        * 아이디어 핵심
            * **객체에 run(args)을 하면 복제객체 생성후 생성자가 호출된다.**
            * **반면 객체.sub(CTOR_NAME, args).run(args) 처럼 생성자를 추출해서 호출한 경우는 생성자만 호출된다.**
            * baseObj::run()은 getOrigin().clone()을 사용해서 객체를 생성하고 run(CTOR_NAME, args)해서 생성자를 호출한다.
                * 지금은 tcppBridgeObj는 obj에서 상속받은 상태이지만, 위의 별도 항목으로 있듯이 나중에는 상속이 아니게 될 것이다.
        * 알고리즘
            1. verifier가 obj->canRun(args)를 호출한다.
            2. obj::canRun(args) 안에서는 기존 대로 sub(CTOR_NAME, args)로 찾는다. @new가 아니라 @ctor만 찾는 셈.
            3. verifier가 통과된다.
            4. 실행단계에서 baseObj.run(args)가 불린다.
            5. baseObj::run(args)에서 getOrigin().clone()으로 복제객체를 생성하고, 복제객체.run(CTOR_NAME, args)를 호출한다.
                1. getOrigin() 함수 때문에 가장 구체클래스로부터 clone()이 가능하게 된다. bridgeCpp일 수도 있고, Int일 수도 있고, obj일 수도 있고, genericOBj일 수도 있다.
            6. 생성자는 이제 객체를 복제하는 게 아니라, `me`를 가져와서 초기화를 하는 것에 불과하다.
4. [x] 3에서 응용해서, msg처리를 상위 객체로 위임한다. ==> **흥미로운 아이디어지만 적용은 어렵다.**
    * A객체 안에 B함수()가 있다고 하자.
    * 이때 B함수를 호출하려면 `A.B()` 처럼 해야 한다.
    * 만약 B의 msg 처리를 A에게 위임할 수 있다면 어떻게 되는가?
    * `A()` 가 가능하게 된다.
    * 그리고 이 아이디어는 with도 한번에 구현이 가능하다. 하나의 수정으로 with와 이 문제를 모두 해결하는 것이다.
    * [x] 그러나 아쉽게도 현재 구조에서 적용이 힘들다.
        * node.run() 하게 되면 결국 sub(조건)으로 node를 찾아서 거기다대고 run() 하게 된다.
        * 문제는 이 `sub`인데, 코드를 보면 subs() 에서 순회를 하면서 sub를 찾는 코드다.
        * 즉 subs() 안에 위임을 한 sub객체의 msg가 들어있어야 하는데 subs()는 container를 반환하기 때문에 container에 뭔가 반영이 되어있어야 한다.
        * 물론 sub()를 호출당하면 subs()를 부르지 않고 미리 msg를 위임한 객체에서 먼저 찾도록 할 수도 있겠지. 하지만 외부에서 node.sub()를 호출하지않고 node.subs().sub()를 하는 상황도 있을 수 있다.
        * subs()는 어디까지나 편의함수니까. 그렇다면 이 경우, node.sub()한 결과가 일치하지 않게 된다. 그러니 subs()를 했을때 container자체에 반드시 반영이 되어야 한다.
        * 그리고 그것을 가능하게 해주는 가장 편리한 기능이 chain인데, with도 chain으로 구현된단 말이지. 별반 차이가 없고, 심지어 고작 생성자문제를 해결하려고 chain을 건다고?? 되려 복잡해진다는 얘기다.
> 요약:
>     * 아이디어 핵심
>         * **객체에 run(args)을 하면 복제객체 생성후 생성자가 호출된다.**
>         * **반면 객체.sub(CTOR_NAME, args).run(args) 처럼 생성자를 추출해서 호출한 경우는 생성자만 호출된다.**
>         * baseObj::run()은 getOrigin().clone()을 사용해서 객체를 생성하고 run(CTOR_NAME, args)해서 생성자를 호출한다.
>             * 지금은 tcppBridgeObj는 obj에서 상속받은 상태이지만, 위의 별도 항목으로 있듯이 나중에는 상속이 아니게 될 것이다.
>     * 알고리즘
>         1. verifier가 obj->canRun(args)를 호출한다.
>         2. obj::canRun(args) 안에서는 기존 대로 sub(CTOR_NAME, args)로 찾는다. @new가 아니라 @ctor만 찾는 셈.
>         3. verifier가 통과된다.
>         4. 실행단계에서 baseObj.run(args)가 불린다.
>         5. baseObj::run(args)에서 getOrigin().clone()으로 복제객체를 생성하고, 복제객체.run(CTOR_NAME, args)를 호출한다.
>             1. getOrigin() 함수 때문에 가장 구체클래스로부터 clone()이 가능하게 된다. bridgeCpp일 수도 있고, Int일 수도 있고, obj일 수도 있고, genericOBj일 수도 있다.
>         6. 생성자는 이제 객체를 복제하는 게 아니라, `me`를 가져와서 초기화를 하는 것에 불과하다.
* * *
# [o] 완전객체를 만드는 시점은 언제인가? ==> **실행단계에서 최초로 완전객체의 subs()를 호출하는 시점**
* 다음과 같은 코드가 있다고 하자.
```go
def A // 불완전 객체
    me(newAge int): age = newAge
    age := 0
def B A // 완전 객체
    me(): super(5)
    ....
def C A // 완전 객체
    me(): super(5) // 이거랑 같은 거 아냐??
```
* 추가 요구사항으로 `with`을 구현하거나 member variable의 초기식을 돌릴 수 있어야 한다.
* member variable은 현재 구현으로는 preEval 단계에서 채운다.
    * member variable 초기식은 다른 객체를 참조해서 코드작성을 할 수도 있다. 근데 다른 객체는 또한 또 다른 객체를 참조하는 초기식이 있을 수도 있다.
    * 그러니 이 초기화 문제는 쉽게 풀수 있는 게 아니다.
    * 이를 해결하기 위해서 preEval 단계가 존재한다.
    * preEval 단계에서는 이러한 멤버 초기식만 긁어모아다가 무한루프를 돌면서 초기식을 eval하고 에러가 없을 경우 해당 초기식을 stack에서 없앤다. 이를 변화가 생기지 않을 때까지 반복한다.
    * 그 결과 변화가 더 없으면 에러로 판단한다. 순환참조가 있다는 얘기다.
    * 그렇지 않고 모든 초기식이 더이상 풀리지 않고 무한루프를 돌아도 답보상태가 유지되면 에러로 내보낸다.
* [*] 상속을 도입해도 기존의 member variable 초기화 알고리즘을 그대로 적용 할 수 있을 것으로 보인다.
* [o] 이미 만들어진 origin객체를 생성자에 뒤늦게 태우는 게 가능한가? ==> **가능하다.**
* [d] 1안: verifier 시점에서 onVisit(obj) 최초시점에서 할 수 있는가? ==> **된다. 그러나 하지 않는다.
    * preEval 단계가 있기 때문이다. 이 시점에 객체 완성을 마무리 짓고 verifier에서는 말그대로 검증만 해서 role을 명확히 하는 게 더 좋을 것 같다.
* [u] 2안: preEval 단계에서 일괄적으로 상속도 처리가 가능한가? 이때 with도 하고, 완전객체도 만들어주고 말이야. ==> **된다.**
    * 장점으로는 객체가 완성되는 시점이 명확해진다. 깔끔해진다. 알기쉽다. 유지보수도 쉽다.
    * 하지만 preEval이 visit하는 것은 의존관계를 푸는 시점이 아니라, 풀기위한 후보군을 모으기 위해서 visit을 하는 것이다.
    * 그러니 onVisit 시점에서 상속 구현을 해버릴 수가 없다.
    * 그렇다고 특정 객체의 초기식에 대한 의존관계를 풀어낸 시점에서, 해당 초기식을 소유한 객체가 모든 초기식을 소화했다면, 그 객체를 초기화처리(상속, with 등)을 해버리는 것도 불가능하다.
        * 이 객체는 해결했어도, 이 객체가 의존하는 객체는 남아있을 수도 있기 때문이다.
    * [*] 그러니 preEval 과정이 모두 끝난 뒤에 onVisit으로 수집했던 객체들을 모아둔 배열을 순회하면서 한번에 상속을 처리하는 것은 가능하다.
        1. 단 이과정에서 한번 onVisit한 객체는 skip할 수 있어야 하며
        2. visit(obj)를 하면 안된다. 이렇게 해버리면 obj의 subnodes를 다시 traverse 한다. onVisit(obj)를 해야 한다.
        3. visitor는 node.sub()를 따라서 순회하기 때문에 obj 배열을 순회하는 것에는 적합하지 않다. 그러니 visitor를 사용할 수 없다. 직접 for문을 돌려야 할 것이다.
        4. 물론 onVisit(obj)에서 obj이 super를 가지고 있다면 onVisit(super) 부터 해야 한다.
    * [*] 지금까지 정리된 알고리즘을 요약해보자.
        1. parser는 단일 객체 A, B를 각각 생성한다. 각 객체에는 `with정보`, `상속정보`, `defAssign`를 담고 있다.
        2. preEvaluator는 onVisit(obj)에서 obj를 일단 객체리스트에 수집한다. 그리고 obj가 초기식목록을 가진 경우 obj를 별도의 후보군 리스트에 수집한다.
        3. traverse가 끝난 뒤 후보군 리스트를 무한 루프를 돌면서 초기식을 끊임없이 eval 한다. 초기식 eval이 성공하면 후보군에서 제거한다. 한 루프가 끝난 뒤  후보군의 size에 변경이 없으면 에러로 판단한다.
        4. 초기식 과정이 끝났다. 이제 모든 객체들은 초기식으로부터 생겨난 member variable을 가지고 있다.
        5. 객체리스트를 for문 돈다. 각 obj에 대해 다음의 expand과정을 수행한다. 상속 정보, with 정보를 추가하는 것이다.
            1. 이때 루프를 무한루프를 돌아야 한다. 이유가 있다.
                1. 상속은 방향이 지향적이다. 위에서 아래로. 그러니 순환참조가 안생긴다. 그래서 무한루프를 돌 필요가 없다.
                2. 하지만 초기식과 with는 다르다. 순환참조가 생길 수 있다.
            2. 객체리스트를 순회할 때, 객체의 expand 상태를 알 수 있어야 한다. 객체리스트를 `map<tweak\<obj\>, expandEnum>` 정도로 하면 되겠지.
                2. EXPANDING: expand 중임
                3. NEXT_TIME: expand에 실패하거나 아직 시도 안 함. 다음에 다시 시도하겠음
            3. obj가 이미 expand했던 거라면 skip 한다.
            4. obj가 이미 EXPANDING 상태라면, 지금 무한 (재귀/루프)를 돌기 직전인 것이다. 에러를 내보내고 다음 객체리스트를 순회한다.
            5. obj에 super가 있는지, 즉 상속한 객체가 있는지 확인한다. 있으면 expand(this.super)를 먼저 한다.
            6. 해당 객체의 남은 expand를 수행한다. 저번 수행에 이미 성공했던 defAssign 구문이나, with 구문이나 상속은 이미 제거가 되어있어야 한다.
            7. 이 obj에 대해 expand가 종료되면 객체리스트에서 제거한다.
            8. 객체리스트를 모두 한번씩 돌았는데 객체리스트의 size가 변화가 없다면 순환참조 인 것이다. 에러를 내보내고 모든 expand를 종료한다.
        * 대략적으로 이렇게 될 것이다.
    * [d] 알고리즘을 혹시 최적화를 더 할 수 없을까? ==> **위의 별도 항목으로 정리하였다.**
        * preEval로 visit 순회 --> defAssign을 위해 무한 루프 --> with를 위해 무한 루프. 순회만 3번에 그중 2번이 무한루프다.
        * [d] 1안: defAssign을 값을 eval하면서 넣지 말고, 일단 타입만 inference에서 넣어둔다. ==> **eval을 할 수 있어야 type을 알 수 있다. 이 방법은 모순이지.**
            * 이 방법의 가장큰 문제는 eval을 해야지만 type을 알 수 있다는 점이다.
            * 만약 이 모순점을 극복하고 싶다면 무한루프를 도는 게 아니라 의존성을 체크하면서 순서를 알 수 있어야 한다.
            * [x] type이 nonull 타입이면?
            * [x] 정말로 최적화가 되는가? 루프가 줄어드나? ==> **가능하기만 하면 그렇다.**
        * [d] 2안: defAssign을 하는 시점에 with도 같이 expand 할 수 있나? ==> **preEval에 한다. 실행단계에서도 한다. 매번 객체 생성시마다 한다.**
        * [d] 3안: with를 없앤다? ==> **유지한다. with는 다중상속과 유사한 부작용을 갖는다. 그러나 장점이 많아서 유지한다. 경고를 많이 내보내서 사용자가 잘못구현하지 않도록 유도한다.**
    * [x] 이미 parsing에서 만들어진 origin obj를 생성자에 태워서 완전객체로 만드는 게 가능한가? 아니면 별도의 객체를 만들어서 교체시켜야 하나? ==> **네. 객체 생성후, 거기다가 생성자.**
        * 이렇게 만들어진 obj는 상속도, member 초기화도, with도 된 상태다. 생성자만 호출이 안된것이다.
        * [d] 만약 교체한다고 하자. origin obj에 프로그램 시작 전에 생성자를 호출한 셈인데, 그랬을 때 문제는 없나?
            * 그 생성자에서 global 변수를 쓰고 있었다면? 근데 이게 아직 defAssign으로 생성이 안되거였다면? ==> ****
            * 다음과 같은 코드 겠지?
                ```go
                def A
                    // b B? // b = null
                    // b B // 이렇게 하면 b는 B() 객체가 들어있게 된다. 참고로 B에 me()가 없으면 이 줄은 에러다.
                    me():
                        B.factory.makeObj(0) // B가 어딘가에 있다.
                ```
            * [x] 현재 구현에서, 객체의 onLeave(obj)보다 그 객체의 onVisit(func)가 먼저 불리는 가?
        * 이미 있는 객체에 생성자를 호출해야 하므로, 생성자 호출은 객체생성이 아니게 되었다 ==> **별도 항목으로 해결**
    * [x] parser가 만들어준 상속정보, with정보, 들을 어떻게 잠깐 저장해서 verifier로 전달하나? ==> **전달할 필요없이, @preCtor를 사용한다. **
* [d] 3안: verification이 끝나고 나서 실행도중에 lazy하게 가능한가?
    * 이렇게 하면, 예를 들어 만들어진 B는 불완전 객체다. verifier가 상속관계를 연결시키고 표현식을 돌렸을 뿐이다.
> 요약:
>     org객체는 총 3번에 걸쳐서 완성된다.
>         1. parsing단계에서 1차 AST 추가
>         2. preEval단계에서 초기식 + 상속 + with 등 모든 객체 요소가 검증. 초기식, with는 각 생성자들에 복붙.
>             1. verifer는 속도최적화를 위해서 orgObj가 아니라 typeObj를 다룰 것이다.
>                 1. 별도의 항목에서 논의했다. --> #typeObj를_통한_최적화
>         3. verification 후 with, 초기식은 사라짐. == READY 상태
>         4. 실행단계에서 완전객체에 대해 subs()를 호출하는 순간 이미 만들어졌던 READY상태인 orgObj에 대해 생성자가 호출됨 ==> 생성자 안에서 with, 초기식이 모두 실행됨
>
>     이를 위해서 다음과 같은 신규/수정 사항들이 반영되어야 한다.
>         1. orgObj는 state를 갖는다. PARSED -> PRE_EVAUATED -> VERIFIED -> INITIALIZED
>         2. 의존성문제는 무한try로만 해결할 수 있기 때문에 초기식+with
>         3. 파서는 orgObj에 완전객체 생성을 위한 생성자호출구문을 채워둔다.
>         4. 생성자 호출과 객체 생성을 분리한다.
>         5. VERIFIED된 orgObj::subs()가 불려지면 생성자호출구문을 실행한다. INITIALIZED로 상태변경한다.
* * *
# [o] with 를 composition의 delegation으로도 사용이 가능한가? ==> **네. 해보자. 다중 상속을 지원한다. 하지만 잘못 쓰면 바로 경고를 내보낸다.**
* `with 객체`를 하게 되면 해당 객체의 member를 기반으로 하는 별도의 최고 scope이 등록된다.
* 이를 응용해서, 정의블록문 안에 `with 객체` 를 등록하게 할 수 있는 가?
* 하나의 키워드를 여러 곳에서 사용하자는 ZEN에 부합한다.
* [x] 여러개를 해서 충돌이 발생하면? ==> **겹치면 경고로 나가고, 충돌난 부분이 모호해지면 에러로. 해당 클래스에 직접 override하면 해결**
* [x] 다른 언어 중에서 이걸 지원하는 경우가 있나? ==> **제한적으로만 지원한다. 그마져도 몇개 없다.**
    * [x] Kotiln은 `by` 로 delegate를 편하게 할 수 있지만, ==> **delegate할 클래스가 반드시 interface여야 한다, 상속과 함께 쓸 수 없다.**
        * 아무래도 충돌문제를 피하기 위해서 최대한 제한을 걸어둔 것으로 보인다.
        * 상속과 함께 쓸 수없다는 부분이 가장 확실한 제한일 것이다.
            * 상속한 함수인지 delegation함수인지 어느 것을 우선할지는 명확하지만, 사용자가 `함수 상속했겠지?` 했는데 사실은 delegation함수가 호출되는 경우 에러를 알아내기가 상당히 힘들기 때문이다.
        * 겹치는 것을 허용하되, 겹쳤는데도 불구하고 해당 클래스에서 정의 않으면 warning으로 내보내는 게 어떨까?
        * 그리고 겹쳤는데, 어느것을 우선할지 모호한 경우 에러가 나가도록 한다면.
    * [x] C#도 `delegate` 키워드가 있다 ==> **그러나 함수에 대한 delegation으로, 함수포인터에 가깝다.**
    * [x] Swift도 `delegate`란 키워드가 있지만 ==> **그냥 단순히 interface로 하는 subtyping에 가깝다. 이건 delegate가 아니야!**
    * [x] xtend는 `@delegate`가 있긴 하다. 어느 정도까지 호출이 가능한 걸까?
    * 전체적으로 Delegate를 지원하는 언어 자체가 적다는 건 알 수 있었다.
    * major 언어에서는 유일한 게 kotiln이구나.
    * 일단 생각해보면, 1개만 허용하는 게 좋을 것 같다는 생각이 든다.
        * 물론 상속보다 delegate가 우선된다는 점은 명확하지만.
* [x] 문법적으로 말이 되나? ==> **말은 된다**
* [d] 상속도 이걸로 할 수 있나? ==> **되는데, 최적화가 없다면 depth가 점점깊어진다. 퍼포먼스가 떨어진다. 개념은 동일한데, 가독성에서 상속과 with를 구분하는게 더 좋다.**
    ```go
    def A // 완전객체
        foo() void
        boo(a int, b int) int
        name := ""

    def B with A // A: 완전객체
        boo(a int, b int) int // override
            ret super.boo(a, b)
        age := 5
    b B

    def C
        with a := A() // defAssign은 expression이 아니다. with만의 특이한 문법이다.
        // with a // 이게 기본형이다. 위는 줄여서 쓴거다.
        age := 5
    c C
    ```
    * [x] 질문: 위에서 b와 c는 사실상 같은 걸까? ==> **다르다**
        * [x] 비슷하지만 분명 다르다. ==> **상속은 상위객체가 동등하게 들어간다. delegation도 마찬가지 효과를 보이지만 결정적으로 member로써 상위 객체가 존재한다는 점이 다르다.**
        * 현재 구현적으로는 다르다.
            * 객체를 구현하면서, 같은 member일지라도 함수와 변수는 다르다. 변수는 객체 자체에 귀속되지만 함수는 origin객체에 귀속된다.
            * 물론 namu가 이들을 호출하는 관점에서는 둘은 완전히 같다.
            * namu가 이 둘을 관리하는 시점에서도 둘은 동일하다. 동일하게 `복제`를 시도하고, mutable인지 immutable인지에 따라서 deepcopy가 되거나 shallowcpy가 된다.
            * 실제 namu 코드를 보면 이 둘을 다르게 관리하고 있다.
        ```cpp
        obj::assign() {
            _owns.bind(rhs._owns->deepClone());
            _shares.bind(*rhs._shares);
        }

        obj::deepClone() {
            if(_shares) ret->_shares.bind((scopes*) _shares->deepClone()); // chain's deepClone() clones first container only.
            ret->_subs.bind((scopes*) ret->_makeNewSubs());
        }
        ```
        * [?] 먼저 `함수인지 변수인지 구분하지 않고 동일하게 copy/clone을 할 수 있도록 cpp를 구현할 수 있는가` 부터 따져봐야 한다는 걸 알 수 있다.
    * [x] 완전객체인 B, C도 같은 걸까? => **차이는 없어보인다.**
    * 퍼포먼스가 떨어지는 이유는 명확하다. b.name 하면 될일을, b.a.name을 하게 되니까.
    * 계속 depth가 깊어지면 나중에는 b.a.c.d.e.f.name이 될 것이다.
    * 이는 name이 아니라 함수일 경우도 마찬가지다.
    * [x] 만약 퍼포먼스 차이가 없다면, 사용자 관점에서, 개념적인 관점에서 둘은 동일한가? ==> **delegation을 상속으로 대신할 수는 있다.  하지만 상속과 with를 구분하는게 좋아 보인다.**
        * [x] with는 변수명이 필요하다. 상속은 필요치 않다. ==> **이 관점이라면 동일하다고 볼 수 있겠다.**
            * `with A() 처럼 변수명이 없는 버전을 하나 만들지 뭐...` 라고 생각하고 있다면, 이는 일관성이 없는 것이다. 이 생각이라면 함수 블록문 내부에서도 with A()가 가능해야 한다.
            * 음.. 근데 가능한게 맞아보이는데?
        * [x] 상속은 `super`가 존재한다. ==> **그래. 이것도 문제다.**
            * 코드를 봐보자.
            ```go
            def A
                foo() void: ...
            def B
                with A() // 기본적으로 me는 A라는 뜻인가?
                foo() void: ...
                boo() void
                    foo() // B::foo()
                    A()의 foo
            ```
            * [?] 그럼 with를 쓸때도, with 바깥에 있는 뭔가라는 뜻으로 하나 만들어 본다면? ==> **이 아이디어는 with 자체의 문제로 해결하도록 하자.**
        * [x] 또 다른 문제는 with가 코드 중간에 어디서든 나올 수 있게 되면 어디서 상속을 한 건지 코드를 깊숙히 찾아야 하는 문제가 있다. ==> **그러니 상단에만 놓게 하거나 상속과 with를 구분하도록 하는게 좋다.**
        * [x] 또 다른 문제는 with를 delegation으로 쓴 건지, 상속을 한건지 모르게 된다. ==> **그러니 차라리 상속과 with를 구분해서 사용하도록 하는게 좋다**
> 요약:
>     1. 정의 블록문에서 with를 사용할 수 있다.
>     2. with를 할 때는 정의표현식이 나와야 한다. with A() 같은 거는 함수안에서만 사용이 가능한 것이다.
>     3. 여러개를 with 할 수도 있다.
>     4. 상속한 함수와 with에서 내보내는 함수가 겹치는 경우, with를 우선한다. with가 해당 객체에 정의되었으니. 그러나 겹치는 함수의 목록을 경고로 내보낸다. 이렇게 쓰지 말라고 보내는 것이다.
>     5. with를 한 함수를 해당 객체에서 함수를 만든 경우 function shadowing이 된다. 해당 객체의 함수가 항상 우선된다. 경고도 나가지 않는다.
>     6. with를 2개 이상 하였고, 그 중에서 겹치는 함수가 있다면 어떤 메소드를 우선할지 모호하므로 에러가 나간다. 1개만 with를 하거나, 해당 객체에서 메소드를 정의한 경우에 에러가 사라진다.
>     7. 기반클래스의 함수A가 있고 현재 클래스에서 with한 객체가 A를 들고 있는 경우, overriding이 적용된다. 기반타입으로 함수A를 호출하면 객체A의 함수A가 호출된다.
>     8. with로 내보내는 클래스A와 with를 정의한 현재 클래스 B가 서로 같은 클래스로부터 상속한 게 있을 경우, 같은 클래스로부터 상속을 했다고 경고를 내보낸다.
>     9. withExpr은 코드 블록문을 가지고 있다.그 블록문을 실행하면서,
>         1. `outer` 라는 variable을 하나 scope에 추가해둔다. `outer`에는 withExpr이 실행되기 직전의 me가 들어가 있다.
>         2. withExpr이 주어진 expr 을 `me`로 추가해둔다.
>     10. withExpr()이 종료되면 추가했던 scope이 제거되면서 `outer`, `me`가 모두 없어진다. 이제 `me`는 withExpr 진입전의 `me`가 들어있다.
>     11. 참고로, `with <expr>` 처럼 with 뒤에 나오는 expr은 원칙적으로 nullable이면 안된다.
>         1. 단, 예외로 함수내에서 사용하는 with는 nullabletype인 expr을 사용할때 예외적으로 뒤에 `?`를 붙이는 걸 허용한다.
>         2. 이렇게 하면 null이 아닐때에만 해당 with 블록문을 실행한다.
>     12. 또한 `with`는 함수내에서 사용할 때 뒤에 아무런 expr 없이 단독으로 사용할 수 있다. 이것은 블록문만 만들고 싶을때 사용한다.
* * *
# [o] with를 통해서 static을 구현한다고 했을때 static 상속 문제에 해당되지는 않는가? ==> **개념적으로는 가능하다. --> #완전객체인지_여부는_어떻게_판단하는가_with의_완전객체문제는_어떻게_해결하는가 를 해결하면 된다.**
* [x] 먼저 개념적으로 합치되는지를 분석해보자. ==> **합치된다.**
    * 일반적으로 static 메소드는 타입에 귀속되는 것이기 때문에 상속할 수 없다.
        ```kotlin
        class A {
            companion object {
                fun foo() { .... }
            }
        }
        class B : A() {
            companion object {
                fun foo() {...}
            }
        }
        val a = A()
        val a2 = B() as A
        val b = B();
        a.foo() // A::foo
        a2.foo() // A::foo
        b.foo() // B::foo
        ```
    * [x] 이때, with를 통해서 static을 구현한다면, 상속을 하게될 경우 어떻게 되는가? 그 static 메소드를 어떻게 호출되어지는가? 그 방식에 해결 불가능한 문제는 없는가? ==> **override된다. 그리고 이 방식도 괜찮을 것 같다.**
        ```go
        def A
            with def()
                foo(): ....
        def B A
            with def()
                foo(): ...
                koo(): ...
        a := A()
        a2 := B() as A
        b := B()

        a.foo() // A::foo, 내부에서 a.def().foo()가 a에 등록되는 구조로 구현될 것으로 지금 여겨진다.
        a2.foo() // 현재의 알고리즘으로는 B::foo가 된다.
        b.foo() // B::foo

        a2.koo() // 에러.
        ```
        * [x] with도 override가 되어야 하는가? ==> **네. 반대로 override가 안되게 한다는 건 hiding은 되게끔 한다는 것이다. hiding은 없애는게 맞다고 본다**
            ```go
            def foomaker
                foo(): ..doSomething..
            def a
                foo(): ..doNothing..
            def b a
                with @foomaker // `with fm foomaker` 와 같은 뜻이다.
            a1 := b()
            a1.foo() // ..doSomething..
            ```
            * 문제는 없어보인다.
* [u] 하지만 만약 함수의 반환한 것을 with로 static화 한다면 어떻게 될까? ==> **이러한 동적 코드도 with가 가능해졌다.**
    ```go
    def elemBase: ...
    def elemDerived: ...
    def value
        someBigFunction() elemBase: ...
    def value2 value
        someBigFunction() elemDerived: ...

    v := value2 as value
    def a
        with static := v.someBigFunction()
    ```
    * [d] 1안: 위의 코드를 파싱할 수 있으려면 `동적으로 lazy하게 with를 통해서 origin 객체인 a의 scope을 조작 할 수 있어야` 한다.
        * [x] `v := value2 as value` 같은 것은 언제 평가되도록 구현했는가? 이미 만들어 놓은 부분을 참고하면 더 정확히 구현방법에 대한 확신을 얻을 수 있을 것이다. ==> **verifier에서 한다.**
            * [x] 일단 동작한다. 즉, 코드 어디선가 내가 구현은 해놓은게 맞다.
            * 확인해보니, verifier 안에서 초기화를 해두고 시작한다
            * 그렇군. 그렇게 해도 문제는 없겠구나.
            * 정적으로 하는 걸로 하자.
    * [d] 2안: 아니면 단순히, `def 안에서 with를 할때는 오직 A AType 같이 정적으로만 할 수 있습니다` 라고 하던가. ==> **사용성과 일관성을 위해 지원하는 게 맞다.**
        * 하지만 잘 생각해보면 `v := value2 as value` 부분과 마찬가지로 코드가 시작되기 전에 무언가의 런타임 동작이 들어가는 것은, 꽤 자연스러운 것이다.
        * 그러니 사용성만 고려하면 일관성을 위해서 with문에서도 런타임 동작이 들어갈 수 있다고 사용자는 여길것이다.
        * 지원을 해야하는게 맞다.
    * [d] 3안: verifier 만들어 놓고 시작한다.
        * 이렇게 되면 일단 불완전한 B를 만들고 나중에 교체하는 것이 아니라,
        * 불완전한 B가 파싱단계에서 만들어지고, 본격적인 eval을 하기전에 `B를 완성한다` 는 관점이 된다.
        * verifier::onVisit(obj)는 해당 obj가 코드상에 처음 등장한 시점에서 호출된다.
        * 그러니 이 함수에다가 그 obj가 아직 `not initialize` 상태라면 `with`와 `완전객체 생성자`에 대한 초기화를 수행하는 식으로 실행해볼 수 있을 것이다.
    * [d] 4안: verifier에서 하는건 맞는데, onVisit으로 만나게 되면 실시한다.
        * 코드 분석을 통해서 모든 origin객체는 onVisit에 최초 접근한다는 걸 알았다.
        * 그러니 onVisit(obj)가 들어왔을때 obj가 초기화가 안되어있으면 초기화를 수행한다. 초기화란,
            1. 상속을 구성할 것
            2. static을 통한 with를 확장할 것.
        * [d] 그런데 상속또한 with로 해결하면 좋을 것이므로, 결국은 `with를 통한 초기화를 어떻게 하는가?` 를 먼저 결정할 수 있어야 한다. ==> **상속은 with로 하지 않는다. 자세한 고찰 결과 어렵다는 걸 알았다.**
    5. [u] preEval단계에서 초기화구문을 eval했던 것처럼 무한try를 한다. ==> **알고리즘은 별도로 정리하였다.**
* [?] 그런데 애초에 static 처럼 완전객체인 것처럼 static 메소드를 호출이 가능한 것인가?? ==> **with 완전객체문제를 해결한다면 가능하다. 별도 항목으로 논의**
    * why?
        * static을 하려면 지금까지의 전제는 완전객체여야 한다는 것이다.
        * 그럼 완전객체가 아닌 경우에는? 이 경우 with로 static을 대신 구현이 가능한가??
        * with의 역할은 단순히 delegation 해주는 것이다. 함수가 sub로 들어가도, 완전객체는 애초에 sub에 대한 접근 자체를 막는다.
        * 그리고 모든 상황에서 완전객체를 만들 수 있는 것은 아니다.
        * 따라서 static을 호출 할 수 없는 상황은 반드시 발생한다.
    1. [?] 완전객체를 with를 하였다면, 그리고 이걸 with로 expand를 하였다면, me는 완전객체가 아니더라도, 이 with가 물고 있는 완전객체가 expand한 sub는 접근이 가능하게 한다.
        * 개념적으로만 본다면 훌륭하다.
        * 구현이 문제다.
* * *
# [o] with에는 기반타입이 온 경우, 구체타입의 함수나 prop은 scope에 포함되어서는 안된다. ==> **포함시킨다. verifier단계에서 탐지할 뿐.**
* 코드를 보자.
```go
def SubA
    foo() void: ..
def SubB SubA
    foo() void: ...
    boo() void: ...
def A
    with getSub()
fun getSub() SubA: SubB
A.foo() // SubB::foo() 가 나온다. 괜찮다.
A.boo() // 실패해야 한다. 하지만 성공한다.
```
* 현재의 알고리즘은 prop에 대한 delegation을 잘 지원하기 위해서 delegation함수를 만드는 것이 아니라 scope을 하나 더 쌓는 식으로 알고리즘을 정했다.
* 그러니 `with` 를 만나면 scope으로 씌우는 동작은 그대로 유지해야 한다.
* 대신에 별도의 항목으로 논의한 --> #상속을_지원했을때_verification단계에서_기반클래스_scope에서의_node가_있는지를_알_수_있어야_한다 가 구현이 잘 된다면,
* verifier 단계에서 알아낼 수 있을 것이다.
* * *
# [o] with는 nullableType에 대해서도 할 수 있는가? ==> **아니오. 반드시 non nulltype이어야 한다.**
* why?
    * 지원해야하는 이유는 명확한데, `a := foo()` 처럼 쓰는 경우가 많다는 것이다.
    * 이 과정에서 foo()가 nullable type을 반환할 가능성도 무시하지 못할정도라는 점이다.
    * non nullable만 된다고 제한을 걸어두면 사용성이 확 준다.
    * 위 항목들에서 확정한 알고리즘을 짧게 되새겨보자.
        * 파싱단계: @preCtor에 withOnlyExpandExpr로 넣어둔다.
        * preEval단계: expr을 eval해서 그 subs들을 scope으로 objScope위에 추가해둔다.
        * verification단계: objScope을 탐색하면서 검증한다.
1. [u] 지원하지 않는다. ==> **네. 꼭 필요한가도 좀 의문이 들기 시작했다.**
    * 생각할께 많아져서 그렇다.
    * 다음과 같은 코드를 보자.
    ```go
    def Sub
        age := 0
    getSub() Sub?
        if Random.toInt() % 2 == 0
            null
        else
            Sub()
    def A
        with getSub()
    A.age // 과연 이것은 무슨 타입일까? 맞춰보자.
    ```
    * 정답은 `int?` 가 된다. getSub()는 null일수도 아닐수도 있기 때문에 여기에 의존하는 타입은 int?가 된다.
        * 참고로 `with` 가 함수내에 사용될 때에는 뒤에 나오는 eval이 null이면 에러다.
        * eval이 nullable일 때는 `with <eval>?` 처럼 쓰면 된다. null이 아닐때만 블록문을 실행한다.
    * 물론 Null inference도 비슷한 작업을 해줘야 하긴 하다.
        * 예를들면,
            ```go
            def A
                age := 0 // int
            def B
                a A?
            B.a?.age // age는 int였지만, 앞에 ?. 가 나오기 때문에 최종 eval타입은 int? 가 된다.
            ```
        * 하지만 이 경우는 반드시 앞에 `?.` 기호가 나오기 때문에 구분이 쉽고 알고리즘 짜기가 쉽다.
        * 반면, 위의 케이스는 코드상에 아무런 힌트가 없다.
        * 그리고 현재의 with expand 알고리즘은 일일이 prop이나 func에 대한 delegation을 짜서 넣는게 아니라 그냥 scope을 add 하는 것이다.
        * 따라서 이 기능을 지원하려면 scope을 단순히 얹어서는 안되고, scope을 복제해서 일일이 반환형만 다른 새로운 함수를 만들어 넣고 하는 등의 작업이 필요하다.
        * 꼭 필요한가도 의문이 들기 시작했다.
* [x] 근데 또 이런 케이스를 보자. 이건 지원해줘야 하지 않을까... ==> **안된다**
* 코드를 보자.
```go
def Bean // adt다.
    foo() int = null

def A
    _proxy Bean?
    me(p Bean): proxy = p
    with proxy // 이게 안된다구요...ㅠ

makeBean() Bean

bean := makeBean()
A(bean)?.foo() // 이게 안되요..
```
* 사용성만 보자면 아주 합당한 케이스 아닐까?
* [d] 질문: 생성자에서 채워지는 변수가 있다면, 이건 non nullable이 될 수 있는가? ==> **아니요.**
    * [x]  다른 언어들은 어떻게 하지? ==> **안 해줌.**
        * by 로 delegation을 만드는 방법이 있는데, 코틀린의 경우 nullable 타입이 와서는 안되도록 막아놓았다.
        * 위와 같은 상황(proxy를 만드는) 이라면 by 를 쓸 수 없다. 직접 만드는 수 밖에 없다.
        * Go같은 경우 타입 임베딩이 있긴 한데, 얘는 상속과 비슷한 거라 당연히 nullable이 안된다.
        * 애초에 go는 nullable type이 없기도 하다.
* * *
# [o] #상속을_지원했을때_verification단계에서_기반클래스_scope에서의_node가_있는지를_알_수_있어야_한다. ==> **parser가 pack::orgObjList를 채워준다.**
* 다음 namu 코드를 파싱할 수 있어야 한다는 것.
```go
def a
    foo() void: ....
def b a
    foo() void: ....
    boo() void: ....
a1 := a()
a2 := b() as a
a2.foo() // b::foo
a2.boo() // <-- 에러가 나야 한다. class a에는 boo가 없기 때문이다. 물론 a2는 boo를 가지고 있다.
         // verification에서 a2변수의 타입이 a라는 걸 인지할 수 있어야 하고,
         // a타입에 boo가 있는지를 비교할 수 있어야 한다.
         // 지금은 a2.get("boo") 처럼 해버릴텐데, 이렇게 하면 이 코드는 error가 아니라 성공으로 간주될 것이다.
```
* [x] 어떻게 구현할 것인가?, ==> **node a 에 대해서 기반클래스 중 하나인 B의 subs를 추출할 수만 있다면, verifier가 처리 가능하다.**
* [u] 어떻게 하면 node a에 대해 주어진 type\<T\>에 대한 scope 를 추출할 수 있는가? 알고리즘은 어떻게 되지? ==> **pack::orgObjList를 추가한다. parser가 채워준다.**
    * 고찰
        * verifier만 탐지를 할 수 있으면 되므로, type<--> orObj 매핑 정보는 외부에 있고 verifier에 전달만 되면 된다.
        * parser가 orgObj을 처음 만드는 곳이다.
        * 이후, preEval단계던, execution 단계던 orgObj가 다른 instance로 교체되지는 않는다.
    1. native건, mgd건 모든 pack은 orgObj list를 갖고 있다.
    2. parser::onDefObj()에서 pack의 tray로 orgObj를 추가해둔다.
    3. verifier는 pack을 입력받도록 한다. verifier.start()할시, pack이 아니라 node가 올 수도 있어야 한다. --> python같은 언어도 eval(`코드블록`) 같은 함수를 제공하니까.
        1. 아니면 verifier.start(pack&) 으로 변경한다. eval 기능을 막는거지.
> 요약:
>     1. node를 실행할 때는 당연히 상위 obj scope에서부터 탐색해서 실행한다. 가상 디스패치가 되는 것이다.
>     2. verification시에는 verifier가 node a에 대해 현재 타입을 참조자에서 가져와서 해당 타입의 scope를 추출한다. 그리고 거기서 해당 메시지를 호출 가능한지를 검토한다.
>     +. 호출가능하다는 건 알았다. 기반타입에 함수가 있는 것이다. 마음의 여유가 된다면, 이때 **해당 함수가 = null 일때, 구체클래스에 해당 함수를 채워 놓았는가를 따져본다.  근데 사실 이거는 객체 정의문을 만났을때 테스트하긴 한다.**
* * *
# [o] 생성자 redirection 방법 ==> **가장 첫줄의 ctor()을 사용한다.**
> 요약:
>     1. ctor은 생성자를 위한 키워드다. 이미 다른 항목에서 논의한바 있다.
>     2. ctor() 안에서 1줄만 허용되며, 그 1줄이 ctor() 호출로 된 경우는
* * *
# [o] mgdType을 만들어야 하는가? str에 mgdType을 넣는 경우도 있어야 하는가? ==> **네. 없으면 verifier가 `a A := B()` 같은 코드를 에러탐지할 수 없다.**
# [o] with를 한 A, B도 상속관계처럼 isSub()가 되는가? ==> **네.**
* A가 부모, B가 자식관계라면 `B.isSub(A) = true` 나오는게 정상이다.
* [x] 하지만 with로 된 건 어떻게 되는가? ==> **isSub 맞다.**
    ```go
    def A
    def B
        with A
    a A := B() // ?
    ```
    * [x] 쉽게 생각하면 a에 B()가 들어가 있을 때 a는 A인 것처럼 처리가 가능한가? ==> **네**
        * A의 subs()가 깔리고 나서 B의 subs()가 올라가니까. 네. 처리 가능하다.
* [x] mgdType과 nativeType을 어떻게 잘 엮을까? ==> **mgdType은 1개의 instance만 존재해야한다는 것을 잘 지켜라. orgObj::getType()에 인스턴스를 둬라. pack::orgObjMap<type*, orgObj> 로 관리해라.**
    * mgdType의 요구사항 및 속성을 다시한번 되짚어보자.
        * nativeType은 싱글톤이다. 반면 mgdType은 싱글톤은 아니지만, 시스템이 orgObj를 unique하게 관리하고 있으므로 orgObj.getType()으로부터 나오는 mgdType은 자연스럽게 unique 속성을 개념적으로 갖는다.
        * 쉽게 말해 mgdType을 가져오려면 `_type.bind(orgObj.getType())` 하라는 얘기다.
        * 시스템은 orgObj를 pack::orgObjList와, pack의 subs()에 놓는 것으로 해결하고 있다.
        * 물론 복제된 mgdObj::getType()을 하면 orgObj::getType()과 같은 instance가 나와야 한다.
        * mgdType은 복제가 되어서는 안된다.
    * nativeType들은 static으로 subs(), supers() type[]를 가지고 있다. 그리고 여기에 객체가 담긴다.
    * *mgdType은 유일하게 1개의 인스턴스만 존재해야 한다* 라는 규정만 잘 지켜준다면, nativeType에서 정의한 getSupers() 같은 API에 값을 채우기만 하면 되므로 간단하다.
    * mgdType을 만드는 순간은, parser에서 만든다.
    * 하지만 mgdType에 상속정보를 채우는 순간은 상속이 정의되는 preEval단계에서 해야 할 것이다.
* [x] with는 다중상속이 가능하다. 즉, 부모가 여러개다. ==> **nativeType의 API를 변경한다.**
    * getSuper()는 비교적 쉽다. 하나가 아니라 여러개가 나가면 된다.
    * native는 다중상속을 쓰지 않을 것이므로 element 1개짜리 배열이 나가면 되는 거고.
    * 문제는 getSupers()다. supers()는 이미 vector가 나가고 있으니까. `vector<vector<type*>>` 으로 변경해야 할 것이다.
> 요약:
>     1. with도 상속관계처럼 다루는 게 맞다.
>     2. native는 1개의 getSuper() 만 전제로 하고 있으므로 개선이 필요하다.
       3. mgdType은 unique해야한다.
       4. orgObj::getType()에 둬라.
       5. pack::orgObjMap<type*, orgObj> 로 관리해라.
# [x] protected with가 필요한가? ==> **지원 안함. 그냥 a::b 하세요.**
* [x] protected 상속이 있는 언어도 있다? ==>  c++ 만 있는 개념이다.
* [x] 그럼 나도 지원 안해줘도 될 것 같은데... 정말로 protected with == protected inheritance 인지 조금 만 더 생각해보자.
* * *
# [o] #member_초기화_문법 ==> **with는 런타임에 교체가 가능하다**
* why?
    * with의 경우 assign이 발생해서는 안된다. 그런데 생성자에서는 1번 초기화가 될 필요가 있다는 거지.
    * 즉, 다른 언어들은 이러한 기능이 없기 때문에 assign 기호로도 충분히 가능하다. 그러니 굳이 이러한 초기화 문법이 필요없다.
    * 다른언어와 내 언어는 상황이 다른 것이다.
    * 초기화 문법에 사용되어야 하는 것들에는,
        1. 생성자에 있는 값을 field의 초기화에도 사용
        2. #생성자_redirection_방법
        3. withExpand(==>생성자에 대한 호출)
    * 이 3가지다.
    * [x] 다른 언어들은? ==> **c++, kotlin이 유일하다.**
        * c++ 코드를 보면 이런 것이다.
        ```cpp
        struct A {
            A(int age, string name): _age(age), _name(name) {} // <--
            int _age;
            string _name;
        };
        ```
        * [x] kotlin
            ```kotlin
            class A(private val age: Int, private val name: String)
            ```
        * 그 외의 언어들은 그냥 한줄한줄 적게 끔 하네.
    * 추가 요구사항에는,
        * 이왕 추가하는 김에 간편했으면 한다.
            ```java
            class A
                private int age;
                private String name;
                private float grade;
                A(int newAge, String newName, float newGrade) {
                    age = newAge;
                    name = newName;
                    grade = newGrade;
                }
                // 이렇게 한줄한줄 적으면 불편하잖아.
            ```
        * 그렇게 되기 위해서는 기본적으로,
            1. `,` 을 사용해서 한줄에 여러개를 표현할 수 있어야 한다.
            2. `old = new` 같은 방식이 아니라, **field는 알고 있지? 거기에 들어갈 값이야** 식으로 생략할 수 있어야 한다.
* 고찰
    * 핵심은 2가지다.
        1. 생성자에서만 사용가능한 문법이라는 걸 직관적으로 알 수 있어야 한다.
        2. 간편하게 사용하려면,이미 정의가 된 prop의 이름을 사용할 수 있어야 한다는 점이다.
    ```go
    // 연습을 해보자.
    def Person
        age := 0
        name := ""
        grade := 4.5
        me(age int, name str, grade flt)
    def Tool
        name := ""
        use() void:...
    def Student
        with @Person
        with @Tool
        year int
        classroom int
        me(age int, name str, grade flt, toolName str, newYear int, newClassroom int)
            Tool = Tool(toolName)
            Person = Person(age, name, grade)
            year = newYear
            me.classroom = newClassroom
        me(toolName str, newYear int, newClassroom int)
            Tool = Tool(toolName)
            Person = Person()
            year = newYear
            classroom = newClassroom
    ```
    * 코틀린의 경우:
        ```kotlin
        class Student {
            private var classroom: Int = 0
            private var year: Int = 0
            private var person: Person
            private var tool: Tool

            constructor(age: Int, name: String, grade: Float, toolName: String, newYear: Int, newClassroom: Int) {
                person = Person(age, name, grade)
                tool = Tool(toolName)
                year = newYear
                classroom = newClassroom
            }

            constructor(toolName: String, newYear: Int, newClassroom: Int) {
                person = Person()
                tool = Tool(toolName)
                year = newYear
                classroom = newClassroom
            }
        }
        // 내 기존 코드와 별반 차이 없다ㅋㅋ
        ```
    * 나의 개선버전
        ```go
        def Student
            with @Person
            with @Tool
            year int
            classroom int
            me(Person<-age, Person<-name, Person<-grade, Tool<-toolName, <-year, <-classroom): ret
            me(Person<-age)
            me(Tool<-strName, <-year, <-classroom)
                <-Person()
        ```
1. [d] 기호를 사용한다.
    * 주의할 점은, 이 기능만을 위한 기능이 아니라, 다른 용도로도 사용될 수 있는 폭넓은 기능을 제공하는 일반적인 기호여야 한다.
    * `<-` 기호를 사용한다.
        * `init to` 에 가까운 뜻이다.
        * 생성자에서만 사용한다.
    ```go
    ​￼def Student
        with @Person
        with @Tool
        year int
        classroom int
        me(Person<-age, Person<-name, Person<-grade, Tool<-toolName, <-year, <-classroom): ret
        me(Person<-age)
        ​￼me(Tool<-strName, <-year, <-classroom)
            <-Person()
    ```
    * [?] 매번 Person, Person, Person 붙이는게 귀찮은데?
    * [?] 모양이 이쁘진 않다. <-가. 다른건 없는가?
    * [?] 누가 봐도 생성자에서 이용도로 쓰라고 만든거네. 다른 용도는 없을까?
2. [d] 생성자 밑에 추가로 적용하는 문법을 넣는다.
3. [d] `==>` 를 지원한다. ==> **상속이 사라지면서 super가 없어져버렸다. 어느 func을 먼저 호출해야 하는지 애매하다. 또한 생성자의 super는 with한 애들의 생성자다. field 초기화구문이 아니라.**
    * `==>` 은 예전부터 있던 아이디어이다.
    * overriding한 super함수를 호출해준다. 단, 함수에 넣었던 인자를 넣는 것이다.
    * `==>` 가 앞에 있냐 뒤에 있냐에 따라서 먼저 super를 호출하고 body를 호출하는지 아닌지를 결정한다.
    ```go
    def A
        add(a int, b int): a + b
        me():..
        me(x int, y int): ...
    def B
        with a A()
        a ==> add(x int, y int) // ==> 가 앞에 있으니 a.add(x, y)가 먼저 호출된다.
            print("value is $res!") // 별다른 명시가 없어도 `==>` 에 의한 결과는 res에 담긴다.

        // 위의 코드는 다음과 같다:
        add(x int, y int)
            res := a.add(a, b)
            print("value is $res!")
            return res

        a ==> me(x int, y int)
            // a(x, y) 를 먼저 호출한다는 뜻이다.
    def C
        age := 0
        name := ""
        me(): ..
        ==> me(age int, name str) // 앞에 a가 없으니 이 객체C의 기본생성자가 호출된다
    def D
        with C
        grade := 0.0
        me(C.age int, C.name str, .@grade)
            ret
    ```
    * [ㅌ] 상속이 없어지면서 super가 정해져있지 않기 때문에 overriding을 누구에게 했는지 코드상에 잘 안나타난다. 구현은 어느정도 가능하지만.
    * [d] 생성자에다가 ==>를 쓰면, 그럼 인자가 동일하지 않은 기반클래스 생성자를 호출할 때는??
4. [u] with를 런타임에 교체 가능하게 한다 + 쉬운 초기식 문법을 제공한다.
    * 문제의 핵심은,
        * def 안의 with는 런타임에 수정이 불가능하다.
        * 반면 함수 안의 with는 또 정의가 가능하다.
        * 이렇게 with의 문법이 다르다는 점이 일관성을 떨어트리고 해결방법이 아름답지 않게 만든다.
        * 이렇게 with는 런타임에 수정이 불가능하지만 생성자에서만큼은 수정이 가능해야 하는 문법을 만들어야 한다. 모순적이다. 그게 문법에서도 바로 느껴지는 것이다.
        * 그러니 모순 자체부터를 없앤다.
    * 다음과 같이 한다.
        1. with는 언제든 수정이 가능하다.
        2. with 수정은, 평소 하던대로 `=` 기호를 사용한다. 단 with의 이름은 미리 정의해둬야 한다.
    * 이렇게 하면 추가로 문법이나 기호를 만들지 않아도 된다.
    ```go
    def Student
        with p Person
        with t Tool
        year int
        classroom int
        me(age int, name str, grade flt, toolName str, year int, classroom int)
            p = Person(age, name, grade)
            t = Tool(toolName)
            me.year = year
            me.classroom = classroom
        me(age int)
            p = Person(age)
        me(strName str, year int, classroom int)
            p = Person()
            t = Tool(strName)
            me.year = year
            me.classroom = classroom
    ```
    * 문법이 장황하다고 느낄 것이다. 하지만 이제 with는 그냥 assignment에 불과하므로 초기식을 단축시키는 문법을 만든다면 with든 field든 일괄적으로 간단하게 만들 수 있게 되었다.
    * [x] with의 수정에 대한 verification은 고찰결과 문제가 생기지 않는다고 판단했다.
        ```go
        def A
            foo() void: ....
        def DerivedA
            with A()
            boo() void: ...
            foo() void: ...
        def b
            with a A() // a를 만드는 시점에서 str type은 type inference가 된 A다.
        b.a = DerivedA()
        b.foo() // b::foo()
        b.boo() // --> 에러? 성공?
        ```
    * 기능적으로만 본다면 b는 DerivedA가 할당된 a를 expand 하고 있기 때문에 b objscope에는 DerivedA.boo()가 들어있다.
    * [o] 하지만 verification 단계에서 `b.boo()` 코드를 본 verifier는 어떻게 할까?
        1. verifier는 onFuncCall()에서 b.boo()가 소속된 scope을 확인한다. ==> with다. b.a 변수에서 등록된 것이다.
        2. b.a의 str 타입을 확인한다. A의 대한 type(native 혹은 mgd)가 나올 것이다.
        3. pack에 질의해서 type* 에 대한 orgObj인 A를 얻어온다.
        4. boo가 A에 있는지를 확인한다.
        5. 마지막으로 실제 b에 boo가 있는지도 확인한다.
        * 쉽게 생각하면 위의 알고리즘인데, 여기서 verifier에 대한 추가요구사항이 나온다.
            1. sub 중, 어느게 with로 expand 중인지 알 수 있어야 한다. expand중인 모든 sub 목록을 알 수 있어야 한다.
            2. node가 with field중 어느것으로부터 나온 것인지 알 수 있어야 한다.
            3. type을 넣으면 orgObj을 가져올 수 있어야한다. ==> verifier가 type<-->orgObj 매핑을 들고 있다.
        * [v] 만약 이름이 없는 with라면? ==> **정적 속성을 띄게 되므로 탐지가 쉽다.****
            * 이경우 어짜피 사용자도 런타임에 수정이 불가능하다. 이름이 없으니까. 그러니 정적인 것이다.
            * 따라서 그냥 objScope에 boo()가 있다? ==> **그러면 정적이니까 올바른 호출이 된다.**
    * [x] 쉬운 초기화 문법은? ==> **별도 항목으로 정리**
> 요약:
>     어려운 문제였다. 딜레마에 있었기 때문이다.
>         * with는 함수 안에서, def 안에서 2군데서 사용한다.
>         * def 안에서 사용할때는 생성자처럼 동작해야 하기 때문에, 각기 다른 객체가 with로 될 수 있어야 했다.
>         * 근데 문제는 with 정적인 것이기 때문에 교체가 되지 않는다는 걸 전제로 해왔다.
>         * 어떻게 하지?
>     1. 해결방법은 def 에서 with를 정의하면 선언으로 간주하고, 함수내에서 이 with를 교체 할 수 있도록 해주는 것이다.
>     2. 다음과 같은 요구사항을 구현해놓아야 한다.
>          1. sub 중, 어느게 with로 expand 중인지 알 수 있어야 한다. expand중인 모든 sub 목록을 알 수 있어야 한다.
>          2. 특정 sub node가 이것을 소유한 me obj 의 scope중에서 with field중 어느것으로부터 나온 것인지 알 수 있어야 한다.
>          3. type을 넣으면 orgObj을 가져올 수 있어야한다. ==> verifier가 type<-->orgObj 매핑을 들고 있다.
>      3. 다음과 같이 parsing 된다.
>          1. parser는 def 안에 with를 보면 하던대로 orgObj는 withOnlyExpandExpr(getExpr("A")) 같은 식으로 해서 넣어둔다.
>      4. preEval이 중요하다.
>          1. 먼저 모든 orgObj를 탐색한다.
>          2. prop의 경우 str의 `type` 을 inference로 특정해서 넣어둔다.
>          3. func의 경우 params의 orgObj에 들어있을 getExpr() 부분을 stackFrame 교체해서 제대로된 orgObj를 얻어와서 교체한다.
>          4. 생성자 앞부분에 withExpand, 초기식들을 모아 둔다.
>      * 참고로, 아직까지는 with는 nullable을 허용하지 않는다. 그러니 preEval에서 with의 type을 확정짓는 것에 아무런 문제가 생기지 않는다.
>      * 참고로2, def 에서 정의한 with보다 구체객체로 with를 교체한다고 하더라도 verifier를 다음과 같이 알고리즘을 구현하면 문제가 생기지 않는 다는 걸 알게되었다.
>           1. verifier는 onFuncCall()에서 b.boo()가 소속된 scope을 확인한다. ==> with다. b.a 변수에서 등록된 것이다.
>           2. b.a의 str 타입을 확인한다. A의 대한 type(native 혹은 mgd)가 나올 것이다.
>           3. pack에 질의해서 type* 에 대한 orgObj인 A를 얻어온다.
>           4. boo가 A에 있는지를 확인한다.
>           5. 마지막으로 실제 b에 boo가 있는지도 확인한다.
>           * 쉽게 생각하면 위의 알고리즘인데, 여기서 verifier에 대한 추가요구사항이 나온다.
* * *
# [o] param을 getExpr()로 하면 문제가 생긴다. => **preEval 단계에서 orgObj를 가져와서 교체한다.**
# [o] 생성자는 ctor이라고 이름을 붙인다. ctor은 키워드다.
# [o] getExpr에 대한 stackFrame 이슈 ==> **preEval단계에서 func, prop을 전수조사해서 orgObj, type을 교체한다.**
* 다음과 같은 코드가 있다고 해보자.
    ```go
    def A




        age := 44
        me(n a): age = n
        me(): age = 0

    def B
        me(n a): // A(n) 하고 싶다... 
        me(): // A() 하고 싶다...
    ```
* * *
# [o] #상속을_지원했을때_verification단계에서_기반클래스_scope에서의_node가_있는지를_알_수_있어야_한다. ==> **parser가 pack::orgObjList를 채워준다.**
* 다음 namu 코드를 파싱할 수 있어야 한다는 것.
```go
def a
    foo() void: ....
def b a
    foo() void: ....
    boo() void: ....
a1 := a()
a2 := b() as a
a2.foo() // b::foo
a2.boo() // <-- 에러가 나야 한다. class a에는 boo가 없기 때문이다. 물론 a2는 boo를 가지고 있다.
         // verification에서 a2변수의 타입이 a라는 걸 인지할 수 있어야 하고,
         // a타입에 boo가 있는지를 비교할 수 있어야 한다.
         // 지금은 a2.get("boo") 처럼 해버릴텐데, 이렇게 하면 이 코드는 error가 아니라 성공으로 간주될 것이다.
```
* [x] 어떻게 구현할 것인가?, ==> **node a 에 대해서 기반클래스 중 하나인 B의 subs를 추출할 수만 있다면, verifier가 처리 가능하다.**
* [u] 어떻게 하면 node a에 대해 주어진 type\<T\>에 대한 scope 를 추출할 수 있는가? 알고리즘은 어떻게 되지? ==> **pack::orgObjList를 추가한다. parser가 채워준다.**
    * 고찰
        * verifier만 탐지를 할 수 있으면 되므로, type<--> orObj 매핑 정보는 외부에 있고 verifier에 전달만 되면 된다.
        * parser가 orgObj을 처음 만드는 곳이다.
        * 이후, preEval단계던, execution 단계던 orgObj가 다른 instance로 교체되지는 않는다.
    1. native건, mgd건 모든 pack은 orgObj list를 갖고 있다.
    2. parser::onDefObj()에서 pack의 tray로 orgObj를 추가해둔다.
    3. verifier는 pack을 입력받도록 한다. verifier.start()할시, pack이 아니라 node가 올 수도 있어야 한다. --> python같은 언어도 eval(`코드블록`) 같은 함수를 제공하니까.
        1. 아니면 verifier.start(pack&) 으로 변경한다. eval 기능을 막는거지.
> 요약:
>     1. node를 실행할 때는 당연히 상위 obj scope에서부터 탐색해서 실행한다. 가상 디스패치가 되는 것이다.
>     2. verification시에는 verifier가 node a에 대해 현재 타입을 참조자에서 가져와서 해당 타입의 scope를 추출한다. 그리고 거기서 해당 메시지를 호출 가능한지를 검토한다.
>     +. 호출가능하다는 건 알았다. 기반타입에 함수가 있는 것이다. 마음의 여유가 된다면, 이때 **해당 함수가 = null 일때, 구체클래스에 해당 함수를 채워 놓았는가를 따져본다.  근데 사실 이거는 객체 정의문을 만났을때 테스트하긴 한다.**
* * *
# [o] 생성자 redirection 방법 ==> **가장 첫줄의 ctor()을 사용한다.**
> 요약:
>     1. ctor은 생성자를 위한 키워드다. 이미 다른 항목에서 논의한바 있다.
>     2. ctor() 안에서 1줄만 허용되며, 그 1줄이 ctor() 호출로 된 경우는
* * *
# [o] mgdType을 만들어야 하는가? str에 mgdType을 넣는 경우도 있어야 하는가? ==> **네. 없으면 verifier가 `a A := B()` 같은 코드를 에러탐지할 수 없다.**
# [o] with를 한 A, B도 상속관계처럼 isSub()가 되는가? ==> **네.**
* A가 부모, B가 자식관계라면 `B.isSub(A) = true` 나오는게 정상이다.
* [x] 하지만 with로 된 건 어떻게 되는가? ==> **isSub 맞다.**
    ```go
    def A
    def B
        with A
    a A := B() // ?
    ```
    * [x] 쉽게 생각하면 a에 B()가 들어가 있을 때 a는 A인 것처럼 처리가 가능한가? ==> **네**
        * A의 subs()가 깔리고 나서 B의 subs()가 올라가니까. 네. 처리 가능하다.
* [x] mgdType과 nativeType을 어떻게 잘 엮을까? ==> **mgdType은 1개의 instance만 존재해야한다는 것을 잘 지켜라. orgObj::getType()에 인스턴스를 둬라. pack::orgObjMap<type*, orgObj> 로 관리해라.**
    * mgdType의 요구사항 및 속성을 다시한번 되짚어보자.
        * nativeType은 싱글톤이다. 반면 mgdType은 싱글톤은 아니지만, 시스템이 orgObj를 unique하게 관리하고 있으므로 orgObj.getType()으로부터 나오는 mgdType은 자연스럽게 unique 속성을 개념적으로 갖는다.
        * 쉽게 말해 mgdType을 가져오려면 `_type.bind(orgObj.getType())` 하라는 얘기다.
        * 시스템은 orgObj를 pack::orgObjList와, pack의 subs()에 놓는 것으로 해결하고 있다.
        * 물론 복제된 mgdObj::getType()을 하면 orgObj::getType()과 같은 instance가 나와야 한다.
        * mgdType은 복제가 되어서는 안된다.
    * nativeType들은 static으로 subs(), supers() type[]를 가지고 있다. 그리고 여기에 객체가 담긴다.
    * *mgdType은 유일하게 1개의 인스턴스만 존재해야 한다* 라는 규정만 잘 지켜준다면, nativeType에서 정의한 getSupers() 같은 API에 값을 채우기만 하면 되므로 간단하다.
    * mgdType을 만드는 순간은, parser에서 만든다.
    * 하지만 mgdType에 상속정보를 채우는 순간은 상속이 정의되는 preEval단계에서 해야 할 것이다.
* [x] with는 다중상속이 가능하다. 즉, 부모가 여러개다. ==> **nativeType의 API를 변경한다.**
    * getSuper()는 비교적 쉽다. 하나가 아니라 여러개가 나가면 된다.
    * native는 다중상속을 쓰지 않을 것이므로 element 1개짜리 배열이 나가면 되는 거고.
    * 문제는 getSupers()다. supers()는 이미 vector가 나가고 있으니까. `vector<vector<type*>>` 으로 변경해야 할 것이다.
> 요약:
>     1. with도 상속관계처럼 다루는 게 맞다.
>     2. native는 1개의 getSuper() 만 전제로 하고 있으므로 개선이 필요하다.
       3. mgdType은 unique해야한다.
       4. orgObj::getType()에 둬라.
       5. pack::orgObjMap<type*, orgObj> 로 관리해라.
# [o] #member_초기화_문법 ==> **with는 런타임에 교체가 가능하다**
* why?
    * with의 경우 assign이 발생해서는 안된다. 그런데 생성자에서는 1번 초기화가 될 필요가 있다는 거지.
    * 즉, 다른 언어들은 이러한 기능이 없기 때문에 assign 기호로도 충분히 가능하다. 그러니 굳이 이러한 초기화 문법이 필요없다.
    * 다른언어와 내 언어는 상황이 다른 것이다.
    * 초기화 문법에 사용되어야 하는 것들에는,
        1. 생성자에 있는 값을 field의 초기화에도 사용
        2. #생성자_redirection_방법
        3. withExpand(==>생성자에 대한 호출)
    * 이 3가지다.
    * [x] 다른 언어들은? ==> **c++, kotlin이 유일하다.**
        * c++ 코드를 보면 이런 것이다.
        ```cpp
        struct A {
            A(int age, string name): _age(age), _name(name) {} // <--
            int _age;
            string _name;
        };
        ```
        * [x] kotlin
            ```kotlin
            class A(private val age: Int, private val name: String)
            ```
        * 그 외의 언어들은 그냥 한줄한줄 적게 끔 하네.
    * 추가 요구사항에는,
        * 이왕 추가하는 김에 간편했으면 한다.
            ```java
            class A
                private int age;
                private String name;
                private float grade;
                A(int newAge, String newName, float newGrade) {
                    age = newAge;
                    name = newName;
                    grade = newGrade;
                }
                // 이렇게 한줄한줄 적으면 불편하잖아.
            ```
        * 그렇게 되기 위해서는 기본적으로,
            1. `,` 을 사용해서 한줄에 여러개를 표현할 수 있어야 한다.
            2. `old = new` 같은 방식이 아니라, **field는 알고 있지? 거기에 들어갈 값이야** 식으로 생략할 수 있어야 한다.
* 고찰
    * 핵심은 2가지다.
        1. 생성자에서만 사용가능한 문법이라는 걸 직관적으로 알 수 있어야 한다.
        2. 간편하게 사용하려면,이미 정의가 된 prop의 이름을 사용할 수 있어야 한다는 점이다.
    ```go
    // 연습을 해보자.
    def Person
        age := 0
        name := ""
        grade := 4.5
        me(age int, name str, grade flt)
    def Tool
        name := ""
        use() void:...
    def Student
        with @Person
        with @Tool
        year int
        classroom int
        me(age int, name str, grade flt, toolName str, newYear int, newClassroom int)
            Tool = Tool(toolName)
            Person = Person(age, name, grade)
            year = newYear
            me.classroom = newClassroom

* 코드를 보면 바로 이해될 것이다.
        me(toolName str, newYear int, newClassroom int)
            Tool = Tool(toolName)
            Person = Person()
            year = newYear
            classroom = newClassroom
    ```
    * 코틀린의 경우:
        ```kotlin
        class Student {
            private var classroom: Int = 0
            private var year: Int = 0
            private var person: Person
            private var tool: Tool

            constructor(age: Int, name: String, grade: Float, toolName: String, newYear: Int, newClassroom: Int) {
                person = Person(age, name, grade)
                tool = Tool(toolName)
                year = newYear
                classroom = newClassroom
            }

            constructor(toolName: String, newYear: Int, newClassroom: Int) {
                person = Person()
                tool = Tool(toolName)
                year = newYear
                classroom = newClassroom
            }
        }
        // 내 기존 코드와 별반 차이 없다ㅋㅋ
        ```
    * 나의 개선버전
        ```go
        def Student
            with @Person
            with @Tool
            year int
            classroom int
            me(Person<-age, Person<-name, Person<-grade, Tool<-toolName, <-year, <-classroom): ret
            me(Person<-age)
            me(Tool<-strName, <-year, <-classroom)
                <-Person()
        ```
1. [d] 기호를 사용한다.
    * 주의할 점은, 이 기능만을 위한 기능이 아니라, 다른 용도로도 사용될 수 있는 폭넓은 기능을 제공하는 일반적인 기호여야 한다.
    * `<-` 기호를 사용한다.
        * `init to` 에 가까운 뜻이다.
        * 생성자에서만 사용한다.
    ```go
    ​￼def Student
        with @Person
        with @Tool
        year int
        classroom int
        me(Person<-age, Person<-name, Person<-grade, Tool<-toolName, <-year, <-classroom): ret
        me(Person<-age)
        ​￼me(Tool<-strName, <-year, <-classroom)
            <-Person()
    ```
    * [?] 매번 Person, Person, Person 붙이는게 귀찮은데?
    * [?] 모양이 이쁘진 않다. <-가. 다른건 없는가?
    * [?] 누가 봐도 생성자에서 이용도로 쓰라고 만든거네. 다른 용도는 없을까?
2. [d] 생성자 밑에 추가로 적용하는 문법을 넣는다.
3. [d] `==>` 를 지원한다. ==> **상속이 사라지면서 super가 없어져버렸다. 어느 func을 먼저 호출해야 하는지 애매하다. 또한 생성자의 super는 with한 애들의 생성자다. field 초기화구문이 아니라.**
    * `==>` 은 예전부터 있던 아이디어이다.
    * overriding한 super함수를 호출해준다. 단, 함수에 넣었던 인자를 넣는 것이다.
    * `==>` 가 앞에 있냐 뒤에 있냐에 따라서 먼저 super를 호출하고 body를 호출하는지 아닌지를 결정한다.
    ```go
    def A
        add(a int, b int): a + b
        me():..
        me(x int, y int): ...
    def B
        with a A()
        a ==> add(x int, y int) // ==> 가 앞에 있으니 a.add(x, y)가 먼저 호출된다.
            print("value is $res!") // 별다른 명시가 없어도 `==>` 에 의한 결과는 res에 담긴다.

        // 위의 코드는 다음과 같다:
        add(x int, y int)
            res := a.add(a, b)
            print("value is $res!")
            return res

        a ==> me(x int, y int)
            // a(x, y) 를 먼저 호출한다는 뜻이다.
    def C
        age := 0
        name := ""
        me(): ..
        ==> me(age int, name str) // 앞에 a가 없으니 이 객체C의 기본생성자가 호출된다
    def D
        with C
        grade := 0.0
        me(C.age int, C.name str, .@grade)
            ret
    ```
    * [ㅌ] 상속이 없어지면서 super가 정해져있지 않기 때문에 overriding을 누구에게 했는지 코드상에 잘 안나타난다. 구현은 어느정도 가능하지만.
    * [d] 생성자에다가 ==>를 쓰면, 그럼 인자가 동일하지 않은 기반클래스 생성자를 호출할 때는??
4. [u] with를 런타임에 교체 가능하게 한다 + 쉬운 초기식 문법을 제공한다.
    * 문제의 핵심은,
        * def 안의 with는 런타임에 수정이 불가능하다.
        * 반면 함수 안의 with는 또 정의가 가능하다.
        * 이렇게 with의 문법이 다르다는 점이 일관성을 떨어트리고 해결방법이 아름답지 않게 만든다.
        * 이렇게 with는 런타임에 수정이 불가능하지만 생성자에서만큼은 수정이 가능해야 하는 문법을 만들어야 한다. 모순적이다. 그게 문법에서도 바로 느껴지는 것이다.
        * 그러니 모순 자체부터를 없앤다.
    * 다음과 같이 한다.
        1. with는 언제든 수정이 가능하다.
        2. with 수정은, 평소 하던대로 `=` 기호를 사용한다. 단 with의 이름은 미리 정의해둬야 한다.
    * 이렇게 하면 추가로 문법이나 기호를 만들지 않아도 된다.
    ```go
    def Student
        with p Person
        with t Tool
        year int
        classroom int
        me(age int, name str, grade flt, toolName str, year int, classroom int)
            p = Person(age, name, grade)
            t = Tool(toolName)
            me.year = year
            me.classroom = classroom
        me(age int)
            p = Person(age)
        me(strName str, year int, classroom int)
            p = Person()
            t = Tool(strName)
            me.year = year
            me.classroom = classroom
    ```
    * 문법이 장황하다고 느낄 것이다. 하지만 이제 with는 그냥 assignment에 불과하므로 초기식을 단축시키는 문법을 만든다면 with든 field든 일괄적으로 간단하게 만들 수 있게 되었다.
    * [x] with의 수정에 대한 verification은 고찰결과 문제가 생기지 않는다고 판단했다.
        ```go
        def A
            foo() void: ....
        def DerivedA
            with A()
            boo() void: ...
            foo() void: ...
        def b
            with a A() // a를 만드는 시점에서 str type은 type inference가 된 A다.
        b.a = DerivedA()
        b.foo() // b::foo()
        b.boo() // --> 에러? 성공?
        ```
    * 기능적으로만 본다면 b는 DerivedA가 할당된 a를 expand 하고 있기 때문에 b objscope에는 DerivedA.boo()가 들어있다.
    * [o] 하지만 verification 단계에서 `b.boo()` 코드를 본 verifier는 어떻게 할까?
        1. verifier는 onFuncCall()에서 b.boo()가 소속된 scope을 확인한다. ==> with다. b.a 변수에서 등록된 것이다.
        2. b.a의 str 타입을 확인한다. A의 대한 type(native 혹은 mgd)가 나올 것이다.
        3. pack에 질의해서 type* 에 대한 orgObj인 A를 얻어온다.
        4. boo가 A에 있는지를 확인한다.
        5. 마지막으로 실제 b에 boo가 있는지도 확인한다.
        * 쉽게 생각하면 위의 알고리즘인데, 여기서 verifier에 대한 추가요구사항이 나온다.
            1. sub 중, 어느게 with로 expand 중인지 알 수 있어야 한다. expand중인 모든 sub 목록을 알 수 있어야 한다.
            2. node가 with field중 어느것으로부터 나온 것인지 알 수 있어야 한다.
            3. type을 넣으면 orgObj을 가져올 수 있어야한다. ==> verifier가 type<-->orgObj 매핑을 들고 있다.
        * [v] 만약 이름이 없는 with라면? ==> **정적 속성을 띄게 되므로 탐지가 쉽다.****
            * 이경우 어짜피 사용자도 런타임에 수정이 불가능하다. 이름이 없으니까. 그러니 정적인 것이다.
            * 따라서 그냥 objScope에 boo()가 있다? ==> **그러면 정적이니까 올바른 호출이 된다.**
    * [x] 쉬운 초기화 문법은? ==> **별도 항목으로 정리**
> 요약:
>     어려운 문제였다. 딜레마에 있었기 때문이다.
>         * with는 함수 안에서, def 안에서 2군데서 사용한다.
>         * def 안에서 사용할때는 생성자처럼 동작해야 하기 때문에, 각기 다른 객체가 with로 될 수 있어야 했다.
>         * 근데 문제는 with 정적인 것이기 때문에 교체가 되지 않는다는 걸 전제로 해왔다.
>         * 어떻게 하지?
>     1. 해결방법은 def 에서 with를 정의하면 선언으로 간주하고, 함수내에서 이 with를 교체 할 수 있도록 해주는 것이다.
>     2. 다음과 같은 요구사항을 구현해놓아야 한다.
>          1. sub 중, 어느게 with로 expand 중인지 알 수 있어야 한다. expand중인 모든 sub 목록을 알 수 있어야 한다.
>          2. 특정 sub node가 이것을 소유한 me obj 의 scope중에서 with field중 어느것으로부터 나온 것인지 알 수 있어야 한다.
>          3. type을 넣으면 orgObj을 가져올 수 있어야한다. ==> verifier가 type<-->orgObj 매핑을 들고 있다.
>      3. 다음과 같이 parsing 된다.
>          1. parser는 def 안에 with를 보면 하던대로 orgObj는 withOnlyExpandExpr(getExpr("A")) 같은 식으로 해서 넣어둔다.
>      4. preEval이 중요하다.
>          1. 먼저 모든 orgObj를 탐색한다.
>          2. prop의 경우 str의 `type` 을 inference로 특정해서 넣어둔다.
>          3. func의 경우 params의 orgObj에 들어있을 getExpr() 부분을 stackFrame 교체해서 제대로된 orgObj를 얻어와서 교체한다.
>          4. 생성자 앞부분에 withExpand, 초기식들을 모아 둔다.
>      * 참고로, 아직까지는 with는 nullable을 허용하지 않는다. 그러니 preEval에서 with의 type을 확정짓는 것에 아무런 문제가 생기지 않는다.
>      * 참고로2, def 에서 정의한 with보다 구체객체로 with를 교체한다고 하더라도 verifier를 다음과 같이 알고리즘을 구현하면 문제가 생기지 않는 다는 걸 알게되었다.
>           1. verifier는 onFuncCall()에서 b.boo()가 소속된 scope을 확인한다. ==> with다. b.a 변수에서 등록된 것이다.
>           2. b.a의 str 타입을 확인한다. A의 대한 type(native 혹은 mgd)가 나올 것이다.
>           3. pack에 질의해서 type* 에 대한 orgObj인 A를 얻어온다.
>           4. boo가 A에 있는지를 확인한다.
>           5. 마지막으로 실제 b에 boo가 있는지도 확인한다.
>           * 쉽게 생각하면 위의 알고리즘인데, 여기서 verifier에 대한 추가요구사항이 나온다.
* * *
# [o] param을 getExpr()로 하면 문제가 생긴다. => **preEval 단계에서 orgObj를 가져와서 교체한다.**
# [o] getExpr에 대한 stackFrame 이슈 ==> **preEval단계에서 func, prop을 전수조사해서 orgObj, type을 교체한다.**
* 다음과 같은 코드가 있다고 해보자.
```go
def A
    ...
    def B
        ....
    foo(b B) void
        ....
```
* 이때 A.foo()의 params의 element인 param은 name, org 2개의 변수를 갖는데, org가 바로 `getExpr(null, "B")` 처럼 parsing 되서 들어간다.
    * params.add( param(name, *getExpr(null, "B")*) )
* verification 때 주어진 인자와 func call의 param이 올바른지 검증한다.
    * `str p = ps[n++].getOrigin().as<node>()`
    * 위의 코드 처럼  geExpr을 eval해서 거기서부터 orgObj을 꺼낸다.
    * 문제는 여기서 발생한다. expr을 eval을 하려면 stackFrame이 있어야 한다.
    * 즉, param의 getExpr()은 무엇을 기준으로 하냐면 **해당 param이 불려지는** stackFrame에 의존한다는 것이다.
        * --> **param을 정의한** 이 아니다!
* 현재 구현버전에서도 재현될 것으로 보인다.
* 코드를 잘 짜서, 실제로 문제가 되는지 확인해보자.
    ```go
    def A
        def B: ... // 1
        foo(b B): ...
    def B // 2
        ...
    boo()
        foo(B()) // 이 B는 2번 B다. 그러나 현재 구현에서는 차이를 구분하지 못할 것이다.
    ```
* 해결방법은?
1. [u] preEval에서 getOrigin()을 해버려서 데이터를 가져와 교체한다.
    * 교체는 쉽다. param은 str로 origin을 가지고 있을 테니까.
    * 일단 eval이 끝나면 쉬울것이다.
    * library 혹은 이미 optimization이 된 namu 코드는 verification, preEval과정이 없게끔 만들어야 한다.
    * 여기서 중요한 점 하나!
        * 모든 요구사항중의 핵심은 **verification에서 체크하기 위해 객체 정의시 str의 type에 정확한 타입이 들어가 있어야 한다** 라는 것이다.
        * 이는 다음 내용을 시사하는데,
            1. verification이 끝난 다음이라면 굳이 type을 알아낼 필요가 없다. str에 node type 넣어도 된다는 얘기다.
                예를들어, 함수내 local 변수 정의시에는 verification일때만 type을 정확히 유추한 str을 정의해서 stackFrame에 넣어야 한다.
            2. verification이나 preEval 단계에서 만들어지는 객체들은 모두 str 혹은 params에 type을 찾아서 넣어줘야 한다.
            3. parser에서는 type이 뭔지 알아낼 방법이 없다. preEval단계에서 obj의 subs() 들을 순회하면서 함수이면 params를, prop이면 prop.str을 갱신해줘야 한다.
            4. optimize 된 library나 pack을 만들때는 파일 맨 앞에 orgObj 트리 구조를, 이름만으로 구성해놓아야 한다. ==> **별도항목**
1. 1의 속도를 최적화해본다: parser가 orgObj에 접근할때는 lazy하게 객체를 만들어 넣는다.
    * 어디에 넣는가? 막연하게 `orgObj지?` 라고 생각하지 않았길 바란다. pack일 수도 있다. 그 정의문이 코드 뒤쪽에 있어서 아직 평가되지 않은 것인지도 모른다.
2. 기존 방법을 그대로 사용한다.
    * 퍼포먼스 문제가 생긴다.
        1. verification에서 canRun()을 할때마다 stackFrame 교체를 해야한다.
        2. 혹시라도 execution단계에서 canRun()을 할때 stackFrame을 교체해야 한다는 것을 잊어버릴 수 있다 ==> 그래서 `node::canRun(obj& objScope)` 로 parameter를 추가해야 한다.
> 요약:
>     1. ADT타입을 with로 지정할 수도 있어야 한다.
>         1. nullable은 아직 모르겠다. 일단은 안하는 걸로. 필요하면 나중에 생각해보자.
>     2. 타입을 다루는데 있어서 전반적인 문제가 하나 있는데 parser 단계에서 타입을 지정하는 모든 부분에 문제가 있다는 점이다.
>         1. Parser는 코드를 읽는 것. 코드는 위에서 아래로 순차적으로. 그러니 위에서 아래에 나올 node에 대한 종속을 가지고 있는 코드를 작성하면 2PASS를 돌 수 밖에 없다.
>         2. Parsing 단계에서는 종속적인 데이터를 채울 수 없는 것이다. 종속적인 데이터의 대표적인 예는 바로 참조자, `str` 이다.
>         3. verification에서는 타입검사를 해야 한다. 그러니 str에 담겨있는 `type` 이 구체타입인지 추상타입인지, isSub 관계인지등을 테스트해야 한다.
>         4. 그러기 위해서는 `type`을 확정지을 수 있어야 하고, `type` 은 orgObj로부터 가져온다.
>         5. 따라서 orgObj가 미리 만들어져 있어야 하는데 orgObj가 코드 아랫부분에 나올 코드라면 만들 수 없다.
>             (그 orgObj가 nested obj인지, pack 밑에 바로 있는지, 그 아랫부분 코드를 파싱하기 전에는 알 도리가 없기 때문이다.)
>     3. 그래서 preEval 단계에서, 프로그램 시작시 정의되어야하는 모든 node를 대상으로, 그 node 중 `type` 을 가진 sub들을 찾아  `type`을 채워넣는다.
>         * 주로 2개다.
>             1. prop이다: prop을 물고 있는 str을 찾아서 이 str의 `type`을 inference해서 외부에서 넣어주면 된다.
>             2. func이다: params 에는 getExpr()이 있는데 이 getExpr()은 func을 가진 orgObj를 me로 하였을때의 stackFrame을 기준으로 get을 하는 것들이다.
>                 그러니 stackFrame을 그렇게 교체해서 얻은 orgObj에 대한 str로 바꿔주면 된다.
>                 물론 이때의 str의 `type`은 node가 아니라 orgObj의 type으로 되어야 겠지.
>     4. 참고로 parser는 지금처럼 prop과 func의 params를 getExpr()를 사용해서 채워넣는다.
* * *
# [o] 간편한 초기화 문법 ==> **이미 만들어진 prop에 값을 넣는 용도로만 사용한다.**
* me.a = b 를 단축시키는 것이 목표다.
* `a = b` 를 단축시키면 `a` 가 된다. 그얘기는 a와 b가 같을때 동작하는 문법이어야 한다는 얘기다.
* 생성자의 인자는 어짜피 명시를 해줘야하기 때문에 `생성자인자의 명시 <==> 자동으로 prop에 할당` 으로 동작한다는 아이디어가 좋다.
```go
def A
    age int
    _name str
    grade := 0.0
    ctor(age, name, grade): ret

    // 위의 코드는 아래와 같다:
    ctor(age int, name str, grade flt)
        me.age = age
        me.name = name
        me.grade = grade

def B
    a A
    with a2 := A()
    ctor(a.name, a.age, a.grade, a2.name, a2.age, a2.grade) // 이렇게도 된다.
        a2 = A(1, "wow", 4.5) // 하지만 a2자체를 교체하고 싶다? 그러면 이렇게 하는 수 밖에 없다.

def C
    with a A // nullable은 올 수 없다.
    // super의 생성자로 redirection하고 싶다면?
    ctor()
```
* 단순히 `a.age, a.name, a.grade` 하면 되는거 아냐? 싶은가? 그렇게 하면 안된다.
* a의 생성자를 호출하도록 해야지, prop을 외부에서 할당하도록 허용하면 안된다.
* 이 문법의 의의는 생성자를 쉽게 짜는 것이다. 그래서 다른 생성자를 호출하는 것에는 효과가 없다.
* [u] with의 생성자를 호출하는 코드는 어떻게 해야 하는가? ==> **지원해주지 않는다. 지금도 충분히 복잡하다.**
    * 사실 해줘야 하는가? 부터 의심이 들긴 한다. 그 어떤 언어도 이걸 지원해주진 않는다.
```go
// with의 생성자로 redirection 시키는 간편화 문법을 만들어 본다면?
def B
    with a A
    ctor(age int, name str, grade flt, name)
        // me.name과 name에서 보면 알듯이 `.` 가 붙는 경우는 인자가 만들어지지 않는다. name str 로 인자가 만들어지는 대신에 assign이 동작하는 것이다.
        // 만약 .name을 접근하고 싶다? 그러면 me.name으로 사용하자.
        a = A(age, name, grade) // 원래 이렇게 하길 의도했다.
    name := "wow"

    me()
```
* [u] 알고리즘은 syntactic sugar로 한다.
    1. parser는 onFunc() 에서 func의 param을 정해야한다.
    2. parser는 onFunc에서 args는 arr& 로써 받아들인다. 일반적으로 `age int` 라고 하면, `arr[0] = defVarExpr("age", getExpr("int"))` 와 같은 식으로 들어가게 된다.
    3. parser는 list에 defVarExpr가 아니라 getExpr로 들어있을 경우, `a int` 가 아니라 `a` 라고만 적은 것이다. 이 경우 2가지를 처리해준다. parser가.
        1. `param.add(param("$unamed_param_1", getExpr("a"')))` 추가한다.
        2. 생성자 앞부분에 `assignExpr("a", "$unamed_param_1")` 을 추가한다.
    4. preEval단계에서 모든 함수의 params는 orgObj로 교체된다.
        1. 위 예시를 바탕으로 예를 들면 `getExpr("a")` 을 본 preEvaluator는 me로 stackFrame을 교체한 상태에서 getExpr을 eval한다. 결과 나온 orgObj안의 'a' 로 param과 str의 `type`을 교체한다.
        2. 이때 me의 objScope이 아니라 pack에서 접근한 경우 에러를 내야한다.
* [x] 함수 파싱의 난이도가 더 증가되었다. 함수호출과 구분이 또 힘들어진다. 괜찮은가? ==> **괜찮다. 이미 parser는 해당 부분을 `list: '(' expr* ')'` 라고 정의해놓고 verifier에서 검증한다. **

> 요약:
>     1. 간편 초기화 문법은 me의 prop에 assign 하는 것을 생략해주는 문법이다.
>         *이미 만들어진 instance나 refer에 값을 assign 하는 것이지, 객체를 생성해서 넣는게 아니다.* 예를들어 prop `a A?` 가 있을 때 `a = A(인자1, 인자2)` 같은 코드는 생략이 불가능하다.
>         이 문법으로는 객체를 만들 수 없기 때문에. 그러니 이럴때는 직접 객체를 생성하자.
>    2. 사용법은, 함수의 parameter를 정의할 때 `A B` 같은 defVarExpr 가 아니라 `A` 같은 getExpr 로 정의하는 것이다.
>        parser는 문법적으로 이미 expr이기만 하면 받아들이기 때문에 bison 에러는 생기지 않는다.
>        verifier에서 defVarExpr인지, getExpr인지, 2가지 패턴 중 하나가 아닐 경우에만 에러로 탐지한다.
>    3.  알고리즘은 syntactic sugar로 한다.
            1. parser는 onFunc() 에서 func의 param을 정해야한다.
            2. parser는 onFunc에서 args는 arr& 로써 받아들인다. 일반적으로 `age int` 라고 하면, `arr[0] = defVarExpr("age", getExpr("int"))` 와 같은 식으로 들어가게 된다.
            3. parser는 list에 defVarExpr가 아니라 getExpr로 들어있을 경우, `a int` 가 아니라 `a` 라고만 적은 것이다. 이 경우 2가지를 처리해준다. parser가.
                1. `param.add(param("$unamed_param_1", getExpr("a"')))` 추가한다.
                2. 생성자 앞부분에 `assignExpr("a", "$unamed_param_1")` 을 추가한다.
            4. preEval단계에서 모든 함수의 params는 orgObj로 교체된다.
                1. 위 예시를 바탕으로 예를 들면 `getExpr("a")` 을 본 preEvaluator는 me로 stackFrame을 교체한 상태에서 getExpr을 eval한다. 결과 나온 orgObj안의 'a' 로 param과 str의 `type`을 교체한다.
                2. 이때 me의 objScope이 아니라 pack에서 접근한 경우 에러를 내야한다.
      4. prop이 nullable이어도 이 기능은 정상동작한다.
      5. 이 문법을 쓸때는 getExpr()로 나온 obj가 반드시 me의 objScope에 속해야 한다. pack/local이 아니라.
          1. 그래서 getExpr()이 가져올 수 있는가 없는가를 그냥 stackFrame에 질의하면 안된다. 적어도 pack은 제거한 상태에서 질의하자.
          2. pack에 있는 prop값이 갑자기 변경되거나 하면 큰일이기 때문에 막는것이다.
      6. 생성자 뿐만 아니라 함수기만 하면 다 사용한다.
# [o] 기반클래스 생성자 호출 방법 ==> #member_초기화_문법 로 해결!

* why?
    * 코드를 보면 바로 이해될 것이다.
    ```go
    def A
        age := 44
        me(n a): age = n
        me(): age = 0

    def B
        me(n a): // A(n) 하고 싶다...
        me(): // A() 하고 싶다...
    ```
* 순수하게 문법적인 문제다. 구현은 가능한 상태다.
* 문법적으로 깔끔하고, 다른 문법과 일관성이 있었으면 좋겠다.
* 고찰
    * 초기식의 핵심적인 의미는 뭘까.
        * 모든 생성자에 일괄적으로 적용되는 사항들이다.
        * 생성자는 케이스별로 특수하게 적용되는 코드들이고.
    * 초기식에 사용되는 문법은 선언과 값의 할당이 분리되어 있었다.
        * `age int` 는 변수 age의 정의.
        * `age = 5` 는 값의 할당
    * 추가 요구사항: parser가 AST를 만들 수 있어야 한다.
        * preEval 단계에서 with가 expand 되어야 한다. 알고 있지?
        * 그러니 parser가 AST를 만들 수 있어야 한다.
        * 즉 문법이 모호하지 않아야 한다는 것이다.
    * 추가 요구사항: derived 객체를 넣을 수 있어서는 안된다.
        * 당연한 얘기다. 현재의 with 알고리즘은 각 symbol 별로 expand 할 수 없기 때문에,
        * derived 객체를 넣으면 파생객체의 모든 메소드가 다 expand 된다.
    * 추가 요구사항: delegation 용도로도 with를 쓸 수 있으면 좋겠다.
1. [d] 각 생성자 내부에서 with ==> **진짜 with인지 상속을 위한 with인지 parser 레벨에서 구분이 어렵다.**
2. [d] 상속의 문법을 다시 꺼낸다.
3. [d] `with A` 로 한다. ==> **생성자 안에 A를 사용하는 코드가 있을때 진짜 A를 쓰는 건지, with에 넣을 A를 말하는 건지 구분이 어려움.**
4. [d] `A with B` 로 한다.
5. [*d*] `with B, @B()` 로 한다.
    * why
        * 상속을 `with` 로 구현하면 뭐가 안좋냐면, `super` 를 쓸 수 없게 된다. 1개라고 정해진것도 아니고, with가 static 목적인지 상속 목적인지 모르니까.
        * 그러니 뭔가의 이름을 붙여서 부를 수 있는 수단은 존재해야 한다.
        * 그래서 4와 비슷하지만 `@` 축약문법도 제공하면 어떨까?
    ```go
    def B
        me(): ...
        me(n int): age = n
        age := 2
        hoo() void: ...
    def A
        b with B // orgObj인 B를 expand하는 b라고 이름을 붙인 것이다.
                 // B는 완전객체이기 때문에 생성자에서 B를 expand하지 않으면 기본적으로 orgObj인 B가 들어갈 것이다.
        with singObj
        with D
        with C() // 이건 초기식이다. 모든 생성자에 C()를 만들고 여기서부터 with expand가 되는 코드가 들어간다.
        me(@int) // 여기서 쓰인 @는 축약식이다. int는 orgObj int 가 아니라 int라는 이름의 int 변수다.
                 // me(int int)와 같은 코드다.
            // expand 코드는 항상 생성자 앞부분에 와야 한다. 이유가 있다.
            // 일단 부모객체를 먼저 생성자호출 하고나서, 자식을 돌려야 하지? with도 마찬가지다.
            // 그런데 expand가 중간에 올 수 있다고 여지를 남기면, 사용자는 초기화되지 않은 변수에 접근하는 코드를 짤지도 모른다.
            // 그러니, 생성자에 들어오면 미리 expand부터 해야 한다.
            // expand 순서를 반드시 지켜야 한다.
            //D.print() err! D는 이 생성자 통틀어서 expand되지 않았다. 그 말은 orgObj D에 대한 expand를 자동으로 해준다는 뜻이다.
                     // 그러나, 그렇다고 해도, 아직 expand 블록이 끝나지 않았기 때문에 안된다.
            //b() --> err! b객체를 만들려는 것인지 with를 expand하는 것인지 구분이 안간다.
            //@singObj(random()) --> err! 아직 @b가 되지 않았다. 이거부터 해야한다.
            b(n) // ok. b(n)으로 생성된 객체가 expand된다.
            ::singObj(random()) // ok. random()은 derivedSingObj가 반환될 수도 있다. 그러나 결국은 singObj의 복사생성이 발생한다.
            //b = B() --> err! with객체 이기 때문에 할당이 불가능하다.
            // @D는 언급이 없으므로 with D로 확정된 것이다.
            //@c() --> err! @C는 C()로 이미 되어 있다.
            hoo() // ok
            b.hoo() // ok
        boo()
            //@b() --> err! 일반 함수에서 with에 넣을 수 없다.
    def singObj
        foo() void: ...
    foo(n int) singObj
        ret if n % 2
            singObj
        else
            def derived
                with singObj
                foo() void: ....
                koo() void: ..
    ```
6. [u]  --> #member_초기화_문법 을 사용한다.
    ```go
    def A
        age int
        ctor(): ...
        ctor(age): ... // 초기화단축 syntax

    def Util
    def B
        with Util()  // 만약 B가 모든 생성자에 걸쳐서 Util 부모객체에 전달할 생성자인자가 1종류만 있다면,
                     // 이렇게만 해 두면 충분하다.
        with a A // 나중에 교체될 것이다. 이름 a를 붙여놓게 중요하다.
        with @A // 이렇게도 된다. with A A와 같은 것이다.
        ctor(): a = A()
        ctor(age int)
            doSomething()
            a = A(age) // 생성자 호출이 나중에 나와도 된다.

    ```
* * *
# [o] 상속을 with로 구현 가능한가? ==> **예**
* * *
# [x] `@` 에다가 초기식을 넣을 수 있어야 한다. ==> **@는 제거되었다.**
```go
def A
    ....

@A // A A와 같다.
@A := 22 // ok. A A := 22와 같다.
a2 A := 22 // ok.
a2 A = 34 // err. 다른 언어들이라면 이렇게 하겠지만, namu는 변수의 정의를 표현할때는 := 를 써야 한다.
@A = 23 // err. A A = 23 과 같다.
```
* 참고로 `a A := val` 은 그저 2줄짜리를 한줄로 만든 편의기능정도로 생각하기 쉽지만, 이게 반드시 되어야 ADT에 대한 with 지원이 가능해진다.
    * 꽤 의미가 큰 문법이다.
* * *
# [x] nullable인 `@`을 만들 수 있어야 한다. ==> **@는 제거되었다.**
```go
def a // 뒤에 ()가 없으니 불완전객체다.
    do() void

@a? // a a? 와 같은 코드다.
a a? // a a? := null 과 같은 코드다.
a.do() // runtime exception
a?.do() // 아무일도 발생하지 않는다.
a = a() // ok
a.do() // ok.
a?.do() // do가 실행된다.
```
* * *
# [x] pack/fileScope과 objScope은 서로 중복을 허용하면 안된다? ==> **중복허용한다. 다른언어도 이건 지원한다**
```go

age := 0

def A
    age := 0

def B
    with A()

```
* * *
# [o] 큰 그림에서의 with 문제 ==> **with는 import도 겸한다. with는 블록문을 넣지 않으면 전체 scope에 적용한다.**
* with는 엄연히 block 문이 존재했다.
    * 그런데 def 안에 쓰이는 with는 성격이 아무리 비슷하다지만, 현재 scope으로 expand하는 것이다. with만의 블록문이 없다.
* [o] import는 이 def 의 with와 닮았다. ==> **아니, 같다.
    ```go
    // 1
    pack test
    import math
    math.doSomething()
    import console.*
    print()

    // 2
    pack test
    math.doSomething() // project 파일에서 import를 이미 한 것이다.
    with console
    print()
    ```
1. [d] with는 기본적으로 여기에 expand하는 것이고, 추가 문법을 해야 블록문이 생기도록 한다.
    1. [d] 블록문을 만드는 키워드/기호를 추가한다.
        ```go
        // 기존:
        with a
            doSomething()
        // 신규:
        block
            with a
            doSomething()
        ```
2. [u] with는 원래 그런 구문이라고 소개한다. ==> **어. 이렇게 하자.**
    * 블록문을 넣으면 그 블록문 안에서만 유효하고,
    * 블록문을 넣지 않으면 해당 scope내 전체에서 유효하고.
    ```go
    with a
        doSomething()
    with a
    doSomething()
    ```
    * [v] 그러면 사용자들은 `def` 안에서도 블록문이 들어간 with를 쓰려고 하지 않을까? ==> **def 안에서는 선언만 허용된다고 예외처리하면 되겠지.**
    * [v] with를 연속해서 쓰면 좀 헷갈릴까? ==> **크게 오해할 부분은 아니다**
        ```go
        with a
        with b := B()
        with C()
            doSomething() // 어때? a, b가 여기서 expand된것처럼 보이나?
            ok()

        // 참고로 하나의 block안에서 with를 여러개 하려면...
        with C()
            with a
            with b := B()
            ... // 하면 된다.
        ```
3. [d] 새로운 키워드를 추가한다.
4. [d] def 뒤에 with를 넣게끔 한다. 그러면 자연스럽게 블록문이 생긴것처럼 보이지?
    * [?] import는 어떻게 하지?
* * *
# [o] #현재_구현으로는_ADT는_with가_안된다 ==> **생성자에서 채워준다면 prop 초기식에는 nonnullable 타입이라도 비워도 괜찮다.**
* why?
    ```go
    def Base // 불완전 객체다.
        age := 0
        ctor(age): ..
        foo() void:...
    def dummy
        with Base(5)

    def Derived // Base에서 상속받게 하는 방법은?
        with b Base // <-- 1: 에러.
    ```
    * 1을 보면 생성자에서 a를 교체하기 위해 이름을 붙인 것이다. 문제는 A는 ADT이므로 일반적으로 `a A` 처럼 쓸 수 없다. 이건 `a := A()` 혹은 `a A? = null` 와 같은 것이니까.
        * 그래서 1은 에러다.
    * 우리는 nullable은 with에 허용하지 않는다고 했었다. verification, preEval 구현이 어려우니까.
    * 그래서 `with a A`도, `with a A?` 도 불가능 한 것이다. A 는 반드시 ADT가 아닐 경우에만 사용이 가능하게 제한이 걸린 셈이다.
    * 해결방법은?
1. [d] 어떻게든 with a A?도 가능하게 한다.
    ```go
        with b Base? // 2: nullable로 한다.
        with b Base := dummy() // 3: dummy
        with @Base := dummy()
        ctor(age int): a = Base(age)
    ```
2. [u] 불완전객체의 with 정의는 가능하게 한다. 단 생성자에서 해당 with prop에 non nullable인 참조를 반드시 채워넣어야 한다.
    * 예전에도 한번 조사했던 상황인데, 이걸 허용하는 프로그래밍 언어는 단 하나도 존재하지 않는다. ==> **고찰결과, 그래도 이걸 지원해주는게 가장 깔끔하다는 걸 알았다.**
    ```go
    // 예시:
    def Base // 불완전객체
        ctor(n int): ...
    def Derived
        with Base...
        ...

    def A
        with @Base // nonnullable type인데 초기화가 없음. 그래도 ok.
        ctor(n int)
            Base = Derived(5) // Base는 non nullable이지만 생성자코드 내에서 참조를 채워넣기만 한다면 문제 없음.
        ctor()
            //
    // 참고로, 대체 방법1:
    def A
        with b Base := dummy() // 3: dummy
        with @Base := dummy()
        ctor(age int): a = Base(age)
    ```
    * [u] 아, 그리고 nonnullable type인데 초기화를 하지 않는 에러도 verification에서 잡아야 한다.  혹시나 잊었을까봐 컨셉을 되새겨 주자면,
        ```go
        a int // 0이 들어간다.
        a A // A()가 a에 들어간다. A가 A() 생성자가 없다면 에러다.
        a A? // A타입인 null이 a에 들어간다.
        ```
        * 이때 `a A`를 보면, 이 코드가 함수 내에서 사용된다면 바로 에러를 내보내지만,
        * def 안에 prop 초기화에 들어가 있으면 생성자 코드까지 다 실행한 후에 이 a A가 그대로 null을 가지고 있다면 에러를 내보내야 한다는 것이다.
    * 구현은 그리 어렵지 않을 것 같다. 이렇게 하면 된다.
        * parsing 단계에서 `a A` 즉, `defVarExpr` 이 발견되면, 일단 defVarExpr을 그대로 만들어서 내보낸다.
            * 이때, parser::onVisit(defBlock& blk) 은,  blk을 순회하면서 defVarExpr이 보이면 얘로부터 orgObj를 뽑아내는 코드가 이미 구현되어 있다. 나는 이걸 조금 수정할 것이다.
            * defVarExpr이 *`a A?` 처럼 nullable이거나* 아니면 *A가 불완전객체면* 일단 null을 넣어둔다.
        * verification단계시, onVisit(obj)에 도착하면 모든 생성자에 대해서, 평가를 먼저 수행한다.
            * 생성자에 안에서 발생하는 assignExpr을 만날때마다 nullable prop에 값을 넣었는지 안넣었는지를 체크하도록 만든다.
        * 그리고 각 생성자가 끝나면 모든 non nullable type인 prop이 저마다 값을 가지고 있는지 체크한다.
* [?] 만약 상속 depth가 3이고, abstract이면서 불완전객체고, 그러면서도 객체마다 다른 값을 가져야 된다면 어떻게 되지??
    ```kotlin
    abstract class Context {
        val attr: Int = 0
        abstract fun getResourceId(): Int
        fun applyImage() {
            ImageProcessor().process(getResourceId() + attr)
        }
        constructor(newAttr: Int) {
            attr = newAttr
        }
    }
    abstract class View : Context {
        constructor(newAttr: Int) {
            attr = newAttr
        }
    }
    class Button : View {
        constructor(): super(22) {}
        fun getResourceId(): Int {
            return 22
        }
    }
    ```
    ```go
    def Context
        attr := 0
        getResourceId() int = null
        applyImage() void
            ImageProcessor().process(getResourceId() + attr)
        ctor(attr): pass
    def View
        with @Context()
        ctor(attr int)
            Context = .Context(attr) // <-- 여기가 핵심
            //Context().applyImage() // 에러. prop에 채우는 것과 아무런 관련이 없다. 에러로 취급해야 겠지?
    def Button
        with @View
        ctor(attr int)
            View = View(attr)
        getResourceId(): 22
    b Button
    b.applyImage()


    // 2
    def Context
        +attr := 0
        getResourceId() int
    ```
    1. [?] attr도 abstract 하게 변경한다.
        * 문제의 원인을 먼저 잘 곱씹어보자.
            * Context와 View가 서로 연관되어 있다는 걸 표시해줘야 한다.
            * Context는 각 객체별로 독립적으로 존재하는 prop이 존재해야 한다. 객체간에 공유하지 않는다.
            * 이 prop은 궁극적으로는 Context를 상속하는 객체들이 갖는 모양새가 되어야 한다.
            * Context는 객체별로 독립적으로 View에 존재해야 하지만, Context 객체를 만들수는 없다는 점이다.
            * 즉 요약하면, **Context는 객체별로 존재해야하는 instance 종속된 prop이 존재해야하지만, Context상속하는 객체에게 Context를 복제해서 넣는 방법이 없다.**
        * 그래서, 종래의 방법으로는 불가능하고 다른 방법을 제시한다.
        * 중요한 핵심은 abstract는 궁극적으로 *interface* 라는 걸 상기시키는 것이다.
        * 그러니 attr도 하위객체 어딘가에 있다는 정도로 넘어가면 된다.
        * 다음과 같이 될 것이다.
        ```go
        def Contextable // abstract는 interface다. 그러니 able을 붙이자.
            attr int // 그러면 prop이 interface 적으로 변한다. 실제로 이 객체에 attr이 있는게 아니다.
            patcher Patcher? // 이것도 마찬가지.
            applyImage() void // 그러나 실제를 적으면, 실제로 이함수가 이 객체에 들어간다.
                imageProcessor.process(resourceId + attr)
            ctor(attr): blank
        ```
    2. [d] 생성자 안에서 abstract한 prop에 assign하는 순간에만 abstract 객체의 복제를 허용한다?
        * 근데, 이건 구멍이 너무 많다. 당장에 누군가는 다음과 같이 꼼수를 찾으려 할 것이다.
            ```go
            def AbstractObj
                ...
            def View
                with @Context // 나중에 채운다는 뜻
                ctor(attr int)
                    Context = .Context(AbstractObj().foo()) // AbstractObj::foo()를 호출하고 싶어서 이 AssignExpr을 응용해본 것이다.
            ```
        * 이 구멍을 막는 방법은 존재할 지 모르지만, 거의 AI를 빌려와서 독해하고 코드를 이해하는 수준일지도 모른다.
        * 매우매우 귀찮을 것이다.
    3. [?]
> 요약:
>     생성자에서 nonnull type을 지정하고 싶지만, 이 참조자에 들어갈 객체는 여러 생성자들이 저마다 다른 객체로 넣어야 하는 경우가 있다.
>     이때, 생성자에서 채워줄것을 전제로 하고 def 의 prop 초기화를 비워도 괜찮다.
>     초기화를 비우면 non null type에 대해서도 null이 들어갈 것이다.
>     verification때 생성자 호출 전에 assign을 해야할 proplist를 생성한 뒤에 생성자를 verification 한다.
>     그리고 각 생성자가 끝났을때 과연 몇개의 proplist를 assign 했는가를 따진다.
>     1개라도 assign 되지 않은 proplist가 있을 경우 에러로 간주한다.
>     자세한 알고리즘은 이렇다:
        1. parsing 단계에서 `a A` 즉, `defVarExpr` 이 발견되면, 일단 defVarExpr을 그대로 만들어서 내보낸다.
            * 이때, parser::onVisit(defBlock& blk) 은,  blk을 순회하면서 defVarExpr이 보이면 얘로부터 orgObj를 뽑아내는 코드가 이미 구현되어 있다. 나는 이걸 조금 수정할 것이다.
            * defVarExpr이 *`a A?` 처럼 nullable이거나* 아니면 *A가 불완전객체면* 일단 null을 넣어둔다.
        2. verification단계시, onVisit(obj)에 도착하면 모든 생성자에 대해서, 평가를 먼저 수행한다.
            * 생성자에 안에서 발생하는 assignExpr을 만날때마다 nullable prop에 값을 넣었는지 안넣었는지를 체크하도록 만든다.
            * [?] 이 체크방법은???
        1. 그리고 각 생성자가 끝나면 모든 non nullable type인 prop이 저마다 값을 가지고 있는지 체크한다.
* * *
# [o] abstract override 문제 ==> **def 안에서는 abstract obj도 접근 가능하다.**
* 이런 코드를 만들 수 있는가?
```kotlin
abstract class Context {
    ...
    abstract fun getResources(): Resource
    fun foo() {
        getResources().doSomething()
    }
}
class View extends Context {
    ....
    abstract fun updateView()
}
class Button extends View {
    fun updateView()....
    fun getResources(): Resource {
        return ContextFactory.make()
    }
}
Button().foo()
```

1. [d] 단순히 `abstract fun` 이란 *이 func을 body를 채우기 전까지는 이 객체를 생성하지 못하도록 verify error 내보낼 뿐* 이라고 한다면? ==> **아니, 그러면 verifier가 정보를 다 기억해야 하잖아.**
2. [u] 호출하면 런타임에러가 발생하는 dummy func을 만들어둔다.
    * 이렇게 하면 verifier도 있는 정보만 검색해서 체크할 수 있다.
    * verifier는 함수별로 abstract가 발견되면, 보다 파생객체의 scope에 이 abstract와 동일한 signature를 지닌 함수가 있는지 (== 즉, abstract를 채웠는지) 체크해야 한다.
```go
def Base // abstract func이 있으므로 불완전, 즉 대문자로 이름을 지은 것이다.
    getResources() Resource = null // ok. 이제 Base는 불완전객체여야 하고, Base() 를 호출하지도 못한다.
    _n := 5
    foo() void
        getResources().doSomething(n)
def View // 이름을 대문자로 해줘야지? 기본생성자가 없기 때문이다. 불완전, abstract 인셈.
    with Base() // def안의 with에서는 abstract obj라고 할지라도 객체복제가 가능하다. 다만 View도 abstract가 될 뿐이다.
    ctor(ctx: Context): ....
    // with Base 이렇게도 된다.
def Button // 이름은 대문자이지만, 이 클래스는 abstract가 아니게 할려고 한다.
    // with _@View // 이렇게 하면 에러다. def 안에서 with는 abstract는 무시되도, incomplete은 유지되거든.
    with _@View() // 이미 말했듯이 def안의 with에서는 abstract로부터 객체복제가 가능하다.
    updateView() void: ....
    getResources()
        contextFactory.make() // override하고 있다.
Button().foo()
```
> 요약:
>     abstract라는 건 엄밀히 말해서 없다. incomplete obj일 뿐이다.
>     def 안에서 with를 할때는 incomplete obj도 넣을 수 있다, 이미 다른 항목에서 다루었다. 생성자 안에서 제대로 참조를 채워주기만 하면 된다.
>     abstract func을 적으면 parser는 일단 dummy func을 만들어서 채워는 준다.
>     dummy func을 호출하면 런타임 에러가 발생한다.
>     verifer는 dummy func이  호출될것 같으면 컴파일 에러를 내보낸다.
* * *
# [x] `@` 문법은 `A?` 처럼 nullable에는 어떻게 적용하는가? ==> **사용가능하다. packScope에 접근할때는 `.`을 앞에 붙여라.**
1. [u] A?나 A나 같은 것이다? ==> **예**
    * 반대로 물어보면 된다. A?와 A가 같은 코드에 def 될 수 있을 수 있는가? 아니다. ?는 속성인 것이다.
    * 따라서 다음처럼 된다.
    ```go
    def A // 불완전 객체
        ctor(n int): ...
    a A // a = null
    A A // ok. A = null
    @A // ok. A = null
    A = null // ok
    A = A() // ????

    def B // 완전객체
    b B // ok. b는 객체
    @B // ok. B는 객체
    B = B()
    // 원본 B에 접근하고 싶을때는??
    B = .B() // 앞에 . 을 넣으면 packScope에서 찾는 것이다. thisPack.B()와 같은 것이다.
    ```
> 요약:
>     1. nullable 타입에도 `@` 을 사용할 수 있다.
>         1. non null type과 똑같다. `@` 는 `A A` 로 syntactic sugar 하면 된다.
>         2. nullable이면 `A A?` 가 되는 것 뿐이다.
>     2. null인 객체에 함수를 호출하면 runtime exception이다. 컴파일 에러는 아니다.
>     3. 마찬가지로 null인 nullable type에 생성자를 호출하면 runtime exception이 발생한다.
>     4. 그냥 B을 적으면 scopeStack 위에서부터 찾는다. localScope부터 찾겠지.
>     5. me.B를 적으면 objScope부터 찾는다.
>     6. .B 라고 앞에 `.` 을 붙여서 적으면 thisPack의 packScope부터 찾는다.
* * *
# [o] with의 순서를 지켜줘야 한다. ==> **네. 그런데 모호성 경고 나간다. with를 프로퍼티로 구현하고, prop에 set()이 불려지면 교체하는 코드를 구현한다.**
```go
def B
    foo() void: ...
def Util
    foo() void:...
def A
    with @Util // Util이 먼저지? 근데 아직 with는 하지 않았다. 생성자에서 하면 되므로 유효한 방법이다.
    with b B()
    foo() void: ...
    attachB(@B) void
        b = B
    ctor()
        doSomething()
        ...
        b = B(5)
        Util = Util(b)
```
* 이렇게하더라도 객체 A의 scope 구성은,
         packScope <-- fileScope <-- Util <-- B <-- A 가 되어야 한다?
    * `attachB()` 를 통해서 런타임에 변경할지라도 저 구조는 유지가 되어야 한다?
1. [?] 유지되지 않아도 상관 없도록 한다?
    * 전제 조건이 A 안에 with로 B, C가 있을 경우, B가 먼저든, C가 먼저든 괜찮도록 하는 건 어떠한가?
    * 가장 문제가 될 것은 B와 C에서 같은 이름을 가진 sub가 있을 경우 어떻게 하느냐이다.
    * 이 경우 에러를 내보내고 모호성 오류를 내보내는 건 어떨까?
    * 하지만 이렇게 한다고 하자. 그리고 attachB()를 호출했다고 하자.
    * 그러면 이전에 사용하던 B의 objScope을 A의 objScope에서 제거하고, B보다 뒤에 있을 objScope을 B보다 앞에 있는 Util과 연결해주는 작업이 필요할 것이다.
    * 그럴러면 결국 런타임에 obj에게 with 중 하나의 참조자를 건내주면 이게 어느 objScope에 있는지, 그 앞뒤로 뭐가 있는지를 알 수 있어야 한다는 것이다.
    * 근데 이 작업이 가능하다면, with의 순서를 지켜주는 것조차 매우 쉽게 된다.
    * 즉, **유지되도록 상관없도록 한다고 해도, 결국 요구사항은 똑 같다.**
    * 결국 컨셉의 문제이지, 구현 가능성을 논할 필요는 없다. 어짜피 해줘야 한다.
2. [u] 유지되도록은 해주겠다.  대신 이름충돌해서 모호성 오류가 생길 것 같으면, 가장 나중에 적은 게 우선되게 끔 하되, 경고를 잔뜩 내보내는 것으로 하자.
* [u] 어떻게 구현하지? ==> **프로퍼티로 해결**
    1. [u] 프로퍼티 구현방법으로 해결한다. ==> **별도의 항목으로 논의**
        * 위의 예에서 A 객체를 얻어온 뒤에 attachB()를 통하지 않고도, a.b = B() 로도 교체가 가능하다는 점에 눈치를 채야한다.
        * 즉 prop을 변경했을 뿐인데, prop을 소유한 obj 전체에 영향을 미치게 된다.
        * 그리고 이 동작은 정확히 Property의 요구사항이다.
        * 따라서 프로퍼티를 먼저 구현해놓고 with는 프로퍼티의 하나의 형태인것처럼 하면은 로직은 합칠 수 있다.
> 요약:
>     위의 코드를 예로, objScope을 관계를 계산하면, Pack <-- File <-- Util <--B <-- A 순이 된다.
>     런타임에 def prop중 with로 된 것들의 참조를 변경할 수 있어야 한다.
>     이때 런타임에 B의 참조를 변경해도, 동일하게 Pack <-- File <-- Util <-- B <-- A의 순이 유지될 수 있어야 한다.
>     구현은 프로퍼티의 한 종류로써 구현한다. 자세한 내용은 별도 항목 참조
* * *
# [o] @가 with는 같이 적용이 안된다. ==> #현재_구현으로는_ADT는_with가_안된다 로 해결함.
```go
def A // 불완전, 구체 객체다.
    ctor(age int): ...
    ctor(name str): ...
def B
    with @A // ok. 에러는 유예된다. 모든 생성자 안에서 반드시 채워줘야 한다.
    ctor(age int): A = A(age) // --> OK.
    ....
```
* * *
# [o] incomplete org obj 접근하는 버그 수정
```go
def A
    age int
    say() void
        print("hello world!")

foo() A
    ret A // 여기!

main() void
    foo().say()
```
* orgObj을 반환하거나 접근하거나, 형변환할때는 isComplete()인지를 확인할 필요가 있다.
* * *
# [o] str로 cast시 오류 탐지 못하는 버그 수정
```go
def A
    age int
main() void
    print("age = " + A() as str) // 여기!
```

* as int로 하면 정상적으로 메시지가 나온다.
```
err10(OBJ_WRONG_ARGS) 8:5: I can't run with this argument types '{none}'. they should be 'N4namu4nStrE'
err42(IMPLICIT_CAST_NOT_AVAILABLE) 8:11: couldn't implicit cast N4namu4nStrE type as N4namu4nIntE
```
* str일때만 아무런 메시지도 없고, 죽지도 않고.
* * *
# [o] 컨셉이 자주 변경되면서 baseObj와 obj를 더 구분할 필요가 있어 보인다.
* obj는 사실 mgdObj라는 뜻이었는데, bridgeCppObj도 obj에서 상속을 받고 있다.
* 이게 진짜 맞는지 살펴보자.
* * *
# [o] func은 baseFunc이 되야 하는게 맞지 않나?
* 객체는 baseObj <-- obj 관계를 가지고 있으니까.
* 함수도 맞춰줘야지?
* * *
# [o] 상속은 정말 나쁜가? composition, interface로 완벽히 대체가 되는가? ==> **상속, override를 모두 지원하기로 했다**
* why?
    * 상속을 안좋다고 말하는 이유에는 뭐가 있는가?
        * 나도 대충 많이 들어서, `그렇겠다.` 싶지만 이참에 좀 더 구체적으로 알아보자.
        * 상속을 하는 이유는 무엇인가? 가장 큰 이유는 코드 재사용 때문이다.
        1. 상속레벨이 깊어지면서 전체를 이해하는 것이 더 어려워진다. 모든 상속된 클래스들의 동작을 다 알 고있어야 한다.
             왜냐하면 그 상속된 클래스들이 protected로 깊게 연결되어 있으니까.
        2. 캡슐화의 정의를 `prop 혹은 field` 에 국한 하는 것이 아니라 좀 더 포괄적인 개념으로 `상태변경하지 못하게 한다` 라고 생각해본다면, 1번은
            궁극적으로 캡슐화를 깨는 것이다.
        3. 이처럼 상속은 부모클래스의 동작이 엄청난 파급력을 갖도록 만들어준다. 코드 재사용을 하려고 보니 이런 상황이 되는 것이다.
        4. 1번과 overriding이 만나게 되면, 코드의 흐름을 따라가는 것이 매우 힘들어진다. 코드가 커지면 커질 수록 결국 전체를 속속들이 알 고있어야 유지보수가
            가능하게 된다.
        5. LSP는 궁극적으로는 override할때 코드의 추가를 하되, 삭제는 하지 말라는 것이다. 그런데 이런 실수, 편의를 위한 의도적인 구현이 많이 이루어진다.
            즉, 고기썰라고 칼을 쥐어줬는데, 이 칼로 손가락 베이는 실수는 너무너무 많이 한다는 거지. 그럴바에야 칼을, override를 없애는 게 낫지 않겠냐는 거다.
            칼이 아니라 믹서기로 안전하게 갈든가 하면 되니까. 즉, override를 사용하지 말라는 것이다.
        6. 그리고 단일 상속은 연속적으로 사용이 가능하기 때문에 깊게 주의를 기울이지 않으면 상속 레벨이 엄청나게 깊어진다.
        7. 상속이란 각 클래스의 캡슐화를 다 깨버려서, 상속된 클래스 계층이 아우르는 하나의 클래스를 만들어 외부에대한 캡슐화를 선언하는 것이다.
            그러니 각 캡슐화를 깨버리기 때문에 강하게 결합되는 것이고. 강하게 결합되니 수정에 크게 흔들리고, 그러니 유지보수가 어렵고. 이렇게 되는 것.
        8. 그러니 상속말고 composition을 통해 코드 재사용을 하자.
        9. Composition이 좋은 이유는, Composition한 객체의 public 인터페이스만 사용할 수 있으므로, Composition 안의 상태는 캡슐화가 되기 때문이다.
            전체를 몰라도 되게끔 해주는 것이다.
        9. 물론 이 Composition이 제공하는 메소드별로 일일이 wrapper를 만드는 것은 참 귀찮은 작업이다.
        10. 그렇다고 해서 이 Composition을 그대로 밖으로 public으로 공개해서, *직접 호출하세요* 하는 것도 불가능하다. 왜냐하면 이 Composition을 호출하고 난 뒤에 추가적업 및 상태변경이 owner 클래스에 발생하는 경우가 많기 때문이다. 이또한 결국 캡슐화를 깨는 것이다.
    * 코드로 보여주면 약간 이럴걸까?
        ```java
        abstract class A {
            public void boo() {
                doSomething();
                doSomething3();
                ....
                foo(); // call
                doSomething2();
                doBigThing();
            }
            public abstract void foo();
        }
        class B extends A {
            public void foo(); // override
            public void koo();
        }
        class C extends B {
            public void foo() {
                doDifferently();
            }
        }
        A a = new C();
        ```
        * 저 글의 관점으로 이 코드의 문제를 볼까?
            1. 코더의 의도는 잘 전달된다. A에서 대부분을 처리하고, 일부분의 diff를 상속해서 처리하겠다는 것이다.
            2. 문제는 B인데, B는 foo를 채우고, koo를 추가하는데 C는 koo()는 필요하지만 foo는 필요없기 때문에 다시 재정의하게 된다.
            3. 그럼 A, B, C 모두를 알고 있어야, `A a = new C()` 에서 a가 어떻게 동작할지 예상이 된다.
            4. 그리고 B::foo()의 동작을 삭제하고 C::foo()를 추가하는 것은 LSP를 어기는 것이다. 동작 예측이 더 어려워진다.
                하지만 상속, override는 워낙 강력하기 때문에 이를 예방할 방법이 없다.
        * 보면, 함수가 별로 없어서 그나마 알아먹기 쉽다. 하지만 이런 함수가 엄청많다면?
        * 그럼 상속을 쓰지 않고 쓴다면 어떻게 될까?
        ```go
        trait A
            boo() void
                doSomething()
                doSomething3()
                foo()
                doSomething2()
                doBigThing()
            foo() void = null
        trait B A
            koo() void
                ....
            //boo()
            //foo()

        obj c impl A, B // 다중상속처럼 보여도, 실제로는 prop의 상속이나, override가 되지 않는다.
            foo() void
                doDifferently()
        b B := c
        b.boo();
        ```
    * 구현이 가능했다. 하지만 불가능한 경우도 물론 존재한다.
* 고찰 끝, 다음과 같이 결론 내렸다.
    * 잘못짜게 되면 depth가 지나치게 깊어서 흐름을 알기 힘들게 된다.
        * 흐름을 알기 힘들면, 독해도 힘들고, 유지보수도 힘들고, 기능추가도 제한이 걸린다.
    * 또한 상속은 제한조건이 겹겹히 계속 중첩되는 특징을 가진다. 이는 요구사항이 추가되면 변형/확장이 어렵게 만든다.
        * 예를들어, View <|-- TextView <|-- Button 3개가 있다고 해보자.
        * Button은 반드시 뭔가를 보여줄 수 있는 기능(View)이 있어야 하고, Text를 처리해야한다.
        * 이때, Button이긴 한데 이미지를 보여줘야 하는 요구사항이 생기면??
        * 상속은 가운데 있는 layer인 Text만 교체할 수 없도록 제한을 걸어두는 개념이다. Button만 챙길 수는 없다. Button을 챙기려면 Text기능도 같이 가져가야지.
        * 이게 상속의 한계다.
    * 그러니 상속이 갖는 단점은 충분히 이해가 된다. 더 큰 문제는 상속을 잘못 쓰게 만들 게끔 하는 요소들이 너무 많다는 것이다.
        * 요리하라고 불을 주긴 했는데, 이게 가스렌지가 아니라 기화된 가솔린으로 돌리는 요리기구를 준 셈이지.
        * 잘쓰는 사람이라면 가솔린으로도 좋은 음식을 만들 수 있겠지만, 요리하다가 집 날려먹는 사람이 더 많은 구조인 셈이다.
        * 상속을 쓰지말고 composition만으로 코딩을 하게끔 제한하는 언어들은, 마치 이럴바에야 아예 불을 주지 말고, 에어프라이어를 주자는 얘기다.
    * 하지만 문제가 있다.
        * 1. 상속을 대신 하는 방법, 대안책을 쉽사리 떠올릴 수 있어야 하지만, 그렇지 못하다.
            * 바로 이 위에 나온 A, B, C 문제가 그것이다. 적절한 대안이라봐야, *애초에 이렇게 짜는게 잘못이다*, *람다를 쓴다*, *interface를 만든다* 정도인데,
            * 어느쪽이나 불편하거나, 바로 떠오르지 않아서 머리를 혹사하거나, 만들고 나서도 interface나 클로저를 통해서 하는 등 간접적인 방법으로
            * 수행하기 때문에 코드 독해가 더 어려운 방법들이다.
        * 2. 짜기 어려운 언어는 분명히 장벽으로 존재하게 된다.
            * 마치 러스트 처럼. 진입장벽이 높아지게 되고, 이걸 넘게하려면 벽 반대편에 확실히 먹이가 있거나, 벽을 넘도록 부추기는 채찍 든 사람(=회사)이 필요하다.
            * 내가 만들 언어는 이러한 언어가 아니라는 점을 알 수 있다.
            * 즉, `진입장벽`과, `잠재적인 상속으로부터 야기되는 낮은 유지보수성` 2개를 저울질 해본 결과, 상속을 택한 것 뿐이다.
        * 3. 상속이 문제가 아니라 override가 문제다.
            * Rust는 그래서 `하나의 signature로 정의된 함수가 하나 있으면, 그걸 덮는 다른 함수는 존재하지 않아야 한다.`는 원칙으로 보인다.
        * 4. composition을 자동 delegation하는 기능과 상속, override를 없애고자 하는 의도는 상반된 것이다.
            * 자동으로 delegation이 된다는 것은 어떤의미를 가질까? 조금만 생각해보면 알 수 있다. composition을 썼다고 해도 자동 delegation이 되버리면,
            * 겉에서 이 객체를 봤을때는 상속과 차이가 없다는 의미다. 그리고 파생객체와 기반객체간의 signature가 겹치는 함수가 분명히 잘 나온다는 말이된다.
            * 그러면 겉으로 봤을때 상속은 지원되지만 override가 지원되지 않는다는 것은 method hiding만 지원된다는 얘기다.
            * 이는 `foo()를 호출했을때 특별한 상황에서는 A로직이 동작하고, 다를때는 B 로직이 수행됩니다.` 와 별반 다르지 않다.
            * 실제로 go는 2가지 모순점이 발생한다.
                * 1. A 객체에 foo()를 정의하고 이를 B에서 embed하고 B에도 같은 foo()를 추가한 경우, B를 A로 subtyping하는 방법이 존재하지 않는다.
                    * 굳이 한다면 `a A := B().A` 처럼 하는 것이다. 이는 subtyping이 아니라 물론 객체의 참조를 다시한것에 지나지 않는다.
                    * 이상태에서 a.foo()를 하면 당연히 A::foo()가 호출된다.
                    * override를 하고 싶다면 foo()를 갖는 interface를 하나 만들어서 B를 이 Interface로 subtyping 하면 된다.
                    * 즉 부분적으로 interface를 사용했을때만 override가 가능한 상태가 된다. 얘기만 들어도 변태적이다.
                * 2. 1번에서 interface를 통해서 a.foo()를 했을때 B가 호출되는, A --> B 가 되는 경우를 설명했다.
                    * 하지만 이 경우 엄연히 호출되는 foo()는 A안에 있는 거다. foo()를 했을때, 컴파일러가 `this.A.foo()` 로 바꿔주는 것에 지나지 않는다.
                    * 그러니 foo()안에서의 this는 B가 아니라 A다.
            * 결국 go는 B --> A로 가는 override를 막고 있다는 얘기다.
            * go언어를 쓸때 이 단점을 항상 머리속에 넣고 있어야 한다.
    * 따라서 Rust의 방식이라면 나는 찬성을 하는 편이지만, composition + with를 통한 자동 delegation를 전제로 한 현재의 문법 하에서는
    * 절대로 override, 상속을 없애서는 안된다고 판단한다. go 같은 모순점을 안고 가지는 않겠다.
    * 동작이 일관적이지 않으므로 항상 예외케이스를 알고 있어야 하고, 부분적으로는 override를 허용하기 때문에 완벽하게 상속을 제거했다, 그래서 이득을 100% 챙겼다
> 요약:
>     상속과 override는 위험하다는 것에 동의한다.
>     하지만 상속과 override를 지원할 것이다. 이유는,
>         1. 상속은 `goto`와 다르게 상당수 OOP 문제를 `상속없이 짜는법을 생각해보세요` 했을때 쉽게 떠올리지 못한다. 머리를 좀 써야 한다. 된다고 하더라도 코드가 더럽다.
>             이는 분명히 진입장벽으로 작용하며, 내 언어의 특성은 타의로 언어 공부를 시작하는 (회사에서 하라고 해서 배우거나, 취직하려고 배우거나 등) 케이스가 적을 언어이기 때문에
>             이 진입장벽은 커다란 것이다. 메리트 대비 잃는 게 더 많다는 것.
>         2. go언어처럼 with를 통한 자동 delegation 기능이 문법에 전제로 있게 되면 override를 빼는게 되려 악수가 된다. 상속을 뺄거면 차라리 Rust처럼 해야한다.
>              그래서 실제로 go는 2가지 모순점이 발생한다.
>      따라서 Rust의 방식이라면 나는 찬성을 하는 편이지만, composition + with를 통한 자동 delegation를 전제로 한 현재의 문법 하에서는 절대로 override, 상속을 없애서는 안된다고 판단한다.
>      go 같은 모순점을 안고 가지는 않겠다.
>      동작이 일관적이지 않으므로 항상 예외케이스를 알고 있어야 하고, 부분적으로는 override를 허용하기 때문에 완벽하게 상속을 제거했다, 그래서 이득을 100% 챙겼다
>      고 하기에도 애매하다는 것.
* * *
# [o] 코드로 새로운 with, override 문법 검증하기.  ==> **잘 된다고 본다. 근데 더 검증하자.**
* 예제1번
    ```java
    class Animal {
        private String habit;
        protected String sound;
        public Animal() {
            habit="";
            sound="";
        }
        public String say() {
            return sound + " I like to " + getHabit() + ".";
        }
        public void tick() {
            System.out.println(say());
        }
        public String getHabit() {
            return habit;
        }
        public void setHabit(String habit) {
            this.habit=habit;
        }
    }
    class Cat extends Animal {
        public Cat() {
            super();
            setHabit("crawl");
            sound="Meow";
        }
    }
    class PlayfulCat extends Cat {
        public PlayfulCat() {
            super();
            setHabit("play");
        }
    }

    Cat c = new Cat();
    PlayfulCat pc = new PlayfulCat();
    c.tick();
    pc.tick();
    ```
    * 이걸 나무로 고치면,
    ```go
    def Animal
        _habit := ""
        _sound := ""
        say str // 이렇듯, 인스턴스를 차지하지 않는 prop은 interface에서 선언이 가능하다.
            get: "$sound I like to $habit.") // set은 허용되지 않는다. 즉, set을 할 수 없다.
        tick() void
            print(say())
        ctor(habit, sound): ret
    def cat
        with Animal("crawl", "Meow")
        // 혹은, ctor(): habit = "crawl"; sound = "Meow"
    def playfulCat
        with @cat() // 직접 정의하지 않아도 이렇게 with로 끼워넣을 수 있으면 impl 조건은 만족된다.
        ctor(cat.habit): null
    cat.tick()
    playfulCat.tick()
    ```
    * 아주 간결하다!
* 예제2
    ```kotlin
     abstract class Context {
        private val attr: Int = 0
        abstract fun getResourceId(): Int
        fun applyImage() {
            ImageProcessor().process(getResourceId() + attr)
        }
        constructor(newAttr: Int) {
            attr = newAttr
        }
    }
    abstract class View : Context {
        constructor(newAttr: Int) {
            attr = newAttr
        }
    }
    class Button : View {
        constructor(): super(22) {}
        fun getResourceId(): Int {
            return 22
        }
    }
    ```
    * 이걸 namu로 바꾸면,
        ```go
        def Context
            _attr int
            resourceId int = null
            applyImage(): imageProcessor.process(resourceId + attr) // 어떤 함수는 이렇게 구현이 들어갈 수 있다.
            ctor(attr): ret
        def View
            with Context()
            ctor(attr): ret
        def Button
            with View(22)
            resourceId int // set이 없다는 건, set을 할 수 없다는 얘기다.
                get: 22
        ```
    * 간결하다!
* 3번
    ```ts
    class MovieClip {
        private var y:int = 0;
        private var alpha:int = 0;
    }
    class Ball extends MovieClip {
        private var frame: int = 0;
        function Ball() { // 생성자
            graphics.beginFill(0xAA0000);
            graphics.drawCircle(0, 0, 20);
            graphics.endFill();

            addEventListener(Event.ENTER_FRAME, onEnterFrame);
        }
    }
    class BouncingBall extends Ball {
        private function onEnterFrame(e:Event):void {
            this.y = 280 - Math.abs(Math.cos(frame / 15) * 200);
        }
    }
    class FadingBall extends Ball {
        private function onEnterFrame(e:Event):void {
            frame++;
            this.alpha = Math.abs(Math.cos(frame / 15));
        }
    }
    ```
    * namu로 고치면,
    ```go
    def MovieClip
        y := 0
        alpha := 0
    def Ball
        with MovieClip()
        frame := 0
        ctor()
            graphics.beginFill(0xAA0000)
            graphics.drawCircle(0, 0, 20)
            graphics.endFill()
            addEventListener(Event.ENTER_FRAME, onEnterFrame)

        onEnterFrame(e Event) void = null
    def BouncingBall
        with Ball()
        onEnterFrame(e Event) void
            frame++
            y = 280 - math.abs(math.cos(frame / 15) * 200)
    def FadingBall
        with Ball()
        onEnterFrame(e Event) void
            frame++
            alpha = 280 - math.abs(math.cos(frame / 15) * 200)
    ```
    * 거의 비슷하지만 살짝 더 간결하다!
* 예제4
    ```go
    type I interface { Foo() }
    type A struct { i I }
    func (a *A) Foo() {
        fmt.Println("A.Foo()")
    }
    func (a *A) Bar() {
        a.i.Foo()
    }

    type B struct { A }
    func (b *B) Foo() {
        fmt.Println("B.Foo()")
    }

    func main() {
        b := B{A: A{}}
        b.i = &b     // here i works like an attribute of b
        b.Bar()
    }
    ```
    * 나무로 바꿔보면,
        ```go
        def A
            foo()
                print("A.foo()")
            bar()
                foo()
        def B
            with A
            foo()
                print("B.foo()")
        main() void
            b := B()
            b.bar()
        ```
        * 역시 간결하다!
* * *
# [o] #super_call과_override_문제 ==> **A::B 문법을 추가한다**
```go
def A
    foo()
        boo()
    boo(): ...
def B
    with A
    foo(): ...
    boo(): ...
// B객체를 놓고, A::foo()를 시키려면?  --> 조건1
// 그러면서도 A::foo() 안에서 boo()를 실행했을때 A::boo()가 아니라 B::boo()가 실행되게 하려면? --> 조건2
```
* why?
    * with는 상속이 아니다.
    * 그러니 만약 위 코드에서 `B().A.foo()` 를 하게되면 조건1은 달성되지만 foo()를 실행하는 me는 A이기 때문에 조건2는 실패한다.
* [x] 이게 되야 하는게 맞는가? ==> **네**
    * 좀 더 일반적인 super func call을 하는 모든 상황에서 발생할 것 같은 문제가 드는데?
    ```go
    def A
        foo() void
            doSomething()
            boo()
        _boo() void = null
    def B
        with A
        _boo()
            print("I'm B")
    def C
        with A
        _boo()
            print("I'm C")
    ```
* [x] go는 이상황을 어떻게 해결할까?
    * composition은 composition이다. A::foo()에서 boo()를 호출하면 A::boo()가 불려진다.
    * 이는 Go의 원칙인 **내부에서 A --> B가 override 가 가능하지 않도록 한다** 에 의한 것이다. 외부에서라면 interface로 씌워서 A --> B인 것처럼 호출 할 수 있다.
    * 이걸 허용 하는 순간 코드를 어렵게 만드는 원인이라고 보는 거겠지.
    * 그럼 해결방법은?
        1. boo() void를 interface로 만든다. 이렇게 된다.
            ```go
            // 방법1: rust하고 비슷하게.
            //        decl은 prop을 정의 X, decl은 null이 올 수 있음
            //        decl은 상속을 지원함. 진짜 상속. with가 아님.
            //        단점은, with와 by의 차이를 잘 모르겠다는 점이다.
            decl A
                foo() void
                    doSomething()
                    boo()
                _boo() void = null
            def B by A
                // 구현방법: decl은 메모리가 정의되지 않은 애들만 있으므로,
                // A를 만들때 prop 관련은 그냥 제약사항이다. 그러니 실제로 prop을 A에 넣어두지 않는다.
                // by를 사용해서 B에 끼워넣을때는 orgObj인 A의 subs()를 그냥 밑에 깔면 된다.
                boo()
                    print("I'm B")
            def C by A
                boo()
                    print("I'm C")
            // 추가질문:
            //    1. B::foo()을 만들도록 허용해야 하는가? 만약 그렇다면 A타입으로 B객체의 foo()를 부르면 A::foo()가 불리는가, B::foo()가 불리는가.
            //
            // 방법2: with를 사용하되, OOP 상속, override을 허용했을 때처럼
            //    포인트1: B는 A를 with했다. 그러니 B는 A::foo()를 갖는다. B에 대해서 foo()를 호출하면 foo() 안에서 me는 A가 되겠거니 생각하기 쉽지만,
            //            실제로는 그렇지 않다. B에서 foo()를 찾은거기 때문에 me는 여전히 B가 된다.
            //            그러니 B::foo()안에서 boo()를 호출하면 이 역시 B::boo()인 것이다.
            //            물론 B.A.foo()를 해버리면 얘기는 다르다.
            //            물론 이 방법은 override도 사실상 지원해버리는 것이다.
            def A
                foo() void
                    doSomething2()
                    boo()
                _boo() = null
            def B with A
                _boo() void
                    doBthing()
            def C with A
                _boo() void
                    doCThing()
            ```
        * go 라면 lambda나 작은 interface를 만들거나 할 것이다.
1. [u] 새로운 문법, `A::B()` 를 추가한다. ==> **별도 항목으로 논의**
    * 고민한 결과 이게 제일 깔끔했다.
> 요약:
>     namu는 여러 객체를 delegation 하기 때문에 super라는 게 없다.
>     대신 a::b() 라는 문법을 지원한다.
* * *
# [x] def 뒤에 1개는 with로 할 수 있게 한다. ==> **어색하다. 그냥 하지 말자...**
```go
def A with B(2, 3)
```
* syntactic sugar 다.
* 2개를 지원하지 않는 이유는,
    1. 가능하면 main 상속은 1개만 하라는 뜻이다.
    2. 여기서 2개를 지원하면 함수내에서 with쓸때도 2개 쓰고 싶어질 것이다.
* [v] 하나도 지원하지 않으면 되는거 아닌가? ==> **이게 있어야, 상속은 했지만 이름은 없는 def 를 쉽게 할 수 있다.**
* 하나만일지라도 def 뒤에 with가 붙는다는게 어색하다.
* * *
# [o] #verification_단계에는_객체를_직접_만들지_않아도_최적화_방법이_있다. ==> **proxy**를 만들자.
* verification 단계에서 verifier::onVisit(defVarExpr) 등을 만나면 안에서 `scope.add(eval.clone())` 같은 코드를 볼 수 있다.
* 왜 eval을 그대로 안쓰고 clone()을 하는가?
    * 이유는 isComplete() 때문이다. orgObj는 incomplete라고 해도, 여기서 복제된 객체는 complete하다. 당연히.
    * 즉 complete 여부는 객체 각각 마다 다르기 때문에 verification 단계시, eval(== orgObj)만 들고 있는 경우 난감해지는 것이다.
    * 객체를 만들지 않고 해결하려면 defVar, defAssign시에 class proxy : public obj 객체를 만들고, 생성자에 orgObj를 넣어주면 된다.
    * 이 proxy 클래스는 딱 1개만 빼고는 모두 orgObj 원본으로 delegation한다.
    * 그 1개가 바로 obj::isComplete() 값이다. 항상 true를 내보내도록 하면 된다.
* * *
# [o] fix: 아무런 값도 나오지 않는다.
```go
def a
    age := 0
    foo() void: ..
    me(n int)

def b
    a1 a
    a2 a
    say() void
        a1.age = 5
        print("hello world: ")
        print(a1.age as str) // `hello world: ` 로 나온다. 5가 안나옴.

main() void
    b().say()
```
* * *
# [o] #with_verification_로직  ==> **어려웠다. 하지만 mark & deepSearch로 가능했다.**
* 지금까지 고찰한, fix된 조건들을 먼저 정리하자.
    1. with 시 ADT 타입(incomplete) 이 오는 것이 허용된다. 이경우 모든 생성자에서 이 ADT에 대한 참조를 채워넣었는지를 꼭 확인해야 한다.
    2. verification은 특정 sub가 있는가 아닌가를 확인할때 type을 사용하지 않는다. 지금까지와 마찬가지로 obj(node)를 가지고 체크할 것이다.
        * 이 얘기는 verification에 들어가기 전에 orgObj는 모두 구성이 완료되어야 한다는 것이다.
    3. incomplete객체와 그것을 복제한 complete객체간의 *정적인* 차이는 존재하지 않아야 한다. 생성자를 거쳤는가, 아닌가, prop의 어떤 값이 실제로 들어가 있는가에 대한 여부일 뿐이다.
        * incomplete객체라고 할지라도 어떠한 타입의 prop을 들고있는가는 valid 하다는 얘기다.
        * 그리고 verifier는 이 *타입정보* 만 알면 충분하다.
    4. 1,2,3을 합쳐서 얘기해보면, verifier는 verfification단계에서 incomplete에 대한 참조를 들고 있어도 마치 complete한 것처럼 이것을 검증할 수 있다.
    5. 따라서 with시 ADT가 들어있는 상태라고 할지라도 해당 객체의 검증여부는 항상 valid하다.
    6. 문제가 되는 것은 오직, 어떠한 생성자를 거쳤을지라도 반드시 prop이 incomplete를 참조하는 순간은 없어야 한다라는 점이다.
    7. 순환 의존문제를 가장 쉽게 해결하는 방법은,
        1. expand 단계에서 다른 객체의 연결시 복제없이 orgObj를 연결하도록 하고 타입정보를 최대한 살리도록 한 다음.
        2. verification들어가면서 orgObj를 각각 생성하는 것이다.
            * 간단한 예를 들어볼까?
                ```go
                // 예1:
                def A
                    b B
                    ctor(b)
                def B
                    a A
                    ctor(): a = A(B())
                // 예2:
                def A
                    b := B()
                // 예3:
                def a
                    with B
                def b
                    with A()
                ```
                * parser는 `b B`가 있다는 사실만 어딘가에 기록해둔다. **왜냐하면 아직 B orgObj 자체가 없을 수도 있으니까.**
                    * orgObj를 생성하기 위한 생성자호출 정보를 orgObj에 넣어둔다.
                        * 이름이 대문자로 시작했다면 호출정보를 비워둔다.
                        * 호출정보가 비워두면 자동으로 incomplete obj가 된다.
                        * 참고로, complete냐 아니냐는 문법상으로 완전한가 의미다. 인스턴스적으로 완전하려면, 당연히 complete속성도 있으면서 expand 단계를 넘어가야만 한다.
                            * 즉, `obj::isComplete()` 와 `obj::getState() == EXPANDED` 는 다른 개념이다.
                    * 위의 예에서는 `def A` 뒤에 소괄호가 없기 때문에 기본호출인 `run("", {})` 인 셈이다.
                * expand 단계에서
                    * onVisit(obj)를 만나면
                        * \_onVisitCommonCtor()를 돌린다. 이 함수는 여기에서만 실행된다.
                    * 일단 sub를 채운다.
                        * `b B` 를 보고 A 안에 B orgObj를 참조하는 b를 만들어 둔다. **아직 B의 복제 객체는 만들 수 없다. B의 orgObj는 인스턴스는 생성되었지만 expand 중이거든**
                        * `a := expr`를 보면
                    * 만들지 못하면, 이 expand는 stop하고, 다른 객체에 대한 expand를 진행한다.
                    * 무한 루프를 돌면서 expand을 하다가 어떠한 객체도 expand를 더 못하는 상황이 온다면 루프를 중지하고 순환참조 에러를 내보낸다.
                    * 마지막으로 pack.objList 순환하면서, orgObj에 대한 생성자를 각각 호출해준다. 이게 끝나면 정말로 complete객체가 될 수 있다.
                        * 참고로 어떤 생성자를 돌리는지는 parser가 orgObj에 주입을 해두었다.
                        * 주입된 생성자호출을 실행할떄의 stackFrame은 pack만 들어가 있으면 된다.
                    * commonCtor()은 없앤다.
                        * 이 얘기는 sub에 대한 초기식은 orgObj에 대해 1회만 실행된다는 것이다.
                        * 생성자는 객체가 복제될때마다 매번 실행되지만.
                * verification 단계에서는 expand에서 생성한 orgObj를 두고 테스트한다. **expand단계가 끝나면 앞서서 참조한 orgObj도 모든 sub가 expand되었을 것이다**
                    * 그리고 verifier는 값을 중요하게 생각하지 않는다. type정보만 본다. 그러니 orgObj가 incomplete이든 아니든 상관 없다.
* [u] 위의 내용을 토대로 하면, 로직은 큰 그림에서 다음과 같이 된다.
    * 사전 요구사항
        * getEval()은 orgObj을 반환하는 함수여야 한다.
    * parse 단계
        1. pack.orgs에 pack 자신을 넣어둔다. pack도 org맞다.
        2. parser는 `A`를 보면 지금까지와 마찬가지로 `getExpr("A")`로 변환한다.
        3. `defObj`를 보면 pack.orgs에 넣어둔다.
        4. `with expr` 혹은 `A := B` 를 보면,
            1. with의 경우는 dependency객체를 만들어서 orgObj에 따로 넣어둔다.
            2. with, defAssign 을 보면 별도의 preEval() 에 넣어둔다. 이 함수는 오직 parser->preEval 까지만 유효한 함수다.
                * [x] 왜 함수, defVar, defProp은 preEval()에 안들어가는가?
                    * 모두 타입추론을 해야하는 것들이다. expr 기반이다.
                    * 저것들은 eval을 하지 않으면 타입을 알수가 없기 때문이다.
                    * 저것들은 expr을 실행하는 중에 다른 타입에 종속되서 안되는 경우가 생길 수 있다.
                        * 타입에만 의존하는  `A B` 같은 케이스는 orgObj만 있으면 되니 수월하지만, expr기반이면 그게 안된다.
        5. getGenericExpr는 parser.\_generics.add 해둔다.
            * 참고로 genericObj도 앞서 말한 `defObj` 에 해당한다.
        6. 나머지, `A B`, `foo(A B) C`, 같은 케이스는 기존 코드대로, subs에 바로 둔다.
        7. parse가 끝나기 직전에 parser.\_generics에 있는 getExpr()을 실행한다. 그렇게 하면,
            1. genericObj에 sub로 새로운 obj가 등록된다.
            2. generalizer를 돌린 obj가 밖으로 나온다. 이걸 pack.orgs에 넣어둔다.
* 문제 시나리오
    * 이걸 해결할 수 있어야 한다.
    * [x] 문제시나리오1 이게 위의 expand 알고리즘으로 해결되는가? ==> **네**
    ```go
    def A
        age := b.age + 5
    def b
        age := foo(2)
    ```
    * [x] 문제시나리오2 ==> **expandable**
    ```go
    // 예1:
    age := "age"
    def A
        grade := age + 5 // 이건 에러가 맞다고 보는가?
        age := 3.5
    ```
    * [x] 문제시나리오3 ==> **expand 불가능**
    ```go
    // 예2: 이건 아닌게 맞다고 생각한다.
    def A
        age := B().grade
    def B
        grade := A().age // 순환참조 에러가 나갈 수 있어야 한다
    ```
    * [x] 문제시나리오4 ==> **expandable 불가능**
    ```go
    // 예3:
    def A
        age := B().grade // 여기서 무한 루프에 들어간다.
    def B
        addr := A().age
        grade := 3.5 // 위에서부터 훓지 않고, grade를 먼저 expand했었다면, 문제가 없었을 코드였다.
    ```
    * [x] 문제시나리오5 ==> **expand 불가능**
    ```go
    // 예4:
    age := foo(5) + 1
    def A
        age := B().grade
    def B
        grade := age + 1
        with A // 보다시피 with는 항상 우선순위가 높아야 한다?
    ```
    * [x] 문제 시나리오6 ==> **expandable**
    ```go
    age := 5
    foo() A
    def a
        with grade + 3
        grade := 3.5
    def B
        age := 2

```
 No newline at end of file
        ctor(f flt)
    ```
    * [x] 문제시나리오7 ==> **expand 불가능**
    ```go
    def A
        grade := B().age + 1
    def B
        age := foo(c.wow)
    def c
        wow := A().grade - 5
    ```
    * [?] 문제시나리오8 ==> **?**
    ```go
    def A
        grade := b.a1 * 2
    def b
        a2 := A().grade + 5
        a1 := 5
    ```
    * 현재 알고리즘으로는 안된다.
    * 즉, execute시점에서 complete orgObj의 초기식은 orgObj별로 의존성이 자리잡는게 아니라, 각 초기식 구문 별로 의존성이 자리잡혀 있다는 걸 알 수 있다.
* [u] 이렇게 각 초기식 구문별로 의존성 처리를 해주는 걸 지원해줘야 할까? ==> **네. kotlin은 해주네. 이게 되야 사용자들은 좀 자유롭다는 느낌이 들겠다.**
    * [u] expand 단계: *preEval에서 이름을 바꾸자.*
        * expander는 visitor가 아니다. expand가 verifier이고, expander는 expand들을 배열에 담아서 만든다.
        * expand는 verifier를 기반으로 하되, 몇몇 함수는 아무런 동작을 하지 않도록 override하거나 조건을 추가할 것이다.
            * str meobj, int len 2개를 갖는다.
        1. pack.orgs를 expand(완성) 한다.
            1. pack.orgs로부터 expand배열을 만든다.
                * expand는 생성자에서 orgObj를 하나 받는다.
            2. 만든 expand배열을 하나하나 start() 한다.
                * start() 하면
                    1. meobj로 frameInteract한다.
                    2. preEval() 찾아서, len을 비교한다. 만약 같거나 크다면 더 expand할게 없는 것이다.
                    3. preEval()의 맨 앞의 stmt를 빼와서, expand시도한다. 도중에 err가 발생하면 거기까지만 하고 중단한다.
                    4. expand라는 말이 걸맞게 onVisit시, verification만 하는게 아니다. 에러가 없을 경우 expr을 실행해서 sub를 만드는 게 목적이다.
                * 주의점
                    * expand는 타입추론을 동작한다. 코드를 실제 eval하는게 아니다.
                    * 예를들어 expand::onVisit(defAssignExpr& e) 가 오면,
                        1. super::onVisit(e)를 돌린다. 에러있으면 바로 return
                        2. 추가로 체크할 것을 한다.
                        3. 그래도 에러가 없다면, sub로 추가한다. 이때 e.getEval()을 해서 type을 얻어오기만 한다.
                            * 참고로 getEval()은 orgObj를 반납하는 함수다.
            1. 결과가 에러가 발생했다면, 다음 expand를 실행한다.
            2. 에러가 발생하지 않았다면 모든게 expand된 것이다.
                1. 그 expand.obj에서 preEval()을 제거한다. 이제 필요없다.
                2. 이 expand는 제거한다.
        * 코드로 보는 알고리즘
            ```cpp
            class visitor {
                // @return false면 traverse하지 않음
                bool onVisit(...)
            };
            class verifier : public visitor {
                // ...
            };
            class expand : public verifier {
                bool onVisit(visitInfo i, obj& o) {
                    if(i.len > 1) return false;
                    _us.push_back(frame::_setMe(o));
                    return true;
                }

                void onLeave(i, obj& o) {
                    if(i.len > 1) return;
                    frame::_setMe(_us.back());
                    _us.pop_back();
                }

                void onTraverse(i, obj& o) {
                    o.sub("preEval")->accept(visitInfo{"", &o, 0, i.depth+1}, *this);
                }

                bool onVisit(i, func& f) {
                    return f.name == "preEval";
                }

                void onTraverse(i, func& f) {
                    while
                        stmt := f.blk[_evalutedLen]
                        if(stmt == null) break;
                        _rpt.rel();
                        stmt.accept()
                        if(_rpt.isErr()) break;
                        _evaluatedLen++;
                }

                void onVisit(i, getExpr& e) {
                    if(e.me.getState() < EXPANDED) _err(...)
                    super::onVisit(i, e);
                }

                int _evaluatedLen;
            };
            ```
1. [d] 무한루프 방법 ==> **매우 느리다. 더 빠른 방법을 택해야 겠다.**
    * 결국 6가지 구현이 추가되어야 한다.
        * 사전 필수 조건
            * preEval()의 코드는 with아니면 defAssign라는걸 확실히 하자.
            * defAssign, with는 defExpr이다. defExpr은 초기식expr에 올 수 없어야 한다.
                * 이는 defAssign, with가 preEval() 바로 밑에 있어야 한다는 조건이다. defAssign 안에 defAssign 있는 건 용납해선 안된다.
            * with는 expand 시점에서 complete이건 incomplete이건 다 expand가 된다.
            * 다만 incomplete에 대해 with를 한 경우라면 verifer가 **모든 생성자에서 해당 with를 채웠는가?** 를 확인할 것이다. 사용자가 해줄 거라는 얘기다.
                * 그러니 expander건 verifier가, *incomplete 타입에 대한 with라면 나중에 생성자에서 우리가 예외처리 해줘야 하는데...* 할 필요가 없다.
            * 이 expander가 하는 초기식은 코드에 따라서 순서가 매우 복잡할 수 있다. 그러니 무한루프를 도는 거다.
            * 단, 이렇게 한번 의존성을 풀어내고 나면 실제 execute시점에서는 신경쓰지 않아도 된다.
                * 즉 초기식은 expand 단계에서만 수행된다. 객체가 초기식은 실행되지 않고, 복제될때는 생성자만 처리된다는 점에 유의하라.
        1. 파서는 defBlock밑의 defAssign을 preEval()에 넣어두기도 하지만, orgObj에 sub로 비어있는 tstr(node::type, dummyNode)로 넣어두기도 하자.
        2. expand시 defAssign은 orgObj에 **이미 있는** sub에 새로운 tstr(새로운type, orgObj) 을 넣어두는 것이다.
            * defAssign시 type일 지정했으면 그 type을 tstr에 대신 넣는다.
            * 예: `A B := C`
        3. 각 expand는 위에서 아래로 1회씩 진행한다.
        4. expand 성공한 preEval() 내의 코드 1줄은 제거한다.
            * 이얘기는 뒷줄에 있는 코드가 먼저 expand 될 수도 있다는 뜻이다.
        5. onVisit(getExpr&) 에서, obj에서 sub가 있는지 아닌지 체크할때 단순히 sub() 한 결과가 null이면 아예 없다는 것이고, dummy가 나오면 있지만 아직 채워지지 않은 것이니 `try again` 하면 된다.
        6. getExpr&)에서 찾을 때
            1. 먼저 obj.directSub()에 있는지 체크한다.
                1. 있으면 성공.
                2. 있는데 dummy면 try again
                3. 없으면 obj.dependencies 순회하면서,
                    1. dependencies.org를 가져와서,
                    2. org.getState() >= EXPANDED 체크한다. 아니라면 continue
                    3. 맞다면, org.sub(e.subName)을 한다. 있으면 return true로 체크 성공을, 없으면 continue
                4. 그래도 없었다면 obj.pack.sub() 한다. 있으면 return true 그래도 없으면 진짜 return false
    * 그러면 위의 모든 예제를 다 해결 할 수 있다.
    * 사전 필수 요구 조건
        * 위의 알고리즘 예시코드가 있다. 아주 좋은 알고리즘 요약이니 꼭 참조하자. 그렇게 짜면 될 것이다.
        * getEval()은 orgObj을 반환하는 함수여야 한다.
        * preEval()의 코드는 with아니면 defAssign라는걸 확실히 하자.
        * defAssign, with는 defExpr이다. defExpr은 초기식expr에 올 수 없어야 한다.
            * 이는 defAssign, with가 preEval() 바로 밑에 있어야 한다는 조건이다. defAssign 안에 defAssign 있는 건 용납해선 안된다.
        * with는 expand 시점에서 complete이건 incomplete이건 다 expand가 된다.
        * 다만 incomplete에 대해 with를 한 경우라면 verifer가 **모든 생성자에서 해당 with를 채웠는가?** 를 확인할 것이다. 사용자가 해줄 거라는 얘기다.
            * 그러니 expander건 verifier가, *incomplete 타입에 대한 with라면 나중에 생성자에서 우리가 예외처리 해줘야 하는데...* 할 필요가 없다.
        * 이 expander가 하는 초기식은 코드에 따라서 순서가 매우 복잡할 수 있다. 그러니 무한루프를 도는 거다.
        * expand 단계에서는 초기식의 순서를 재정렬하고, 타입이 올바른지만 체크한다.
        * execute 단계에서는 이렇게 재정렬된 초기식을 순서대로 실행하는데, 이 초기식은 @commonCtor에 담긴다.
        * 즉, 이렇게 한번 의존성을 풀어내면 실제 execute시점에서는 의존성 순서를 신경쓰지 않아도 된다.
        * execute단계에서 시작 전에 모든 orgs에 대해서 생성자호출정보를 통해 orgObj의 생성자를 호출할 것이다. 그리고 생성자 안에서는 반드시 먼저 @commonCtor을 호출한다. @commonCtor은 앞서 말한대로 의존성 순서가 해결된 초기식들이 들어있다.
        * pack에는 @init()가 있다. 이것은 complete orgObj들을 초기화시키는 코드가 모여져 있다.
     * parse 단계
         1. pack.orgs에 pack 자신을 넣어둔다. pack도 org맞다.
         2. parser는 `A`를 보면 지금까지와 마찬가지로 `getExpr("A")`로 변환한다.
         3. `defObj`를 보면 pack.orgs에 넣어둔다.
         4. `with expr` 혹은 `A := B` 를 보면,
             1. with의 경우는 dependency객체를 만들어서 orgObj에 따로 넣어둔다.
             2. with, defAssign 을 보면 별도의 preEval() 에 넣어둔다. 이 함수는 오직 parser->preEval 까지만 유효한 함수다.
                 * [x] 왜 함수, defVar, defProp은 preEval()에 안들어가는가?
                     * 모두 타입추론을 해야하는 것들이다. expr 기반이다.
                     * 저것들은 eval을 하지 않으면 타입을 알수가 없기 때문이다.
                     * 저것들은 expr을 실행하는 중에 다른 타입에 종속되서 안되는 경우가 생길 수 있다.
                         * 타입에만 의존하는  `A B` 같은 케이스는 orgObj만 있으면 되니 수월하지만, expr기반이면 그게 안된다.
                 * 단, defAssign의 경우에는 subs().add(getExpr.name, tstr(node::type, dummyNode))로 넣어두자.
                 * 단, 모든 생성자 코드의 앞줄에는 @commonCtor()을 호출하도록 추가하자.
         1. getGenericExpr는 parser.\_generics.add 해둔다.
             * 참고로 genericObj도 앞서 말한 `defObj` 에 해당한다.
         2. 나머지, `A B`, `foo(A B) C`, 같은 케이스는 기존 코드대로, subs에 바로 둔다.
         3. parse가 끝나기 직전에 parser.\_generics에 있는 getExpr()을 실행한다. 그렇게 하면,
             1. genericObj에 sub로 새로운 obj가 등록된다.
             2. generalizer를 돌린 obj가 밖으로 나온다. 이걸 pack.orgs에 넣어둔다.
     * expand 단계: *preEval에서 이름을 바꾸자.*
         * expander는 visitor가 아니다. expand가 verifier이고, expander는 expand들을 배열에 담아서 만든다.
         * expand는 verifier를 기반으로 하되, 몇몇 함수는 아무런 동작을 하지 않도록 override하거나 조건을 추가할 것이다.
             * str meobj, int len 2개를 갖는다.
         * expand단계에서 defAssign, defVar, with등은 모두 실제객체를 run()해서 채우는게 아니라 eval(즉, orgObj)만 넣어두는 게 목적이다.
         * visitor는 onVisit() 과 visitor::start()는 enum을 반환한다. enum의 값은 이렇다.
             * SUCCESS 혹은 OK
             * ERR
             * TRY_AGAIN
         * complete orgObj의 초기식 구문은 obj 별로 의존성을 갖는게 아니라 각 초기식구문 별로 다른 의존성을 갖는다.
             * 예를들어보자.
                 ```go
                 def a
                     grade := b.a1 * 2
                 def b
                     a2 := a.grade + 5
                     a1 := foo(5)
                 ```
             * 위와 같은 코드가 있을 때, 실제 실행순서는 이렇게 되야 한다.
                 1. b.a1 = foo(5)
                 2. a.grade = b.a1 * 2
                 3. b.a2 = a.grade + 5
             * 이걸 쉽게 구현하겠다고, a.@commonCtor(), b.@commonCtor() 각각 불러버리면, a.grade = b.a1 * 2가 먼저 실행된다.
                 * 그런데 이때의 b.a1은 아직 init 되지 않았으므로 값이 0이겠지.
                 * 그래서 위의 예상과는 다른 결과가 나온다.
         1. pack.orgs를 expand(완성) 한다.
             1. pack.orgs로부터 expand배열을 만든다.
                 * expand는 생성자에서 orgObj를 하나 받는다.
             2. 만든 expand배열을 하나하나 start() 한다.
                 * start() 하면
                     1. meobj로 frameInteract한다.
                     2. preEval() 찾아서, len을 비교한다. 만약 같거나 크다면 더 expand할게 없는 것이다.
                     3. preEval()의 맨 앞의 stmt를 빼와서, expand시도한다. 결과는 3종류다.
                         1. SUCCESS: 이경우, preEval()에서 이 stmt를 제거한다.
                             * 주의할 점은 expand::onVisit(defAssignExpr&) 등에서 다음 3가지를 이미 처리했을 것이다.
                                 1. me.subs()에 dummyNode 대신 orgObj를 제대로 찾아서 넣었다.
                                 2. me.@commonCtor()에 orgObj를 제대로된 expr로 run에서 assign 하는 expr을 넣어두었다.
                                 3. me가 complete object라면 pack.@init 에도 2번에서 변환한 assign 하는 expr이 들어가 있을 것이다.
                         1. TRY_AGAIN이라는 warn이 있는 경우
                             * TRY_AGAIN은 expand에서만 사용하는 특별한 경고다. 에러는 없지만, 의존성 문제 때문에 해결이 불가능하니 다른걸 먼저 해보자는 얘기다.
                             2. continue한다. 즉, 다른 expand를 try한다.
                         2. ERROR: 명확한 에러다. 어짜피 실행은 절대로 안된다. 그래도 계속 해보자.
                             * 이 stmt를 그냥 preEval()에서 제거한다.
                             * expand 밖에서 이 error을 보고 처리해줄 것이다.
                     4. 참고로, 3번에서 stmt.accept()를 하면 expand가 시작되는데,
                         * expand라는 말이 걸맞게 onVisit시, verification만 하는게 아니다. 에러가 없을 경우 expr을 실행해서 sub를 만드는 게 목적이다.
                         * expand는 타입추론을 동작한다. 코드를 실제 run 하는 게 아니다.
                         * 예를들어 expand::onVisit(defAssignExpr& e) 가 오면,
                             1. super::onVisit(e)를 돌린다. 에러있으면 바로 return
                             2. 추가로 체크할 것을 한다.
                             3. 그래도 에러가 없다면, 이미 추가된 sub에 새로운 tstr을 만든다. 이떄 tstr의 type은 orgObj.type, value는 orgObj가 들어간다.
                                 * 참고로 getEval()은 orgObj를 반납하는 함수다.
                             4. 그리고 @commonCtor()에 defAssignExpr을 assignExpr()로 변환하여 넣어준다.
                             5. 만약 me가 complete object라면 pack.@init() 에도 4번 expr을 push 해둔다.
                                 * 당연한 얘기겠지만, 4번을 그대로 shallow 해서 push하면 된다. clone() 할 필요는 없다.
                         * 예를들어 expand::onVisit(getExpr& e) 를 만나면,
                             1. 먼저 obj.directSub()에 e.subName이 있는지 체크한다.
                                 1. 있으면 볼것도 없이 성공 return
                                 2. 있긴 한데, dummyNode면 TRY_AGAIN return
                                 3. 없으면 me.dependencies 루프를 돌면서
                                     1. dependency.org를 가져와서
                                     2. org.getState() >= EXPANDED 체크한다. 아니라면 continue 로 다음 dependency 획득
                                     3. 맞다면, org.sub(e.subName) 으로, 여기서 찾는다. 있으면 found = true로 표시후 continue, 없으면 그냥 continue
                                         1. 만약 org.sub(e.subName)으로 찾았는데 found가 이미 true라면, with 2개에 모두 들어있는 상황이다. conflict다. 확실한 에러로 return한다.
                                 4. 그래도 없었다면 정말 없는 것이다. 확실한 에러로 return.
                 1. start()의 enum의 결과가  ERR이면 발생했다면, 이 expand를 지우고, 다음 expand를 실행한다.
                     1. 외부에 전달할 report에는 이 에러가 확실히 담겨야 한다.
                 2. TRY_AGAIN이면 다음 expand로 continue.
                 3. SUCCESS라면 이 obj에 대해 모든게 expand된 것이다.
                     1. 그 expand.obj에서 preEval()을 제거한다. 이제 필요없다.
                     2. 이 expand는 제거한다.
2. [u] mark and eval 방법 ==> **이걸로 합시다**
    * 알고리즘 개요
        1. A 구문을 expand 시도 하기 전에 mark 해둔다.
        2. A를 expand 시도한다. 그 도중 B에 접근하는 경우 B도 재귀적으로 시도한다. (당연히 1번과정 부터 반복한다.)
        3. 만약 A expand하려고 봤더니 이미 mark 되어있으면 순환참조 에러가 발생한 것이다.
    * 필수 조건
        * 하나의 orgObj에 대한 expand가 최종 SUCCESS가 되면,
            1. 이 orgObj의 모든 sub에 대해서 prop, func의 param에 있는 getExpr()을 orgObj로 교체한다.
    * 알고리즘
        * obj::run()을 통해 객체가 복제될때, with은 복제되지 않는다. 생성자를 통해서 직접 expand된다.
        * visitor는 기존의 \_visited 가 있었지만, 이걸 enum으로 상태를 더 세분화해야 한다. 그 enum은
            * VISITED
            * VISITING
            * NOT_VISITED
        * parse 단계
            * orgObj에게 **이 sub str에 대한 초기식 주세요** 할 수 있어야 한다.
                * 그리고 node.sub()를 할때 반환값이 node& 것도 있어야 하지만, str&도 줄 수 있는 방법이 있어야 한다.
                    * 위 이유도 그렇고, verifer가 isSub() 같은 데서 type도 알아야 하니까.
                * orgObj는 preEvals 라는 map<str*, tstr\<expr\>> 을 하나 들고있으면 되겠다.
            * incomplete 이건 complete이건 생성자가 호출되면 초기화식이 먼저 호출된다. 이 초기화식 run하는 함수를 @preCtor라고 한다.
            * `def A`의 sub를 파싱할때,
                1. sub가 링킹문제만 해결하면되는 경우라면 subs()에 add하고.
                2. 타입추론까지 해야되는 경우라면 orgObj.preEvals에 push() 하고 orgObj.subs().add(name, dummyNode)를 해둔다.
        * expand 단계
            * 목적은, 타입추론하고 with를 expand해서 객체의 형태(sub 의 종류, 갯수, type)을 확정시키는 것이다.
            * 당연한 얘기지만, with 를 expand할때,
                * expand단계에서는 with의 타입이 뭔지 getEval()만 할 수 있으면 성공이다.그걸로 일단 with expand를 하고 있으면 된다.
                * 하지만 preRun 단계에서 진짜로 with를 expand할때는, @commonCtor 안에서 with에 있는 expr을 먼저 run()해서 그 결과로 나온 obj의 scope을 가지고 with expand를 하게 될 텐데,
                * 여기서 중요한 점은 expr을 먼저 run()을 --> with에 이름이 있는 경우라면 나온 obj로 with prop에 할당 --> prop의 scope을 objscope의 아래쪽에 쌓기
                * 로 돌아가야 한다는 점이다.
                * 이렇게 해야 3개 이상의 depth로 with를 한 경우에도 의도한 대로 동작한다.
                    ```go
                    def A
                        age int
                        with @B
                    def B
                        age int
                        with @C
                    def C
                        age int
                            get: foo()
                        ...
                    A.B.C // ok
                    a A
                    a.age // A::age
                    a.B::age // B::age
                    a.C::age // C::age 가 나와야 한다.
                             // 그럴러면 a는 C를 가지고 있어야 한다.
                    ```
            * 초기식은 반드시 위에서 아래로 run 되는게 아니다. 종속성에 따라서 뒤에껄 먼저하고 앞에껄 할 수도 있다.
            * getExpr을 만나면 dependencies를 뒤져서 with인 애들에도 있는지를 꼭 체크해야 한다.
                * with 애들에 있는데, me.subs()에는 없었다? ==> with가 아직 expand 되지 않았다는 얘기다. with가 뒤에 있거나, with 앞에 있었는데 다른 sub에 의존적이라 TRY_AGAIN되었다는 거지. 이 withExpr.accept()를 해야 한다.
            * expand 때는 초기식을 run() 할 수 없다.
                * why? 초기식에 함수를 참조하고 있다면 어떨까? 그 함수를 verify해야 할 것이다. 그런데 그 함수 안에서 이 객체를 참조하고 있다면 어떨까?
                * 충분히 돌릴 수 있는 코드지만, expand때에는 run()이 불가능하다는 걸 알 수있다.
                * 참고로 kotlin은 초기식에 함수도 쓸 수 있다. 그러니 나도 지원해야지.
            * 아직 초기화되지 않은 값에 접근을 허용하면 매번 값이 달라지게 된다. 그러니 이걸 verify에서 탐지해서 반드시 에러로 처리해야 한다.
                * kotlin은 초기식의 실행순서가 좀 완벽하지 않다. 어떻게 하면, 초기화되지 않은 값 (즉 기본값인 0)을 참조해서 eval하는 경우도 있다. 그런데 일체의 오류도 발생하지 않는다.
                * 내 언어는 중간debug를 전제로 하고 있기 때문에 가장 중요한 것은 속도와 더불어 정합성이다.
                * 중간debug를 했을때와, 처음부터 verify를 했을때의 값이 동일해야 한다는 것.
                * 그러니 나는 이 기능을 kotlin과 달리 완벽하게 지원할 필요가 있다.
            * expand에서 초기식이 안되므로 expand에는 초기식의 eval타입을 추론해서 sub를 만들어두는 정도로 해야 한다.
            * expand단계가 진행되는 시작부터 끝까지 항상 **orgObj.subs()에 있는 prop, func의 params는 모두 getExpr()을 orgObj로 교체된 상태**여야 한다.
                * 즉, expand시작과 동시에 subs()에 있는 것들을 orgObj로 교체한다. (1회성)
                * 진행중 org.preEvals안에 있는 expr은 orgObj로 교체된 후에만 subs()로 이동한다.
            * initExprVisitor를 만든다.
                * 이것은 초기식에서만 사용할 것을 전제로 한 것이다.
                * 다음과 같은 상황에서만 다른 node로 visit을 시도한다.
                    * `A.B` 상황인 경우 B.accept()
                    * `B` 에서 B가 getExpr인 상황인경우 B.accept()
                        * 같은 `B` 더라도 `foo(B)` 인 경우는 verification만 할뿐, visit은 하지 않는다.
                * 이 클래스는 2단계에서 사용된다.
                    1. expand단계에서 orgObj의 sub를 모두 verify하고 확정하고자 하는 용도 (+ with expand)로 사용된다.
                    2. preRun 단계에서 expr을 run해서 실제로 값을 넣고자 하는 용도
                * 2개 단계에서 visit한다는 구현은 동일하지만, 그에대한 onVisit() 전혀 다르다. 그러니,
                    * class expander : initExprVisitor
                    * class preRunner : initExprVisitor
                * 2개 클래스를 각각 만든다.
        * verify 단계
        * preRun 단계
            * complete 객체인 경우는 preRun단계에서 일괄적으로 ctor가 호출되면서 값이 모두 정해진다.
        * run 단계
* * *
# [o] 기본생성자와 생성자 안에서의 with는 어느것이 더 우선인가? ==> **--> #with_verification_로직 으로 해결했다**
* why?
    ```go
    age := 22
    def A
        ....
    def Util
        age int := 2
        ctor(age)
    def B
        with a A(b, c)
        with u Util
        grade := 4.5
        b := age + 5 // 1
        ctor()
            u = Util(2)
        ctor(n int)
            age++ // 의도한 것은 u.age++였을 것이다. 그러나 u는 null이므로 에러다.
            .age++ // .을 붙이면 packScope를 접근한다.
            r := random().between(grade)
            u = Util(r) // 2
    ```
    * 1번의 age는 과연 22일까 아니면 2일까??
        1. [d] 2로 하게 한다. ==> **꾸역꾸역 실행시키는 로직이 좋은게 아니라, 사용자에게 실패한 현재상황을 알려주는게 베스트다. 이 방법은 아니지.**
            * 이 얘기는 `u = Util(u, z)` 코드를 실행하고 난 뒤에 b := age + 5가 되도록 코드를 변경하겠다는 것이다.
            * 그럼 가장 현실적인 로직은 `with 혹은 with인 prop에 assign하는 생성자 코드를 항상 먼저 실행한다` 가 되겠지.
            * 그럼 2번을 볼까? 이거 되야 하나, 안되야 하나?
            * with에 assign하는 라인보다 일반 prop을 참조하는 코드가 먼저 나오니 로직이, 머리속이 복잡해지지?
            * 그럼 이 코드를 이해하게 될 사용자도 마찬가지가 아닐까?
            * 이 방향은 아니라는 걸 알 수 있다.
            * 사용자도 충분히 예측이 가능하면서, 중복 에러가 발생했다는 걸 고지하고 사용자가 그걸 고치도록 하는 것이 가장 좋은 해결방법이란 얘기다.
        2. [u] 에러를 내뱉는다. 왜? u는 아직 null이니까. ==> **구현은 --> #with_verification_로직 을 참조하자.**
            * 이 얘기는 `u는 null이고, scope도 inject가 되진 않았지만 u에 age가 있으니 여기선 age가 참조되어야 하는데 age가 null이니 에러를 내보내야 하겠네!` 라는 에러를 처리할 수 있어야 한다는 거겠지?
            * **사용자 입장에서 바라보자. 이건 반드시 구현되어야 하는 기능이다.** 구현하는 사람이 힘든거지.
            * [x] 아니면 그런 에러조차 보내지 않고 1번 코드의 age는 그냥 packScope의 age인 22로 간주하고 실행하게 하나?? ==> **무조건 에러가 나가야 한다. 이론의 여지가 없다.**
            * [?] 이 과정을 처리하는 간단한 로직은? ==> **별도의 항목으로 논의한다. ==> #with_verification_로직**
        3. [d] 초기식을 지원하지 않는다.
* * *
# [x] prop 생성 로직을 clone이 아니라 blockFunc으로 한다. 그리고 preCtor의 재탄생 ==> **없던 걸로 하면 된다. 통일된 로직은 만들 수 없고, 그냥 --> #with_verification_로직 가 더 좋다.**
* 기존의 객체 복제로 생각했던 것은 orgObj.clone() 이었다. 효율적이었으니까.
* 하지만 상속과 with 때문에 이 방법은 어렵게 되었다.
* 그래서 나온 것이 초기식과 with를 생성자 앞부분에 넣자! 라는 거였다.
* 하지만 그것보다는 공통ctor을 하나 만들어서 여기에 초기화 로직과 with를 한데 몰아두는 게 좋을 것 같다는 생각이 든다.
* 이유를 제시한다.
    1. 기존의 알고리즘은 sub node의 생성과 초기화가 2분화 되어있었다. 그리고 이게 문제를 발생시킨다.
        * 기존에 방식은,
            * defVar인 경우는 일단 sub node에 inference된 `type`이 주입된 빈 str 을 일단 넣어둔다.
            * defAssign인 경우는 preCtor에 넣어둔다.
            * **일관적이지 않지? 이걸 쉽고 간단하면서도 하나의 통일된 rule로 합치려는 것이다.**
            * 그리고 생성자에서 assignExpr()을 사용해서 데이터를 넣는 방식이었다.
    2. 생성자마다 초기화expr을 복붙하는 것보다 하나를 만들어서 쓰는게 훨씬 효율적이다.
    3. 기존 방식은 같은 def obj 내라면 어떻게든 꾸역꾸역 실행시키는 방향이었지만, 지금 생각해보면 되려 에러가 쉽게 발생할 것 같다.
        * 그냥 위에서부터 아래로 변수를 정의하도록 하는게 자연스럽다.
        ```go
        def old
            grade := age + 5 // 예전에는 이렇게해도 동작했었다. age가 밑에 나오긴 하니까. 밑에껄 먼저하고 위에껄 알아서 하도록 설계했던거지.
            age := 0
        def new
            age := 0
            grade := age + 5 // 근데 이렇게 해야만 컴파일되도록 하는게 맞는것 같다.
        ```
* 이 개선은 with에도 영향을 미친다.
```go
age := 22
def A // 불완전객체
    ctor(n int): ...
    age int // 초기값 0

def B
    grade := age + 5 // 27이다. pack.age가 참조되니까.
    with @A := A() // 1: ok. 이 시점에서 objScope의 A는 나오지 않았기 때문이다. 이 라인이 끝나야 objScope의 A가 나온다.
    //with @A := .A() // 위와 같은 코드다.
    grade := age + 5 // 2: 이때의 age는 A.age를 참조한다.
```
* 2번을 보면 얼마나 이 문법이 misleading 하기 쉬운지 단적으로 잘 보여준다.
* 간편하고 간결하지만, 그거야 코드를 아는 사람이 그런거고.
* 처음보는 사람은 age가 어디서 오는 age인지 한번에 알기 힘들다.
* 해결방법은?
* [x] 다른언어들은 어떻게 할까?
    * [x] 코틀린, 자바 ==> **변수을 이미 다 만들어 놓고나서, 초기식을 돌리는 것처럼 에러를 내보낸다. 즉, 초기화되지 않은 변수에 접근한다는 식으로 에러를 내보내는 것이지**
1. [d] packScope은 모두 `.` 을 붙이도록 한다?
    * 근데 이렇게 하면 .A의 함수에서 B를 접근할때 .B로 해야한다. 이런 문법은 어디에서도 본적이 없지.
2. [d] preEval 가기 전에 변수가 들어갈 자리는 있지만, 아직 객체가 binding되지 않은 상태를 만들어놓고나서 공통ctor을 돌린다.
3. [d] 그냥 사용자보고 조심하라고 한다.
    * [x] 함수 안에서도 이 상황은 발생하지 않는가?? ==> **예. 발생한다.**
    * [x] 심지어 protected로 선언하면, 같은 파일에 field가 없더라도 문제는 재현되지 않나? 마치 이문제와 똑 같은 상황이 되지 않나? ==> **네. 재현된다.**
    * 그러면 우리는 이미 함수안에서 조심해서 쓰는 거에 익숙해져 있잖아. 여기서도 똑같이 하면된다. 왜냐면 초기식 블록은 사실 공통 생성자니까. 함수 안의 body 니까.
    * 똑같은 rule에 지배받는게 맞다.
    * 그래. 그런데 에러를 최소화하고 가독성을 높이기 위해서 with를 앞에다 두자고 하자.
4. [d] with 상속은 항상 앞에 나오도록 한다. ==> **다른 언어들은 이러한 제약이 없다. 그러니 나도 없는게 맞다.**
    * with가 앞에 있지 않으면 컴파일 에러다.
    * [d] 컴파일시 알아서 위로 땡겨주면 되지 않을까? ==> **with의 순서는 어떠한 age를 참조하느냐는 섬세한 문제가 된다. 알아서 위로 땡겨주면 어떨때는 정상동작하고 어떨때는 오작동하게 될 수 있다. 절대 안된다.**
5. [u] `지금은 무슨타입인지 모르지만, 나중에 with로 한다고 해놓았네? 그러니 일단 에러야.` 로 처리한다. 뒤에 적히든 앞에 적히든 알아서 의존 문제를 푼다 --> #with_verification_로직 으로 이걸 해결했다.
    * 위의 `why?` 에 나왔던 몇가지 생각이 잘못되었다는 걸 알아서 요점을 정리해본다.
        * `일관적이지 않지? 이걸 쉽고 간단하면서도 하나의 통일된 rule로 합치려는 것이다.`
            *  먼저, 이 글에는 의도가 드러나지 않았지만 전제조건이 하나 잘못되어있는 걸 바로잡자.
                * `A B` 의 경우 B를 `getExpr("B")` 라고 파싱된다. 저 글을 쓸때는, `이 상태로 바로 run단계에서 수행하면 되겠지?` 했고, 실제로 기존 코드는 구현도 그렇게 되어있다.
                * 하지만, 저걸 수행할때의 stackFrame이 어떻게 되냐에 따라서, 다른 객체가 나오는 문제가 있기 때문에, `getExpr` 부분을 `orgObj`로 교체를 해줘야만 한다.
                * 이 과정은 일종의 링킹 과정이라고 할 수 있다.
                * 참고로 함수 내에서 `A B` 하는 경우는 기존대로 getExpr()로 파싱을 해서 그대로 쓰면 된다.
                    * 함수내에서의 stackFrame은 `그 함수를 가진 obj`라는, 항상 일정한 타입이 들어오기 때문이다.
            * 2번째로 링킹만으로는 안되는, 타입추론이 들어가야만 하는 초기식이라는 게 존재한다.
                * 바로 `A := B` 같은 표현식이다. B가 표현식이기 때문에 B안에는 함수호출이나 다른 복제객체의 prop에 대한 참조도 있을 수 있다.
                * 즉 expr이므로 다른 node에 대한 종속성을 잠재적으로 가질 수 있다는 점이다.
                * 이 점이 이 문제를 까다롭게 만든다. 이 얘기는 expr의 타입추론을 할때 일정의 순서를 찾아서, 그 순서대로 따라가야 종속성문제를 풀 수있다는 얘기가 되니까.
                * 자세한 알고리즘은 --> #with_verification_로직  을 참조하자.
                * 타입추론을 돌려야 하는 경우, 일단 orgObj.preEvals에 defAssignExpr 채로 넣어둬야 한다.
                * 하나의 통일된 로직을 한다는 것은 모든 것을 orgObj.preEvals()에 넣는다는 건데,  preEvals에 담긴 것들은 최종적으로 orgObj.subs()에 들어가게끔 하는 게 목적이다.
                * 그러니 의미가 없다.
        * `2번을 보면 얼마나 misleading하기 쉬운 문법인지 알 수 있다.`
            * 그래서 expand 단계에서 with를 뒤져가면서 `어 너 with에 이거 expand하겠다고 해놓았네. 아직 with는 expand 안되었지만, 여기서 쓴 이 식별자는 with에 있는 얘가 되야만 해.` 같은 로직이 돌아가게끔 했다. 이제 misleading은 없다.
            * kotlin도 이렇게 돌아간다.
* * *
# [o] #완전객체인지_여부는_어떻게_판단하는가_with의_완전객체문제는_어떻게_해결하는가 ==> --> #verification_단계에는_객체를_직접_만들지_않아도_최적화_방법이_있다
* [?] 완전객체인지 아닌지를 판단해서 완전객체가 아닐 경우 에러를 내뱉는 것은 일반적으로 어디에 구현이 되어 있는가? 누가 그 역할을 하는가? ==> **verifier가 orgObj에 대해 getExpr()를 하는 순간 orgObj가 완전객체인지 확인한다.**
* 아직 완전객체 부분은 구현이 되어 있지 않다. 하지만 설계는 이랬다.
    * preEvaluator는 obj가 가진 초기화 구문(== 생성자호출구문)이 비어있을 경우, INCOMPLETED로 변경한다.
    * verifier는 obj에 대해 sub()를 요청한다.
    * obj는 자신의 상태를 조회하고 INCOMPLETED로 나온다.
    * verifier는 onVisit(getExpr&)에서 접근하려는 node가 불완전객체인지를 항상 체크하고, 아닐 경우에 접근을 시도한다. eval이 나오지않으면 에러를 내보낸다.
* 보다시피 전체로써 완전객체인지 아닌지를 판단하고 있을 뿐. sub하려고한 대상을 가지고 있는 진짜 객체가 완전인지 아닌지를 판단하거나 하는 코드는 없다.
* 그럼 어떻게 할까.
* 고찰 -> 추가요구사항
    * 현재의 preEval단계에서의 with 알고리즘을 먼저 보자.
        * 초기식구문과 함께 @preCtor에 담겨져 있다가 무한루프를 돌면서 eval을 시도한다.
        * eval한 node가 완전객체가 아니면 에러로 기록하고 해당 구문을 초기식 구문 리스트에서 없애버린다. 이후, with expand가 되지 않은 채로 검증을 계속한다.
        * `eval이 실패했거나/가져온 eval이 PRE_EVALED 상태가 아닐 경우`, 다음 try를 위해서 초기식구문리스트에 남겨진 채로 다음 초기식구문/withExpand구문을 꺼낸다.
        * [x] 함수를 통해서 `with`를 하는 경우 완전과 불완전인지 검증당시와, 실행단계에서의 각 eval 객체가 달라지는 경우가 있지 않을까? ==> **그런 상황은 없다. 불완전객체를 코드에서 반환하거나 접근하는 순간부터가 에러다. 어딘가에는 에러가 발생했을 것이다.**
            * 말로만은 무슨 상황인지 와닿지 않지? 코드를 보자.
            ```go
            def A
                a := getSub()
            def Sub // 불완전
                me(n int): ....
            def SubImplA Sub // 완전
                me(): super(5)
            def SubImplB Sub // 불완전
                me(n int): super(n)
            getSub() Sub
                return if Random.toInt() % 2 == 0
                    SubImplA
                else
                    SubImplB(0)
            A.a
            ```
            * 검증 당시에는 SubImplA가 나왔을 수도 있다. 이 경우 a에 할당된 객체는 완전객체이므로 문제에서 벗어난다.
            * 그러나 실행단계에서 운이 나쁘면 SubImplB이지도 않겠냐는 얘기다.
            * 문제없다. 왜냐하면...
                * SubImplB(0)은 완전객체다. 불완전을 표현하려면 `return SubImplB` 라고 했어야지. 그런데 이렇게 적는 순간 에러다. 불완전을 코드에서 반환하거나 접근하면 에러니까.
                * 그러니 불완전객체를 코드에서 적는 것 자체가 불가능하다.
        * 그러니 preEval 단계에서 불완전 객체가 with에 사용되는 케이스는 **전혀 없다.** ==> **이 사실은 매우 도움이 된다.**
        * 즉 내가 `A`객체와 거기에 속한 `sub`와 그 sub과 A의 직계scope인 `scope` 이 3가지만 있으면 verifier는 에러인지 아닌지 검증할 수 있다. 알고리즘은 다음과 같겠지.
            * verifier::onVisit(getExpr& e)
                1. e를 eval 시도한다.
                2. eval 실패시 에러다.
                3. eval 성공시,
                    1. 그 eval이 완전객체인지 확인한다. 완전객체면 더 볼 필요 없다.
                    2. 완전객체가 아니라면, e 로부터 owner obj인 A를 꺼낸다.
                    3. A에게 eval이 with로 된 sub인지, 아니면 A 혹은 A 기반클래스 중의 sub인지를 확인받는다.
                    4. with로 된 sub라면 더 볼 필요없다. preEval단계에서 with로 expand된 객체는 완전객체임을 확인했기 때문이다.
                    5. with로 된 sub가 아니라면, A쪽 sub라는 얘기고, 이는 실패로 이어진다.
        * 정리하면 추가 요구사항은 `객체A와 sub가 있을 때, sub가 A 혹은 A의 조상클래스들에서 상속받은 subnode인지, 아니면 with로 expand된 것인지 구분할 수 있는가? 단, 기반클래스의 expand된 with도 with로 구분한다` 가 된다.
    * 다음 상황은 어떻게 되지?
        ```go
        def A
            foo() void = null
        def Sub
            foo() void ....
        def Sub2
            foo() void
        def B A
            with Sub()
            with Sub2()
            foo() void // 경고를 막기 위해 foo 추가. 이게 없으면 Sub2.foo()가 대신 실행된다.
        ```
        1. B는 preEval단계에서 Sub()가 먼저 expand, 그 다음 Sub2()가 expand, 그리고 그 위에 B객체의 foo()가 올라가 있다.
        2. getExpr("B", "foo") 를 실행하면 B.subs()에서 `foo`를 찾는다.
        3. B의 subs()가장 위에 있는 것은 B객체의 foo()다. `B객체의foo()` 를 반환한다.
        4. verifier는 `B객체의foo()`를 두고 검증에 들어간다. 이 함수는 어느 with냐고, 아니면 orgObj에 있는 거냐고.
1. [d] 생성자 안에 있을 withExpandOnlyExpr을 사용한다.
    * verification에 진입 했을 때 이미 expand시도가 되어있을 것이다. 그러니 아무거나 생성자를 찾아서 맨 윗줄부터 withExpandOnlyExpr 목록을 찾으면 이걸 통해서 어떤 객체들이 with로 expand되었는지 알 수 있다.
    * 근데 딱 들어도, 굉장히 복잡해 보인다.
        * 일단 withExpandOnlyExpr을 제대로 돌릴려면 me를 set 하는 게 필수 일 것이다.
        * 그리고 객체를 찾고나서도, 객체마다 또 sub() 탐색을 돌아야 한다. 그 안에서 또 루프를 돌겠지.
2. [d] preEvaluator가 처리한다. ==> **아니다. 만들어질때는 괜찮다. 접근할 때, 접근한 함수가 with꺼인지 with가 아닌거인지가 문제기 때문에.**
    * preEvaluator는 어짜피 withexpand를 할 의무가 있으니까.
    * [x] 맞지? 구체가 불완인데 기반이 완전이면 접근허용했을때 문제가 생기는 상황을 예시로 찾아보자. ==> **그래. 구체가 불완이면, 기반이 완전이어도 접근을 허용하면 안된다.**
        * 마치 싱글톤이 기반클래스가 있을때.. 라는 말처럼 들리네.
        ```go
        def org
            doSomething() void: ...
        def A()
            foo() void
                getOrg().doSomething()
            _getOrg() org = null
        def B A// 불완전
            _org Org
            me(newOrg org): org = newOrg
            _getOrg(): org
        B.foo() // 런타임 에러
        ```
       * 역시 에러였다. 내가 찾아낸 위의 코드를 보자.
           * B는 불완전객체다. 하지만 B.foo()를 했을 때, foo()는 A에 있다. 그러니 위의 논리라면 이건 호출이 가능해야 한다.
           * 그러면 A::foo()는 어떤가? getOrg()를 호출하는데 이건 B::getOrg()에서 overriding 되어 있다.
           * 그러나 B::getOrg()에서는 sub인 \_org를 반환한다. 이 \_org는 생성자에서 넣어줘야 하는 것이다.
           * 그런데 B는 불완전이랬지? 그러니 org는 없는 상태이기 때문에 NPE가 발생한다.
3. [d] subs(), scope 을 이용한다.
4. [d] obj는 기본적으로 false로, obj에서 상속받은 orgObj는 INCOMPLETE여부를 반환하면 되는거 아닌가?
5. [u] --> #verification_단계에는_객체를_직접_만들지_않아도_최적화_방법이_있다  로 해결한다.
    * 요약하면,
        * proxyNode라는걸 만든다. 얘는 isComplete()시 반드시 true를 반환하고 나머지는 다 delegation한다.
        * verification에서 defVar, defAssign을 만나면, verifier는 기존코드에서는 orgObj.clone()을 했다. 왜냐하면 객체를 복제해야 isComplete()가 항상 true가 되니까.
        * 근데 이제는 verifier가 그냥 proxyNode(orgObj) 하면 된다.
        * orgObj.isComplete() 는 단순히 orgObj가 생성자호출 정보가 있는가 없는가로 결정된다.
* * *
# [o] #프로퍼티_구현_알고리즘 ==> **class prop을 만들고, commonCtor에서 매번 new prop(meObj) 로 생성한다**
* Why?
    * 프로퍼티는 me pointer가 필요하다.
        * 프로퍼티 get() 이나 set() 안쪽에서 me의 scope을 전제로 다른 prop들에 접근하거나 func을 호출하기 때문이다.
        * 즉, instance가 바뀌면 이 프로퍼티는 다른 me를 참조하도록 해야 한다.
        * 어떻게 할까?
1. [d] me를 외부에서 일일이 넣도록 한다. ==> **cast하는데도 me obj를 넣어야 하게끔 된다. 이건 좀 이상하다.**
    * 이 경우 node로부터 값을 꺼내는 onGet(obj&) 같은 함수를 하나 만들어서 호출하는 형태가 되겠지.
    * 그런데, node로부터 값을 꺼내는 동작이나, node를 다른 타입으로 cast 하는 동작이나 사실상 같은 거라는 걸 알아야 한다.
    * 따라서 이얘기는 cast하는데도 me obj를 넣어야 한다는 뜻이 된다.
    * 그건 좀 이상하지.
2. [u] `with` 처럼 매 obj 복제시마다 me obj가 갱신된 property를 새로 만들어서 넣는다.
    * 일단 구현은 자연스러울 것이다. with처럼 orgObj.preEvals에 넣어두기만 하면 된다.
    * 그리고 prop.getEval()에서 반환할 str \_eval과 여기에 들어갈 orgObj을 하나 들고 있어야 한다.
        * 이 또한 defVar처럼 parse단계에서는 \_eval에는 getExpr이 들어있을 것이다.
        * 그러다가 expand에서 직후 subs() 하면서 이 getExpr이 적절한 orgObj로 교체하면 된다.
    * expand시, prop의 경우는 어떻게 하기로 했는지 떠올려보자.
        * 초기식인 expr이 없는 경우이기 때문에 (함수로써 get()안에 들어가 있는거지. 밖에 초기식으로 빠져나와서 타입추론에 영향을 주거나 하는 상태는 아니다.)
        * preEvals에 있는 prop은 바로 subs()로 옮겨주고, @commonCtor에 이 prop에 대한 assign을 해주는 코드를 넣어주기만 하면 된다.
    * [u] parse 단계에서 preEvals에 넣지 말고 바로 subs()로 옮기도록 하면 어떨까? ==> **parser는 일단 일반함수라고 생각해고 defProp, defVarExpr을 파싱하자. expand에서 subs()에 있는 것들을 재 평가하자.**
        * 로직이 좀 양분되긴 하지만, 그건 넘어가자.
        * [x] 함수가 있는 prop은 어떤 형태로 파싱될까?
            * prop은 class prop : obj 라고 정의될 것이다.
            * 얘는 안에다가 str meObj를 가지고 있을 것이고,
            * func 2개를 가지도록 하면 된다.
            * 이 함수 2개는 각각 "@get", "@set" 으로 이름을 지어주자. namu 코드상에서는 호출이 불가능하도록 하는 것이다.
            * parser의 문법은 아마도,
                * defPropExpr: NAME NAME  --> defVarExpr을 defPropExpr로 이름을 고치자.
                * accessor: "\_" | @empty
                * propGetFunc: accessor "get" blkStmt | accessor "get"
                * propSetFunc: accessor "set" blkStmt | accessor "set"
                * defPropFuncs: propGetFunc propSetFunc | propSetFunc propGetFunc
                * defCustomizedPropExpr: defPropExpr defPropFuncs
            * 식으로 될 것이다. 그래서 defCustomizedPropExpr은 넘어온 defPropExpr인스턴스에서 데이터를 뽑아내서 새로운 prop 객체를 만들어서 넘기면 될 것이다.
        * 기존 코드를 생각해보자. defBlock에서 subs()를 뒤질거고, 이 때 defCustomizedPropExpr이 나온 걸 확인되면 이 expr에서 데이터를 뽑아내서 subs()에 넣어둔다.
        * 이렇게 하는 이유는  defVarExpr, defFunc 을 파싱할 당시에, 이 defVar가 들어가게될 block이 defBlock인지 일반 block인지를 알 방법이 없다는 점이다.
        * defVarExpr이 일반 함수 안에서 사용이 가능한 것처럼, defPropExpr도 일반 함수 안에서 가능해야 할 것이다.
        * [x] 현재의 defBlock parse 구문을 변경해서 안쪽의 defVarExpr이 파싱될때 `아, 나는 지금 defBlock 안에 들어가겠구나` 를 알리는 방법이 있는가? ==> **없다**
            * 안될 것 같다. rightMost derived잖아. 즉 가장 오른쪽에 있는 것부터 확정되어야 좌측이 확정되는 구조다.
            * 좌측이란 대개 더 큰 개념. 우측이란 대개 더 작은 개념.
            * defobj: "def" NAME INDENT defblock
            * defblock: empty | defblock defstmt
            * defblock: empty가 먼저 fix되므로 여기서 뭔가를 해주면 되지 않겠냐는 생각이 들지만, defstmt가 fix되는 순간에는 내가 defblock안에 있는지에 대한 연관성은 전혀 없다.
            * defstmt가 나와야 defblock이 이를 인지하는 구조다.
            * 그러니 거의 불가능에 가깝다. 상향식 파서인 셈.
        * parser는 defVarExpr과 defPropExpr는 항상 일반함수에서 파싱되는 것을 전제로 작성한다.
        * 나중에 expand 시작직후에 orgObj를 순회하면서 subs()에 있는 것들을 재eval하는 단계가 있다.
        * 여기서 안에 있는 defVarExpr과 defPropExpr을 찾아서 적절한 obj나 prop 객체로 바꿔주고 일부는 @commonCtor에 넣어주는 역할을 수행하도록 하는게 좀 더 좋을 것 같다.
    * prop 에 대고 as()을 호출하게 되면 내부에서 getFunc을 호출한 결과를 가지고 캐스팅을 하도록 하자. 이 func을 호출하기전에 당연하지만 가지고 있는 me를 frameInteract 해줘야한다.
    * set/get은 소괄호를 적지 않는다.
    * set의 경우는 코드상에 명시되어 있지 않지만 prop.getEval() 타입으로 정의된 `rhs` 라는 param이 정의되어 있다.
    * get/set 안에 it을 쓰게 되면 prop에 값을 정의해서 이 값을 사용하겠다는 뜻이다.
    * get의 반환형은 당연히 prop.getEval() 타입이다.
    * set의 반환형은 void다.
    * get/set을 명시하지 않으면 기본동작이 된다.
        * innervalue를 지정한 경우라면 기본동작은 당연히 it = rhs, return it 이 된다.
        * innervalue가 없는 경우라면 기본동작은 당연히 `호출불가` 가 된다.
    * 값이 없는 prop은 `A B` 형태로, 값이 있는 prop은 `A := B` 의 형태로 정의하고 get/set을 채워야 한다.
    * 값이 있는 prop의 경우, str \_value 에 실제로 복제된 객체를 넣어둔다. 그리고 prop의 get/set 함수를 call하기 전에 obj에 대해 frameInteract하고 나서 이 \_value가 담긴 scope을 추가한 후 func.run()을 돌리자.
    * 이렇게 하면 자연스럽게 verification때 it을 사용했는데 `A B` 로 하고 있었다면 에러로 탐지되게 된다.
    * 문법 사용 예
        ```go
        def a
            age int
                get: 33
                set: foo(rhs)
            age := 0 // 값이 있는 prop이다.
                get: it * 2
                set: it = rhs
        ```
    * [x] get은 as()가 동작할때 돌아간다는 건 알겠다. 그럼 set()은 언제 동작하지? ==> **scope::set()을 불렀을때**
        * [x] prop은 참조를 가질 수 있을까? ==> **아니오**
            * 사용자 관점에서 보자. 그러면 prop은 함수가 있는 prop이든 없는 prop이든 그냥 변수처럼 취급해야만 한다.
            * 변수가 참조를 가질 수 있는가? 라고 묻는다면 *가질 수 없다.* c++이 아니다. 하나의 객체에 대한 여러 참조를 각각 가질 순 있어도.
            * 예를 보자.
                ```go
                def C... // abstract
                def C2
                    with C
                    ...
                def A
                    a := 0 // primitive는 immutable 이다.
                    c C? //
                    c2 C
                    ctor(c2): pass
                a A(C2())
                v := a.a // v는 복제된 int다.
                c := a.c // c는 a.c와 같은 걸 가리키는 참조다. a.c 자체를 갖는게 아니다.
                c2 := a.c2 // 상동.
                ```
            * pointer 개념이 없기 때문에 참조자에 대한 참조를 밖에서 가져서, 그걸로 원본 참조자 자체의 값을 변경하는.. 식의 동작은 불가능하다.
            * 함수가 있는 prop은 assign 하려고 시도해보았자, get()을 돌려서 나온 값 혹은 객체에 대한 참조를 assign 되는 셈이지, prop 자체를 참조로 삼을 수는 없다.
            * 그러므로 prop안에 inner value는 오직 그 prop에게만 열려있고 외부에 닫혀있다.
        * 따라서 prop의 set() 이 호출되는 순간은, 오직, prop을 들고 있는 객체를 통해서 해당 변수에 `=` 를 한 순간이라는 얘기다.
        * 저 `=` 즉 assignExpr 밖에 없다. `:=` defAssign도 prop의 set()를 호출하지 않는다. 애초에 말이 안되는 문법이다.
        * 기존 코드의 assignExpr은 어떻게 동작하지?
            ```cpp
            str me::run(const args& a) {
                iter e = _getScopeIterOfLhs(); // e exists. verified.
                str ret = _rhs->as<node>();
                e.setVal(*ret);
                return ret;
            }
            ```
         scopes.set(node)의 경우에는 prop.set()을 호출하는 게 말이 된다.
    * [x] scopes.add(node) 의 경우에는 어떻지? ==> **아무것도 하지마라. scope::set()이 불려질때 프로퍼티::set을 부르면 된다.**
        * add가 불리는 것은 당연히 초기화/객체 생성 등이다.
        * 다시 말해서 이 질문은 `값이 있는 prop은 초기화 구문이 돌아갈때 set()이 불려져야 하는가?` 라는 질문이지.
        * 좀만 생각해보면 바로 알 수 있다. 그럴 일은 없다. innervalue가 있는 prop은 이미 초기식이 이루어진 상태다.
            ```go
            def A
                age := foo(22)
                    set: it = rhs / 2
            ```
    1. [u] scope.set()을 할때 node.\_onSet()을 불러준다.
        * 다음에 나올 내용이 조금 헷갈릴 수 있는데, 잘 이해해보자.
        * 먼저 mutlimap을 쓰는 이유 부터.
            * scope는 tnmap이라고 되어있고, tnmap은 multimap으로 되어있다.
            * multimap으로 된 이유는 오버로딩된 func 때문이다.
            * 문제는 multimap으로 되어있으니 scope::add 혹은 scope::set을 쓸 수 없다는 것이다.
                * key만 가지고는, 여러개의 value중 어떤것인지 구분이 안가는 상황이 되니까.
        * 프로퍼티의 set()을 불러주는 부분을 일원화 하려면 scope::add안에서 제공하는게 유리했다.
        * 아무튼 그게 안되므로 현재는 추가는 add()로, set은 iter로 하는 상황이다.
        * 그러니 다음과 같이 고쳐야 한다.
            * tnmap은 multimap으로 유지한다.
            * tnmap은 add와 별도로 set(iter&, val) 이라는 함수를 추가한다.
                * key로 하면 어떤건지 알 방법이 없으므로 iter를 쓰는 것이다.
            * iter는 setVal을 public으로 제공하지 않는다.
                * 이유는 예상이 쉽게 되지? 기존에는 iter() 함수와 iter::setVal을 사용해서 map에 대한 set() 을 대신하고 있었다.
                * assignExpr::run()으로 가보면 쉽게 그러한 코드를 볼 수 있다.
                * 우리는 프로퍼티::set()을 호출해주려고 한다.
                * 그러나 iter 클래스에서 프로퍼티에 대한 set을 불러주는 것은 개념적으로 맞지 않다. scope에서 하는 게 맞을 것이다.
            * tbicontainable은 set()을 pure virtual로, tnmap::set()을 virutal로 제공하고 기본동작을 채워놓는다.
                * 이때 set()의 반환형은 bool로 에러가 발생했는지 여부를 반환할 수 있어야 한다.
            * scope은 tnmap에서 상속한 뒤, set() 안에서 super::set()을 부르고 에러가 없으면 rhs.\_onSet()을 불러주자.
            * 마지막으로 assignExpr::run() 에서 scope::set() 을 사용하도록 수정하자.
* [u] `호출불가` 인 prop을 호출한건지 아닌지는 어떻게 verification에서 체크하는가? ==> **일단은 node.cast\<prop\>() 을 사용하자.**
    * 바깥에서 본다면 그저 `node` 클래스일 뿐이다.
    * get은 `as()` 에 의해서 호출된다. 그러니 `is(type)` 를 했을때 항상 false가 나가면 되지 않을까.
        * 그런데 이건 런타임의 동작을 막는데 적합하지, verify에서는 좀 힘들다. verify에서는 as()가 안되는 이유를 알려줘야 하기 때문에.
        * as()가 안되는건지, 아니면 prop인데 get이 정의되어 있지 않아서 결과, as()가 막힌건지를 구분해서 에러를 보여줘야만 한다.
    * verifier::onVisit(getExpr&) 에서
        * str eval로 node를 가져왔을때 if (eval->isSub\<prop\>() && !eval->is(type)) 으로 체크를 해주면 될 것이다.
    * set은 `scope`
* * *
# [o] A::B 문법 추가
* 추가된 배경
    * 이미 논의했지만, override를 계속 가져가기로 했다. 그럼 이런 문제가 생기지.
    ```go
    def A
        foo()
        boo()
            foo()
    def B
        with A
        foo()
            A.boo() // B가 아니라, A의 boo를 호출하고 싶은 것이다.
        boo()
    ```
    * 근데 A.boo()을 하게 되면 현재 구현에서는 A객체가 me가 되어서 boo()가 호출된다. 그러니 boo()안에서 foo()를 호출할때 B.foo()가 아니라 A.foo()가 호출되지.
* `A::B` 는 getExpr로 sub node에 접근할때의 scope을 제한한다. A에만 찾는 것이다.
* 이때 A는 당연히 앞에 있는 postfix나 stackFrame에서 찾는다.
* 예를보자.
```go
def A
    __age := 0
    age int
        get: foo()
    foo()
        _age++
        boo()
        ret _age
    boo(): pass
def B
    age int // override
        get: foo() + 1
    with @A // with A라고만 해버리면 with에 이름이 없는거다. 즉, A::B 처럼 호출이 안된다. 이름이 없으니까.
    boo()
        _age *= 2
    foo()
        A::foo() // stackFrame에서 먼저 A를 찾는다. with A의 A가 되겠지.
                 // 그리고 foo()를 호출하는데 me obj는 postfix가 foo()호출시 들어간다.
                 // 여기서는 postfix가 없으므로 stackFrame::getMe()가 된다.
        // 예제2:
        @A() // 지역변수
        A::foo() // 지역변수 A가 아니라 me.A::foo()가 되어야 한다.
        print(age) // 2다. 0이 아니라.
        // 예제3:
        b B
        b.A::foo() // 로컬변수 b에 대해서 동작한다.
        // 예제4:
        A::age
        b.A::age
```
* 프로퍼티에 대한 A::B는 프로퍼티 구현이 나와야 구체적으로 정할 수 있을 것이다.
* 참고로, 다음처럼 with를 할때
* 아무튼 구현 방법은?
1. [u] getExpr, runExpr을 재사용한다. ==> **응. 이걸로 될 것 같다.**
    * 일단 다음과같다.
    ```go
    def lowparser
        accessor: type { $$ = $1 }
                | NAME `::` NAME { $$ = loweventer.onScopedAccessor($1, $2) }
        func-call: accessor list {
            $$ = loweventer.onRun($1, $2)
        }
        postfix `.` func-call: { $$ = loweventer.onFillFromFuncCall($1, $3) }
    def loweventer
        onRun(f node, a arr)
            runExpr(null, f, a)
        onScopedAccessor(scopeName str, sub str)
            getExpr(getExpr(null, scopeName), funcName)
        onFillFromFuncCall(o node, r runExpr)
            r.args.setMe(o)
    ```
    * 대충 돌아는 갈것 같다. 그런데 prop에 대해서는 동작하도록 parser 문법을 조금 수정할 필요는 있겠다. ==> **PROP의 구현방법에 대해 먼저 별도 항목으로 논의하자.** -->  #프로퍼티_구현_알고리즘  논의했다.
        * PROP의 구현 알고리즘은 기본적으로 일반 prop이든 함수가 있는 prop이든 차이가 없도록 하는것이 핵심이다.
        * 그러니 일반 함수 혹은 함수없는 prop이라고 생각하면 된다.
* [x] 근데 매번 이렇게 A::B 인지 A.B인지 구분해서 사용하라는 건 조금 실수하기 딱 좋고 헷갈리지 않을까? ==> **아니요. 이런 경우는 별로 없다. 오히려 super() 이건 넣어야 줘야 한다.**
    1. [?] 반대로 동작한다면?
        * A.B로 하면 알아서 me를 교체하지 않는 기능.
        ```go
        def A
            foo() void: boo()
            boo() void: ...
        def B
            with a A
            boo() void: ...
            koo() void
                boo()
        main() void
            a A := B()
            a.foo()
        ```
    * A에서 확장한 foo()함수를 B 안에서 호출하고 싶다고 하자. A에서 확장했으니 A::foo() 해야 할것 같은가? 아니. 그냥 foo() 하면 되는 거다. 혹은 me.foo() 하면 되는 거다.
    * A::B는, A에도 foo()가 있고 B에도 foo()가 있는데, B가 아닌 A의 foo()를 호출하고 싶은 경우에 사용하게 된다. 즉, super에 대한 호출. super.foo() 가 a::foo()가 되는 것이다.
    * 오히려 super() 이거를 넣어야 될 것 같다.
* * *
# [o] defBlock 안에서의 with 의 expand 알고리즘
* why?
    1. pack <-- file <-- withScope <-- objScope 의 형태로 chain이 만들어 져야 한다.
    2. 만약 1에서 만든 객체가 다시 또 어떤 객체의 with expand가 된다면, withScope <-- objScope 부분만 떼어서 들어갈 수 있어야 한다.
    3. 런타임에 이미 할당된 with prop이 다른 객체에 대한 참조로 변경될 수 있어야한다. 이때 만들어진 위의 chain도 같이 변경되어야 한다.
    * 어떻게 할까?
1. [u] orgObj는 pack을 가지고 있는다. 그리고 frameInteract(obj) 할때, stackFrame.setPack(this->getOrigin()->getPack()) 해서 stackFrame에 껴둔다.
* * *
# [o] 사용자는 다른사람이 만든 객체를 완전객체처럼 써야하는지 말아야 하는지 분간이 안될때가 있다. ==> **앞글자가 대문자면 incomplete**
* 코틀린을 보면 `object`가 있으면 완전객체로 쓰라는 뜻이다. 없으면 쓰지 말라는 거고.
* 반면 내 언어를 보면 def 뒤에 소괄호가 있으면 완전객체라는 뜻이 된다.
* 그러나 소괄호가 없는 경우, 완전객체 일 수도 있고, 아닐 수도 있다. 생성자를 보면 알 수 있다.
* 그러나 진짜 문제는 마침 기본생성자만 있었다고 해도, 그래서 완전객체가 되었다고 해도, 그것이 이 객체를 만든 개발자가 진정으로 `완전객체로 사용하세요` 라는 뜻으로 만든 것인지, 아니면 `아, 그건 신경못썼네...` 인 건지
   분간이 안된다는 것이다.
* 이건 꽤 딜레마적인 상황인데,
    * 명확하게 `완전객체입니다. 그렇게 쓰세요, 저는 그걸 원합니다` 가 되려면 개발자가 `object` 키워드나 소괄호 같이 무언가를 입력하게 해야 한다.
    * 그런데 그렇게 하면 추가적인 로드가 걸리는 것이므로 이미 class에 익숙해진 개발자들은 그렇게 하려하지 않을 것이다.
1. [?] style을 속성으로 사용하자는 idea를 확장한다 ==> 소문자로 시작하면 완전객체, 대문자면 불완전객체?
    * 물론, 뒤에 소괄호가 있냐 없냐로 구분이 가능하긴 하다.
    * 하지만 사용자는 불가능하지. 이미 고찰했다.
    * 이 방법은 사용자에게 좀 더 명확한 구분을 주자는 것이다.
    * 괜찮지 않나?
* * *
# [o] verifier는 생성자를 호출하는 코드를 보면, 그 org객체가 abstract인지 아닌지 여부도 체크해줘야 한다.
* incomplete여부와 abstract여부는 다르다.
* abstract하면 incomplete이지만 반대는 아니다.
* node::isComplete()가 있다. orgObj::isAbstract()를 두자. 이 abstract 한지 아닌지는 parser가 채워두면 될 것이다.
* verifier가 생성자를 호출하는 코드인지 아닌지를 판단하려면,
    * verifier::onVisit(runExpr& r) 에서는
        * r.subject.setMe(r.getMe.eval())
        * r.subject.eval()
    * 을 통해서 org node를 뽑아온다.이 orgNode는 func일수도, orgObj일 수도 있다.
    * orgObj라는 얘기는 이 객체에 대해 생성자를 호출한다는 뜻이므로 if(orgObj.isAbstract())로 간단하게 알아낼 수 있다.
* if(orgObj.isAbstract()) 로 에러가 판명되었다면, 이제 orgObj.sub(조건) 을 이용해서 abstract한 함수목록을 다 뽑아오면 된다.
* * *
# [o] static 을 없애는 방법? ==> **def를 통해 다소 제한적이지만 충분히 가능하다.**
### 함수내 변수의 경우
* [x] def 를 사용한다면? => **def는 싱글톤이기 때문에, 괜찮아보이는데?**
```go
foo() void
    def val 5 // 초기값이 5인 셈
    print("val=${++val}")
```
### staitc 메소드의 경우는? ==> **def 와 with를 사용한다.**
* [d] 1안: 그냥 origin 완전 객체를 이용하도록 하면 되는 거 아닌가?
    * 안된다.
    * 왜냐하면 어떠한 static은 제공하지만 불완전객체로 하고 싶은 경우가 생기기 때문이다.
* * *
#  [o] 람다식 문법은 함수 안에서만 정의할 수 있다. 밖에서라면 중첩함수를 써라. ==> **람다는 그냥 익명함수다.**
> 결론:
> 람다식은 반드시 함수 호출 안에서만 쓸수 있다.
> 이름이 다를뿐 함수의 반환형과 인자리스트가 동일하다면 같은 함수타입으로 봐야 한다.

* 여기서 말하는 클로저란, **인자가 박혀있지만 실행을 그 함수 밖에서 실행시킬 수 있도록 하는 무언가** 이다.
* 즉 *함수의 실행*과 *함수에 인자를 바인딩* 하는 것을 구분하자는 것이다.
* 내 언어에서는 클로져를 어떻게 만드는가 --> 함수타입이라는 건 없고, 함수정의 자체를 타입으로 쓸 수 있다.
```go
clickListener(v View) ViewResult
setOnClickListener(l clickListener) void -> listener = l

setOnClickListener((l clickListener) -> print("click!"))
setOnClickListener((l) -> print("click!"))
```
* 코틀린
```kotlin
setOnClickListener() { print("click!") }
```
* 파이썬
```python
setOnClickListener(lambda l: print("click!"))
```

* [x] 빈 함수 정의가 있다고 하자. 파생클래스를 위한 abstract인지, 함수타입으로 쓰기 위한 것인지 어떻게 한번에 구분 가능한가? 더 큰 문제는 함수타입처럼 쓸려고 정의한 것 뿐인데 구현을 안해서 완전기원객체를 만들 수 없는 상황에 놓여지게 될 수 있다는 것이다.
	* [ ] 될것 같긴 한데, 그래도 파싱이 되는지 확인이 필요하다.
```go
def person
	foo(x int) int // 함수의 본문이 없으므로 반드시 반환형을 써야 한다.
				   // 본문이 없다는 건, abstract func이라는것이다.
				   // 괄호가 있다는 점에서 변수 정의 문법과 구분이 되며, 반환형이 있다는 점에서 함수호출과 구분이 된다.
	boo(x int) int = null // 역시 본문이 없으므로 반환형을 써야한다.
						  // 뒤에 null이 있다는 건 호출하면 무조건 죽는다는 뜻이다. ==> 함수타입
def student
	koo(b boo) -> print("koo") // 본문이 있기 때문에 반환형이 없어도 된 것이다. 일반 함수다.
s student // 에러. foo 함수를 채우지 않았으므로 student 객체를 만들 수 없다.
```
* 코틀린과 비교
```kotlin
class person {
	abstract fun foo(x: Int) Int
}
class student : person {
	fun koo(b: (Int) -> Int) = print("koo")
}
```
* [d] 나중에 넘기기 위에 람다를 일단 만들 수 있는가? ==> **그렇다면 이 람다의 타입은 무엇인가? 함수타입이 결국 존재해야 하는 것 아닌가?**
	* 이 경우, 만들어진 람다는 무언가의 변수에 들어가게 될 것이다. 나중에 쓰기 위해 보관을 하고 있어야 하니까. 즉 이름을 부여하게 된다.
    ```kotlin
    val multi = {x: Int, y: Int -> x * y}
    fun foo(fun1: (Int, Int) -> Int, x: Int, y: Int) = fun1(x, y)
    foo(multi, 1, 2)
    ```
* 즉 위의 multi는, 그냥 함수 만든것과 같은 거 아니냐는 말이다.
```go
multi(x int, y int) -> x * y
foo1(fun1 multi, x int, y int) -> fun1(x, y) // 반환형은 infer 된다.
foo(multi, 1, 2)
```
* 그러므로, 저렇게 할바에야 그냥 함수를 정의하면 되는 것이다ㅎㅎ
* * * 
# [x] 인자의 일부가 박힌 함수를 만들 수 있다. ==> **신기하긴 하지만, 유용하지 않다.**
> 결론:
> 개념적으로는 신박했지만, 결과는 신박하지 않다.
> 함수 정의시 반환형은 생략할 수 있게 하자.

```haskell
area x y = x * y -- 가 있을때,
area2 y = area 2 -- 인자 2가 박혀진 중간함수 area2를 만드는 셈이다.
putStrLn(area2 5)
```

* 같은 걸 내 언어에서 하려면?
```go
area(x int, y int) int
	x * y
area2(y int) int
	area(2, y)
print(area2(5))
```

* 내 언어가 더 길다. 왜그럴까?
	* 일단 한줄에 표현하지 않아서 그렇다. 그러면 한줄에 적어보자.
```go
area(x int, y int) int -> x * y
area2(y int) int -> area(2, y)
print(area2(5))
```
* 다음으로 타입을 생략하지 않아서 그렇다. 타입을 생략한다고 해보자. 
```go
area(x, y) -> x * y
area2(y) -> area(2, y)
print(area2(5))
```
* 인자목록의 타입을 생략하는 건 좋지 않은 것 같다.
```go
area(x int, y int) -> x * y
area2(y int) -> area(2, y)
print(area2(5))
```
* * * 
# [x] on 을 사용한 try-catch와 if-else 예외처리 통합 ==> **실패. if-else는 여기 오면 안된다.**

> 결론
> 1. on은 예외처리로만 사용하며, 1줄에 대한 처리만 지원한다.
> 2. $ 중간값 평가를 지원한다. $중간값 평가가 사용가능해지는 것은 해당 라인이 모두 끝난 뒤다.
> 3. try-catch 예외처리를 제외한 예외처리(파라메터 필터링, 한줄 스킵, 나머지 라인 스킵, 다른 action으로 브랜칭) 은 모두 if-else를 사용한다.

### 고찰
* 언어들은 예외처리를 2 종류로 처리한다.
	1. try catch
	2. 반환값을 보고 null 혹은 -1, 혹은 false 혹은 예상치 못한 값일때 if else로 처리
* [x] 에러에 대한 1개에 처리로 이들을 통일 할 수 있는가? --> 고찰을 통해 알아낸 바, try catch로는 통일이 불가능하다.
	* [x] 그럼 if else로 예외처리가 가능한가? --> 모두 if-else로 가능하다. 그러나 그걸 조금이라도 걸러내야 독해가 보기 좋다.
		* 이때 중요한 건, if가 branch인지 예외처리인지를 구분할 수 있어야 한다는 것과
		* 간략해야 한다는 것.
* 에러처리는 2 곳에서 이루어진다.
	1. 함수의 머리: 일종의 contract 개념. 함수를 잘 호출했는가?
	2. 함수 호출 후 반환값 검사: 함수가 잘 호출 되었는가?
	3. 함수 호출 도중 긴급 사출: 2번과 합칠 수는 있다.
* [x ] try-catch를 제외한 예외처리 코드를 단축할 수 있는가? --> 네, 그러나 의미가 크게 없음. 중간값 평가와 `on`을 지원해야 하는데 이게 사용자 입장에서 매우 직관적이지 않은 문법이다. 그리고 생각보다 이게 필요한 경우도 없다.
```java
public Intent foo(Activitya) {
	if (a == null) return null;
	if (a.isHide()) return DEFAULT_INTENT;

	Result res = a.startResult();
	if (res.isError()) return null
	boolean isOk = new Manager().translate(res)
	if (!isOk) return null;
	return a.getIntent();
}
```
* 위의 코드를 좀 줄여보자.
```java
public Intent foo(Activitya) {
	if (a == null) return null;
	if (a.isHide()) return DEFAULT_INTENT;

	Result res = a.startResult();
	 (res.isError()) return null;
	boolean isOk = new Manager().translate(res))
	if (!isOk) return null;
	return a.getIntent();
```
* 내 언어로 바꾸면:
```go
foo(a activity) intent?
	if !a ret null
	if a.isHide() -> ret DEFAULT_INTENT

	res := a.startResult(s)
		if res.isErr() -> ret null
	manager.translate(res)
		if !isOk -> ret null
```
* [x] if (....) return ....를 축약시키는 문법을 제공하면, 개선이 되는가? --> 별로. 차이 없음.
```go
foo(a activity) intent?
	if a.isHide() -> ret DEFAULT_INTENT

	res := a.startResult() // 주석은 되지만 빈칸을 만들 수 없다.
	if res.isError() -> ret null
	/* 이런주석도 되야 한다.*/isOk := manager.translate(res)
	ret a.getIntent(isOk)
		on err, nullErr -> ret null // err, nullErr이 오면 log를 찍고 null을 한다.
```
* 가장 큰 문제는 함수 밖에서 에러로 판단하는 `if res.isError()` 같은 부분이 현재의 throw와 맞지 않는다는 것이다. 
* 일단 가장 이상적인 코드를 한번 짜볼까?
```go
foo(a activity) intent
	a.isHide() -> DEFAULT_INTENT
	ret a.getIntent(manager.translate( startResult()))
	// ...무언가의 예외처리 코드가 여기에 들어가게 된다...
```
* 함수 안에서 판단가능한 에러는 a.startResult() 함수가 끝났을때 그 결과로 예외를 반환하는 케이스가 될 것이다.
* 그러나 `getIntent(bool)` 을 보자. 여기에 들어가는 bool값은 원론적으로는 true도 맞는 거고, false도 맞다.
* 그러나 `foo` 함수에서는 true가 들어가야만 맞는 케이스라고 가정하자. 그러면 어떻게 되는가?
* manager.translate()가 false로 반환한다고 해서 이것은 에러가 아니다.
* getIntent()에 false가 들어가려는 순간만이, 이 함수안에서, 이 라인에서 false로 넣으려는 순간만이 에러로 간주되는 것이다.
* 저 코드 뒤에 같은 함수안에서 getIntent(false)가 되어도 에러가 아닌 것으로 간주해야 하는 시나리오가 충분히 있을 수 있다. 
* **즉 함수밖에서 판단되는 에러는 즉발적이며, 충동적이며, 범용적이지 않고 특수적으로 동작할 가능성이 존재한다.**
* 그리고 그 가능성이 1%라도 존재하는 이상, 나는 그걸 **일반화 할 수 없다.**
* 그렇다면 1줄로 적는 것과, 여러줄로 적는 것에는 어떠한 사용성 차이가 생기는가?
```go
ret a.getIntent(manager.translate(a.startResult())
	if `a.startResult()` 가 잘못된 값이라면 ...
	if `translate()`에 들어간 값이 예상과 달랐다면 ...
	if `getIntent()`에 들어간 값이 false라면 에러로 간주.
	
// 이 것과,

res := a.startResult()
if res 가 잘못된 값이라면 -> ....
isOk := manager.translate(res)
if isOk가 잘못된 값이라면 -> ....
val := a.getIntent(isOk)
if val이 잘못된 값이면 -> ...
ret true
```
* 최종적으로 하고 싶은 것은 a.getIntent()를 하려는 것이다.
* 그러나 거기까지가기 위해서 a의 객체가 의도와 다른 상태를 가지고 있거나,
* 인자에 잘못된 값이 들어갔는지를 체크하기 위해서 이런 것을 하는 것이다.
* 그리고 값을 체크하는 동작과, 값을 넣는 동작은 2가지의 구분 되는 동작이므로 이를 변수명을 두는 것이고.
* 어떻게 하면 더 간단하게 만들 수 있을까?
* [x ] 인자를 체크하기 위해 변수를 만들지 않도록 해본다! 이러면 간편해지나? --> 이게 유용한 순간이 몇 없다. 그런데 구현은 어렵다. 그리고 상황에 따라서 사용자가 염두에 둬야할(기억해야할) 예외상황이 많다. 즉 우아하지 않다는 것. 그러니 하자말자.
```go
ret a.getIntent(manager.translate(a.startResult(a, b), c, d), e)
//                ^1              ^2            ^3 ^4  ^5 ^6  ^7 --> 이게 아니라
//			 	  ^1              ^2       --> 이렇게 함수만.
//			      ^-2             ^-1      --> 역방향도 지원. 일관성을 위해 배열의 원소접근시 역방향을 지원한다.
    if $2 잘못된 값 -> ...
    if $1 잘못된 값 -> ...
    if $0 잘못된 값 -> ...
    if $5 잘못된 값 -> ...
```
* 인자의 순서에 따라서 숫자를 매긴다.
* 함수호출이 아닌 일반 인자에 대한 숫자 혹은 바인딩은 에러로 간주한다.
* 이렇게 하면 숫자로 되어있기때문에 $5라고 하면 어느위치인지 텍스트만 가지고는 알기 힘들다.
* IDE가 지원을 할 순 있겠지만 그래도 커서를 올려본다거나 동작이 필요하겠지.
* [x ] 이 방법말고, 값을 지정하는 다른 방법은? --> 변수명 혹은 함수명을 가리키게 해준다. --> 변수명은 의미가 없었다. 지원하지 않아도 된다.
	* 왜냐하면 이걸 하는 이유는 쓸데없는 중간값을 저장하는 걸 피하기위해서다.
	* 그런데 변수는 이미 만들어졌잖아? 그럼 함수 호출 전에 그걸 쓰면 된다.
```go
ret a.getIntent(manager.translate(a.startResult(a, b), c, c), startResult)
    if $translate.isOk -> ... // manager.translate(인자목록) 을 다 적을 필요는 없다, 객체처럼 사용도 가능하다.
    if $a.isHide -> ret null // 에러: 변수는 안된다. 그리고 혹 지원해준다고 해도 a를 쓰면 된다.
    if a.isHide -> ret // 에러: a는 함수호출 도중에 평가되는 값이 아니다. 평가 완료 시점이란게 없는 것이다.
                       // 그리고 사전에 처리하면 된다.
    if $c // 에러: c가 너무 많아.
    if $startResult // 에러: 함수야? 변수야?
    if $0.isValid() // $0은 반환값을 의미한다.
    if $1.priority > 2 // 이 경우 manager.translate()의 반환값을 가리키게 된다.
    if !$-1.isOk() // -1은 뒤에서 첫번째. 즉 startResult변수를 의미한다.
    if $-2 < $a // 2개 이상이 동시에 사용될 수도 있어야 한다.
```

* 이번에는 초기 예제를 이 기능에 맞게 다시 짜보자.
* on이 없을 경우:
```go
foo(a activity) intent?
	if a.isHide() -> ret DEFAULT_INTENT
	res := a.startResult()
	if res.isError() -> ret null
	translate := manager.translate(res)
	if !translate -> ret null
	ret a.getIntent(translate)
```
* on이 있을 경우:
```go
foo(a activity) intent?
	if a.isHide() -> ret DEFAULT_INTENT
	ret a.getIntent(manager.translate(a.startResult())
	    on $startResult.isError() -> ret null
	    on !$translate -> ret null
```
* [x ] 그럴싸해보이지만, 저 `on`이if가 동작되는 순간이 언제인가? 라는 의문이 남는다. --> 알고리즘을 생각을 해봐야 한다. 프로퍼티도 지원을 해줘야 하기 때문에 꽤 복잡한 구현이 된다.
    * 물론, 어떻게든 잘 짜서 verifier가 아, 이순간이구나! 알게끔 할수는 있을 것이다.
    * 그리고 데이터가 들어오는 순간 처리가 되어야지, 무식하게 원래의 구문을 다 실행하고 나서 수행하면 안된다.
    * 그러므로 `if` 가 아니라 새로운 키워드 `on`을 사용하자.
    * on의 의미는 조건절에 사용한 모든 키워드의 값이 결정되는 순간 딱 1회 테스트를 실행한다는 것이다.
* [x ] 포텐셜은 느끼는데, 이 기능만을 위해서 추가하지 말고 좀 더 다른 범용적인 용도를 생각해보자. --> 힘들다. 중간값을 저장하기 위한 용도로만 쓸 수 있다.
    * `on`의 의미는 값이 결정된 순간 1회 다음 구문을 수행한다라는 뜻이다.
    * [x ] `on`을 catch의 형태로도 사용할 수 있지 않나? --> 네 가능.
		* 가장 큰 문제는 catch는 블록문에 대해 사용하는 건데 on은 하나의 구문에서만 쓸 수 있다는 점이다.
		* 그러면 try-catch 블록이라는 건 없다고하고, 무조건 한 줄에 대한 예외처리를 해야 한다고 한다면?
* [x] `on` 을 블록문에서도 적용할 수 있는가? 이게 안된다면 on과 catch는 합칠 수 없다. --> 2 개 이상의 구문에서는 안된다. 
* [x ] `on`에 상수가 사용된 경우, 프로퍼티를 넣은 경우는 어떤가? --> 지원할 필요가 없다. 함수호출전에 체크하면 되니까.
* [x ] 반복문에 on을 쓰는 경우는 어떻지? --> 괜찮음. 아니 무조건 지원을 해줘야 함. 그래야 사용자가 케이스바이케이스로 암기를 안해도 되니까.
```go
for person in students
	person.init(a.getArguments(false))
		on !$getArguments -> next
	print("hello! ${person.bow(manager.generateDefaultMsg(a.getResult()))}")
		on $generateDefaultMsg.isValid() == false
			print("failed!")
			next
```
* 안되는 건 아니다. 하지만 on이 중간에 나오게 되면 맨 밑에 썼을때와는 달리 가독성이 좀 떨어지게 된다.
* 위의 코드를 on 없이 작성해보면?
```go
for person in students
	args := a.getArguments(false)
	if !args -> next
	
	person.init(args)
	msg := manager.generateDefaultMsg(a.getResult())
	if msg.isValid() == false
		print("failed!")
		next

	print("hello! ${person.bow(manager.generateDefaultMsg(a.getResult()))}")
```
* [x] `skip`을 만들어줘야 하나? --> 안된다. 모순이 생겨버린다. 다른 형태로 skip을 구현해야 한다.
	* [x] 중간값이 에러가 발생하면 해당 라인을 취소하는 동작이 실 시나리오에 존재하는가? --> 있다.
```kotlin
val type = p.getType(JOB)
if (type != null) {
	val res = activity.getResult(type)
	SharedPreference.putStr("KEY", res)
}
```
* 위의 코드에 `on`을 적용하면?
```go
res := activity.getResult(p.getType(JOB))
	on !$getType -> skip
// 만약, skip을 지원한다고 하자. 그러면 여기에 도달했을떄 res는 존재하는게 되버린다. 모순이다.
```
```go
with // 블록문을 위한 것이다.
	res := activity.getResult(p.getType(JOB))
		on !$getType -> ret // 이 블록문만 끝난다. 여기서 중요한 점은 on은 블록문이 아니어야 한다는 것이다. 어떻게?
	sharedPreference.putStr("KEY", res)
```
* [x] 짧아진건가? --> 차라리 밑에처럼 하는게 낫다. 즉, on을 안쓰니 결과가 더 좋은 것이다. 사용자는 on을 써야 하는가? 안써야 더 간결한가? 를 계속 판단해야 하는 상황에 놓인다.
```go
if !(p.getType(JOB))
	res := activity.getResult($getType) // 이게 더 좋은거 같은데. ret도 필요없고.
	sharedPreference.putStr("KEY", res)
```
* [x] 근데 ret를 왜 return으로 만들어버린거지?  --> ret가 필요없었기 때문이다! ret를 쓰는 상황을 생각해보자. 코드 중간에 ret가 있을까? 그 뒤에 코드는 실행이 안될거기 때문에 그렇게는안된다. 필연적으로 맨 밑에 오는 상황일 거고, 그럴바에야 ret 안쓰면 되므로 의미가 없다. 중간에 ret가 올려면 if -else를 쓰는 수 밖에 없는데, 이 또한 블록문이지 않은가. 그러니 ret가 의미를 가지는 경우는 존재하지 않는다.

* 그런데 for loop의 container 부분 expr에서도 쓰여야 하는 상황도 있다. 
```go
for person in getPeople(a.getType())
	on !$getType != STUDENT -> skip // on에는 중간값 평가가 들어가거나 에러타입이 명시되어야 한다.
	print("${person.name}")
// 위처럼 할바에야, 이게 낫다는 얘기다.
if (type := a.getType()) != STUDENT
	for person in getPeople($getType) // 중간값 평가를 쓴 것이다.type)
		print("${person.name}")
```
* 이 경우 더 헷갈리기 쉽다. 그렇다고 "이런 경우는 쓸 수 없다!" 라고 막으면 일관성이 떨어진다. 이런 case by case로 외우고 다녀야 하니까.
* 즉, on을 쓸 수는 있게 해줘야 한다.

* `$-1` 은 `$ - 1`  처럼 해석될 수 있다. 그러므로 이러한 상황에서의 예외처리가 또 필요하다.
* `on` 을 필요로 하는 케이스가 생각보다 많지 않았다. 내 경험에만 의존해서 *많이 필요하지!* 했는데, 실제로는 아니었다.
* 그리고 중간에 변수를 만드는 편이 더 직관적으로 알 수 있다. 누군가는 이 방식을 더 선호한다는 것이다.
* 그리고 함수에 특정 인자에 재사용되서 다른 함수호출에도 계속 들어가는 경우도 있다. 이때도 중간에 변수를 만들어야 좋다.
* `on`은 객체를 가져와서 그 객체의 조건처리를 한 후, 다시 함수에 넣어야 하는데, 한번 가져온 이 객체가 2번이상 인자로 들어가지는 않을때 쓸모가 있다. --> 즉 조건이 까다롭다. 이런 경우는 거의 없다.
* [x] `on`을 조건처리 외에도 사용할 수 있지 않나? --> catch로는 가능할 듯 하다.
* try라는 게 존재하지 않는다. 한 줄에 대한 예외처리는 그때 바로 밑에서 `on`을 통해서 처리해야 한딱히 없었다.
* try 안에 try를 쓴 경우에 대한 예외처리도 필요하다.
* [x] on 과 catch를 같이 쓰는 경우는 어떻게 되는가? --> on 과 catch가 같은 level에 있는 경우, on에다가 catch가 달린 경우등 생각할 거리가 많다는 걸 알 수 있다.
* 그러나 catch를 try 없이 처리한다는 건 꽤 괜찮은 아이디어라는 걸 알 수 있었다.

### 잠깐의 폭풍같은 생각을 거친 후, 다음과 같이 머리속이 정리되었다.
* return은 함수를 반환하는 것이다.
* ret는 with를 벗어난다.
* break는 반복문을 벗어난다.
* $ 는 `중간값 평가` 라는 기능으로, 블록문에 진입했을때, 블록문에 진입하게 만든 바로 윗줄에 있는 함수호출의 중간결과값을 참조하는 기능이다.
* 중간값 평가는 만약 같은 함수를 한 줄에 2번 호출했다면 사용이 불가능하다
* `on`은 1줄에 대한 기능으로, error가 나왔거나 중간값 평가 조건이 만족되면 수행하는 예외처리용 조건절이다.
* [x] 문제점,
	* [x] ret-with, for-break, return.... 비슷한 기능인데 문법이 3개나 된다. 줄일 방법이 있나?
		* 줄인다고 한다면 1개나 많아봐야 2개를 사용해야 적당할 것이다.
		* ret는 함수호출을 담당하므로 뺄 수 없다. 그러면 남은 것은 break다.
		* 앞서 고찰을 통해서 단순히 if 문에 대한 블록문 ret는 필요가 없다는 걸 알 고 있을 것이다.
		* 즉 if 말고 다른 종류의 블록문에서 빠져나와야 의미가 있는 것이며 그중에는 반복문 뿐만 아니라 *다른 종류의 블록문도 break로 빠져 나올 수 있어요* 가 되어야 의미가 있다는 걸 알 수 있다.
		* [x] 즉 return은 함수에서빠져나오는 것. ret는 if문을 제외한 블록문을 빠져나오는 용도로 사용하는 것이라고 하면 어떨까? --> 된다.
* 코드 블록이라는 개념을 도입한다. 빈 라인이 없이 채워져 있는 코드는 하나의 코드 블록이다.
* 코드 블록 묶음에는 원하는 만큼의 catch 문을 달 수 있다.
	```go
	foo(a int, b int) int
		ret 3 // ret는 함수에서도 사용 가능하다.
	foo(a int, b int) int
		b := if a > 5
			ret 3 // ret는 if 를 제외한 블록문을 빠져나온다.
				  // 즉 ret는 if가 아니라 if 밖에 있는 함수를 빠져나오는데 사용된다.
		print("b=$b")
		// a > 5일 경우에는 여기까지 오지도 못한다. b도 만들어지지 않는다.
	foo(a int, b int) int
		with res := a + b
			c := it + for n in 0..it // it은 res다.
				if n > 2
					ret n // for문을 빠져나오는데 사용된다.
			print("c=$c") // n = 3이 ret 되고 it은 res = a + b 이므로 c = 3 + a + b
	```
	* [x] ret와 on을 같이 쓰면? 잘 동작하는가? --> 안 알아봄. 후술할 단점때문에 의미가 없어져서.
		* [x] `on`이 발생하면 해당 라인의 나머지 부분은 어떻게 되는가? --> X
* on의 사용처를 요약하면,
	* 반환값만 바꿔서 계속 처리를 하게 하고 싶다
	* 뒤에 나오는 모든 처리를 그만두게 하고 싶다
```go
view := mgr.kotlin
var appInfo: ApplicationInfo? = null
try {
    appInfo = context.getPackageManager().getApplicationInfo(INFO, META)
    findViewById<ImagetView(FLOAT)
	if !view return
	attr := view.getAttr()
	if attr.height == 22
		someOtherRoutine() // 사실상 2번에 해당하는 것이다.
		return 1
	anim = attr.getHeightAnim()
	if anim.isReady
		anim.start()
		return 0
	else
		print("error: animation isn't ready.")
		return 1
// 위를 바꿔보면:
		mgr.getView(FLOAT)?.getAttr()?.getHeightAnim()?
			on $getAttr.height == 22 -> someOtherRoutine(); return 1
			on $getHeightAnim -> anim = it
		if anim.isReady
			anim.start()
			return 0
		print("error: animation isn't ready.")
		return 1
```
```go
if pos < 0 || id < 0 || id > 2000000 -> return
setItemSelectedState(pos, id, selected)
if updateView -> notifyItemChanged(pos, payload)
// 바꿔보면
setItemSelectedState(pos, id, selected)
	on $pos < 0 || $id < 0 || $id > 2000000 -> return
if updateView -> notifyItemChanged(pos, payload)
// 별로 짧아졌다는 느낌이 안든다. 오히려 전에것이 더 좋아보인다.
```
* *해당 라인만 취소 하고 싶다*
* *다른 처리를 하게 하고 싶다* --> 이건 로직에 대한 분기다. if-else를 쓰라.
* 4가지고 구분된다. 나는 이중에서 포기할 것을 선택하든가 모든 경우에 수를 조사해서 다 지원하든가를 선택해야 한다.
* 여기서 집중해야하는 on의 의미는 우리는 **에러인 if와 로직적인 if를 분리**하고 싶어서 이런 걸 하고 있다는 것이다.
* 그러니 로직적으로 다른 처리를 계속하고 싶어하는 케이스에 대해서는 if-else를 써야 한다.

```go
	foo(a int, b int) int
		...
	main() int
		foo(boo(5), max(3 + 5, a + b * 2))
			on $boo > 5 -> return 3
			catch(e nullErr) -> e.log() // 에러가 발생하면 
```
* 중간값 평가까지는 유용하다. 문법도 비교적 심플하다.
* [x] 그러나 중간값 평가와 `on`을 함께쓰면 그렇지 않다. 이유는,
	* 이렇게 하는 이유는 모든 예외처리는 on을 통해서 하고 로직은 if-else를 분기하려고 했던것이나, 앞서 4가지 케이스별 사례를 분석해본 결과, on만 써서 모든 걸 커버하려면 한 줄만 취소하거나, 다른 함수를 하나만 호출하고 종료하거나 등이 필요하게 된다.
	* 이 판단은 오로지 user가 생각해서, 아 if-else 쓰지말고 on으로 해야하는 거군. 아, 이건 on으로 하면 까다로우니 if-else로 해야하는 거군 하면서 복잡하게 짜야 한다.
	* 그리고 독해할때도 "미리 예외쳐내고, 본론 보기" 와 "본론 보고, 예외는 나중에 정리하기"가 모두 가능한 상황 혹은 2가지 중 상황에 맞게 사용자가 판단해서 짜야하는 상황이 계속 찾아오기 때문에 혼란스럽다. 우아하지 않은 것이다.
* [x] try-catch 대신 on 을 쓰겠다는 것인데, 잘 되나? --> 이건 괜찮다.
* [x] on 뒤에 중간값 평가가 오는 경우, 에러가 오는 경우 2종류에 대해서 모두 on을 쓰라고 해도 될까? 아니면 에러는 catch로 잡아야하나? --> on뒤에는 무조건 예외만 온다.
```go
foo(a int, b int) int
	...
main() int
	foo(boo(5), max(3 + 5, a + b * 2))
		
```

# [o] on이 try-catch를 대신 해도 된다.

* [x] 코드 블록이라는 개념을 도입한다. 빈 라인이 없이 채워져 있는 코드는 하나의 코드 블록이다. --> 확인결과 이건 도입하면 안된다. 
	* 즉 try라는 건 어느 시점에서든 중단 될 수 있다는 것이다. 따라서 try 안에서 정의한 변수는 try 밖에서는 의미가 없어야 한다.
	* 그런데 코드블록이라는 건 변수가 블록 외부에도 영향을 미친다는 걸 시사하기 때문이다.

* 하지만 try를 없애고 go 처럼 예외처리를 한다는 건 맞다.
	* monad를 도입해서 좀 더 사용하기 쉬운 형태의 예외처리를 만들려고 한다.
	* try catch가 나는 싫은데,
		* try catch가 없어도 반환값 체크로 대체가 가능하긴 하다. C++을 보면 말이지.
		* throw를 하는지 안하는지를 바로 알 수 없다. 함수호출시 signature를 봐야하지.
		* 사실상 goto 같은 것이다.
		* try, catch, finally 등등 쓰다보면 블록문이 너무 많으니까 직관성이 떨어진다. 로직이 에러에 파묻히는 꼴

* [ ] go와 같은 컨셉으로 좀 더 다듬어 보자
```kotlin
try {
	getVew(someId).visibility = true
} catch (e: NameNotFoundException) {
    return false;
}
return appInfo?.metaData?.getFloat("Provider", 0f) > 0f
```
* 위 코드가 이렇게 바뀐다.
```go
findViewById<ImageView>(someId).visibility = true
	// on은 블록문이 아니라는 점에 주목하자.
	on nameNotFoundErr -> ret false on UnexpectErr // ret 'on' 을 통해서 예외를 넘길 수 있다.
ret appInfo?.metaData?.getFloat("Provider", 0.0) > 0.0
```
* [ ] 만약 appInfo를 채우는 도중에 catch로 빠지면 appInfo는 무슨 값이지?
	* 즉 try라는 건 어느 시점에서든 중단 될 수 있다는 것이다. 따라서 try 안에서 정의한 변수는 try 밖에서는 의미가 없어야 한다.
```go
abc := network.connect("http://....")
	on networkErr
		// 만약 여기에 왔다고 하자.
		doSomething()
	
		// 그때의 abc의 값은 뭐가 되는가?
		// 	go는 어떻게 하나?:
		//		go는 connect() 함수 안에서 null, networkErr 처럼 반환하도록 문법이 정해져 있다.
		//		즉 abc의 값은 null 된다.
```
* [ ] 이 다음에 실행될 코드는 뭘까? ret? 아니면 abc := ... 의 다음 구문?
	* [ ] 둘다.. 가 아닐까?
		* 아예 블록을 통째로 날려야 되는 부분도 있을 것이고,
		* 한줄만 날리고 싶은 경우도 있을 것이다.
		* 굳이 합쳐보라면 무조건 ret 가 된다. 한줄만 날리고 싶다면 *블록을 씌우세요* 가 되면 되니까. 그러면 다음과 같은 코드가 된다.
```go
abc socket?
with
	abc = network.connect("http://....")
		on networkErr
			....do something
			// ret
p pipe?
with
	p = socket?.openPipe()
		on....
			....
```
* 싫다. 그냥 자바 try catch와 다를게없는거 아닌가?
```kotlin
abc: Socket? = null;
try {
	abc = network.connect("http://.....")
} catch (err: NetworkException) {
	.... do something ...
} 
p: Pipe? = null;
try {
	p = abc?.openPipe()
} catch {....) {
	....
}
```

* [ ] 만약 go 처럼 처리한다면?
	* error을 반환하는 함수는 필연적으로 nullable type이 되어야만 한다. 상당수가 nullable type이 될것이다.
	* [ ] 개선점은?
* [ ] 만약 lua처럼 처리한다면?
	* lua는 에러일 경우에는 에러타입이 반환된다. 즉 모든 에러를 반환하는 함수는 에러타입과 함수의 반환타입 2개가 중첩된 상태인 것이다.
	* [x] 다만 에러타입이 반환된 경우에, 함수반환타입처럼 사용을 하는 코드를 작성하면 어떻게 되는가? --> 익셉션이 발생한다. 컴파일에러를 잡지 못한다. 
		* 그리고 루아는 약형 스크립트 언어다.
		* 완전히 루아처럼은 안된다는 뜻이다.
	* [ ] 타입중첩은 기발한 아이디어 이긴 하다. lua의 방법을 응용해서 어떻게 방법이 없을까?
* [ ] lua와 go를 합친다면?
	* 타입은 중첩된다. 즉 nullable 타입은 설사 null이 들어가 있다 할지라도
		* 기본적인 메소드는 호출이 가능하다.
			* isError()
			* errorMsg()
			* 등
		* null이 있을때 해당 타입에서 정의한 메소드를 호출하면 당연 exception이다.
		* void를 반환하는 함수가 아닌 경우, 함수 내에서 에러 객체를 반환할 수 있다.
		* 에러객체는 error에서 상속을 받은 객체를 의미한다.
		* 함수내에서 에러객체를 반환하는 경우 타입은 반드시 nullable이 되어야 한다.
		* 만약 에러의 종류 상관없이 무시하고 다음 처리를 하고 싶다면 `safe-navigation`을 하면 된다.
		* 에러를 세밀하게 알고 싶다면 on을 사용해서 처리한다.
		* [ ] 에러가 발생했을때, 그 에러의 세부 필드를 같이 반환하고 싶다면?
			* [ ] 일종의 모나드처럼 `null`이 아니라 2번째 타입이라는 의미로 `?`를 사용한다면?
				* 함수의 반환형을 사용할때 2번째 타입을 같이 명시한다.
				* 2번째 타입을 명시하지 않으면 기본타입인 err가 된다. err에서 상속받은 타입들을 내보낼 수 있다.
				* safe-navigation에서 실패한 경우, 2번째 타입이 그대로 나가게 된다.
				* 1번째 값 혹은 2번째 값 둘 중 한개만 들어갈 수 있다.
				* `.` 을 하면 첫번째값이 있다는 확신! 이기 때문에 이를 primary type이라고 하자.
				* `!`을 하면 두번째 값이 있다는 확신으로 하는 것이다. secondary type이라고 하자.
```go
	foo(a int, b int) int? // 2번째 타입은 nil이다.
		if b == 0 -> ret nil // nil은 err에서 상속받은 것이다.
		a / b

	foo2(url str) int?networkErr // 2번째 타입은 networkErr이다.
		http.connect(url) // 이 함수는 2번째 타입으로 networkErr을 이미 정의했다.
		
main() void
	foo(2, 0)

	foo2("http://lycos.com")?.openSocket() // 2번째 타입이 뭐건간에, 2번째 타입으로 되어있지 않다면 openSocket()을 하라는 것이다.
	print(foo2("nothing")!.msg) // 2번째 타입일 경우에만 msg에 접근한다. print에는 msg의 타입이 들어간다는 사실이 컴파일 된다.
```
* 응용
```go
getLayout(t: bool) verticalLayout?horizontalLayout
	ret t ? verticalLayout() : horizontalLayout()

w := getLayout(val)!.horizontalWidth
```
* [x] 음.. 이게 필요한 경우가 별로 없나? ⇒ 그런듯
* [x] upcasting은 어떻게 되나? --> 가능은 할 것 같다. 단 하나의 타입으로 casting 하는 기능은 지원해야 한다.
```go
v widget?Button := ....
v1 := v as widget?ImageButton
```
* [x] 2개 모두 하나의 타입으로 된다면? ⇒ 안된다. 너무 복잡하다. 중첩타입의 중첩타입 같은 문제도 나온다.
```go
def view
def widget view
def button view
def nothing
v widget?button

// 케이스 <단일타입 vs 단일타입> ==> 같은 갈래라면 컴파일 OK
// 같은 갈래라는 것은, 둘 타입이 서로 조상 혹은 자손 관계인지를 보는 것이다.
view as nothing // 에러: nothing은 view와 공통된 갈래라는게 없다.

// 캐스팅이 실패할 경우 exception이 발생한다.
// ?란 err를 의미한다.

// 케이스 <중첩타입 vs 단일타입> ==> 중첩타입의 2 타입중 하나라도 단일타입과 같은 갈래라면 컴파일 OK
// nothing은 view와 조상 혹은 자식 관계에 있지 않은 것이다.
v as button // ok: secondary 타입이라면 button이 가능하다.

// 케이스 <단일타입 vs 중첩타입> ==> 단일타입이 중첩타입의 2개 중 하나라도 같은 갈래라면 컴파일 OK
widget as view? // ok: widget as view는 성립함
widget as nothing? // 에러: widget은 ?이 아님. widget은 nothing도 아님
networkErr as view? // ok: networkErr은 ?의 갈래.

// 케이스 <중첩타입 vs 중첩타입> ⇒ primary가 prmiary로, secondary가 secondary로 각각 갈래라면 컴파일 OK
v as view?nothing // 에러: secondary as nothing은 실패한다.
v as view?view // ok: widget as view, button as view 각각 성공한다.
v as view? // 에러: button as err은 실패함.

// 타입수렴:
v! // v를 secondary 타입으로 수렴을 try 해보는 것이다. 실패시, 해당 구문 전체가 null이 된다.
v? // v를 primary 타입으로 수렴 try한다.
v!! // v를 secondary 타입으로 확정 수렴한다. 실패하면 exception이 발생한다.
v?? // v를 primary 타입으로 확정 수렴한다.
foo(w widget) int
	.....
foo(v?) // foo(v as? widget) 과 같다.

a := foo(v?) // a는 int? 타입이다.
if a! // ==> if a!.isErr
	...do err...

a := foo(v?)
	on -> ...do err...

v! as button
v1?
```

* [ ] 이렇게 하면 그런데, 장기적으로 에러타입(nullable type)이 엄청늘어나는 것이 아닌가?
* [ ] 죽는냐 사느냐는 개발자에게 맡기면 어떨까? 왜?
	* 기존 OOP에서도 개발자는 죽느냐 사느냐를 맡고 있다.
	* 아니 오히려 죽느냐 사느냐가 전적으로 개발자에게 맡겨지고 있다. elm 처럼 모든 예외처리를 강제하는 것이 아닌 언어 모든 게 대부분.
	* 대표적인 케이스가 배열에서 elem를 꺼내는 부분이다.
		* OutOfBoundException이 발생가능 한데, 배열에서 원소를 꺼낼때는 왜 매번 try catch를 하지 않는가?
		* 자바에서는 RuntimeException으로 이걸 분류하고 있고, 이것들은 compile단계에서는 알 수 없으므로 굳이 try - catch를 하지 않아도 되도록 구현을 해놓았다. CompileException들은 try - catch가 없으면 에러로 취급한다.
			* RuntimeException들은 try를 쓰지 않아도 되게 했다는 건 사실 변명같다. RuntimeException 중에서도 중요한게 얼마나 많은데.
			* RuntimeException으로 분류가 되어있으니 사용자도 try를 안한다는 것도 이상하다. try catch를 신봉자 처럼 떠받들면서 평소에도 맹신하듯 발언들을 하는 것 치곤.
* point를 정리좀 해보자.
	1. 에러가 있다는 것, 함수가 에러를 내보낸다는 걸 쉽게 알 수 있어야 한다.
	2. 모든 에러를 즉각적으로 처리하는 것은 불가능하다.
		* 함수형은 가능했지만, 그건 함수를 매우매우 잘게쪼개려고 드는 언어니까 가능한거라고 본다. OOP는 기본 함수가 많게는 몇백 라인까지 쓰는 사람들도 수두룩 빽빽하다.
	3. 따라서 에러의 처리를 무시할 수도 있어야 한다. ==> 실제로 많은 개발자들은 배열의 원소를 꺼내는 코드에서 try를 쓰지 않는다.
	4. 에러를 아무도 처리하지 않으면 바로 터져야 한다. ⇒ 빨리 실패해야 생산성이 올라간다.
	5. **try - catch를 쓰고 싶지 않다**
* try-catch가 위의 요건들 중 얼마나 만족하는지 보자.
	* 1번은 힘들다. throws로 표시하기도 하지만, 너무 길어져서 못생기기도 하다. 그리고 함수 안에서 throw를 하는 경우는 또 표현이 잘 안된다.
	* 3 가능. 4 가능. 3과 4의 요건을 만족한다.
* ELM / Haskell 방식은?
	* 1. 가능. 타입을 보면 일목요연하다.
	* 2. 가능. 3. 가능. MayBe는 일종의 에러를 내포한 상대로 지연을 하고 있는것이다.
	* 4. 터지지 않는다에 가깝다. 모든 에러를 대처해야 하므로.
* 이제 내 방식을 요약해보자.
	1. 중첩타입과 모나드에서 힌트를 얻어, 에러와 타입을 중첩시킨다.
		* 에러 말고 다른 타입을 중첩하지는 못한다.
			* 이렇게 하면 secondary 타입을 적극적으로 다룰 수 있어야하므로 문법이 늘어난다.
			* secondary타입에서 에러가 발생하면 중첩타입의 중첩타입이 된다. 복잡하다는 것.
	2. 에러를 중첩시킨다는 건 에러를 바로 처리하지 않고 지연시킨다는 것이다. 폭탄을 앉고 가는 것. 대신 에러가 들어있다는 걸 명시적으로 타입으로써 인식시킨다.
	3. 중첩된 타입으로부터 에러가 없는 타입으로 암시적 캐스팅이 지원된다. 그러나 실패하면 거기서 바로 앱은 죽는거다. 이 기능은 빠른 실패를 위해서 넣은 것이다.
	4. 중첩된 타입에서 에러를 무시하고 더 지연시키고 싶으면 safe-navigation을 사용하면 된다. ?.가 있듯이, !.도 있다.
	5. 에러를 바로 처리하고 싶다면 on을 쓰면 된다.
	6. try-catch는 없다.
	7. ! 뒤에 더 상세한 에러의 타입을 명시할 수 있다. 캐스팅도 지원한다.
	8. ?는 값으로 수렴해보는 걸 의미한다. !는 에러로 수렴해보는 걸 의미한다. 
	9. 중첩타입을 ?나 ! 없이 수렴도 가능하다. 단, 실패하면 거기서 죽는 것이다.
	10. 타입 뒤에 ? 가 붙으면 nullErr가 중첩된 걸 의미한다.
	11. 타입 뒤에 ?! 가 붙으면 err(에러의 기원)을 의미한다.
	12. 나눗셈은 int!divideZeroErr를 반환한다. 그러나 이 결과를 int로 받을 수 있다는 점이 중요한 것이다.
	13. array[n]도 T!invalidIndexErr 가 나간다. 그러나 역시 T로 받을 수 있다.
* 내 방식의 예제를 작성해보자.
```go
isPkgEnable(c ctx, name str) bool
	am := ctx.adultMgr()
	enable := am.getAttribute(name) // int?illegalArgErr
	if am.CLOUD_STATE == enable? || // enable이 에러일 경우, 이 == expr 자체가 null로 된다.
	   am.TRASH_DISPOSAL == enable?
		ret false // ret는 if에 영향을 받지 않는다.
	else
		am?.getBucketInfo(name, am.ALTAR_OF_DIA)
			on noNameErr -> ret false
			on
				leaveLog(it.msg)
				ret false // ret는 on, if에 영향을 받지 않는다.
		ret true
// 원본은 22줄 이었는데, 13줄로 압축이 가능했다.
// 그러면서 모든 기능을 구현 할 수 있었다.

// 예제2:
/*
val a: Int? = try { parseInt(input) } catch (e: NumberFormatException) { null }
fun printNumber(reader: BufferedReader) {
	val number = try {
		parseInt(reader.readLine())
	} catch (e: NumberFormatException) {
		return
	}
	println(number)
}
*/
a := parseInt(input)
printNumber(reader BufferedReader)
	number := parseInt(reader?.readLine())
		on NumberFormatException -> ret
	print(number)
// 결과: 9줄 -> 5줄: 거의 50% 수준으로 압축되었다.
```

* `on`은 별다른 말이 없어도 ret가 적용된다.
* errCheck를 해서 함수를 빠져나간 흔적이 있는 경우, 그 밑에 줄부터는 non-errType이 된다.
```go
// 방식1:
parsed := json.parse(rawStr) // parsed는 jsonObj?parseErr 타입
print(parsed?.value?) // 이것은 parsed?.value가 err가 아닐 경우에만 print가 실행된다.
print(parsed?.value) // 이것은 print에 str?parseErr을 넘긴다.

// 방식2:
parsed := json.parse(rawStr)
if parsed! -> ret // 여기서 err인지 체크를 했기 때문에
print(parsed.value) // 여기서 쓰인 parsed는 err타입이 아니다.

// 방식3:
parsed := json.parse(rawStr) // parsed는 jsonObj 타입이다. 에러가 아니다.
	on parseErr // 자동 return 된다.
	// parseErr외에 다른 에러가 오면 바로 죽는다.
print(parsed.value)
```

### 추가로 예외처리에 고민해야할 점
* [x] stack trace가 필요하다. ⇒ 가능하다.
* [x] 사람들은 catch보다도 finally를 매우 중요하다고 생각한다. 이게 가능한가? ⇒ 문법추가하면 가능
	* 특정한 리소스가 해제되는 시점을 개발자가 원하는 대로 가져가게 하고 싶다는 것이다.
	* 아무리 reference counting으로 GC를 구현한다고 하더라도 함수내에서 만든 객체가 함수밖에서 돌아다닐 수 있다는 사실은 변하지 않는다.
	* 따라서 *함수밖에 나가면 안에서 만든거는 모두 resource 해제!* 이렇게는 할 수 없다는 것이다.
	* 리소스가 해제되는 시점을 개발자가 tweak할 수 있도록 추가 문법을 제공해야 한다
* [x] 메모리 부족으로인해 정의가 불가능한 경우가 있을 수 있다. 이 경우도 error로 취급하는가? ==> 발생하면 그냥 죽는거다. stacktrace정도는 띄워주자.
	* 제일 걱정되는 건 이때의 정의하려는 변수는 T? 인가 라는 점이다.
	* 근데 이 부분은 kotlin도 해당된다? ==> 아니오. 코틀린 try catch를 사용하므로 exception이 발생하면 블록을 빠져나가버린다. 그래서 T?가 아니어도 된다.
	* 실제로 사용자가 할만한 대처방법이 거의 없다는 게 사실이고. 그런 언어들도 많다. haskell이나 python.
* [ ] 타입 뒤에 ?가 붙으면 nullErr, 타입뒤에 !가 붙으면 err 이렇게 할 필요가 있을까? 그냥 err로 1개만 통일해버리면 어떨까?
	* null을 굳이 구분할 필요가 있는가... 란 얘기다.
	* [ ] 먼저 생각해봐야 하는건,  *safe-navigation이 실패를 하면 무슨 타입으로 eval 되는가* 이다.
		* 다음 예제를 보자.
```go
val := parsed?.parse(rawStr)?.value // val은 str?parseErr를 갖는가?
```
* val은 err중첩 타입이라는 점에서는 이견이 없다. 문제는,
	1. str?err 인가?
	2. str?parseErr인가? 그렇게 생각하나? 그럼 다음 예제를 볼까?
```go
// parse는 parseErr를 내보낼 수 있다.
// openUrl은 networkErr를 내보낼 수 있다.
socket := http.openUrl(parsed?.parse(rawStr)?.url) // socket의 타입은?
// 1. 처음이 parseErr였으니 parseErr다.
// 2. 
```
* 여기서 한가지 유력한 사실은, errType은 한 구문 내에서 err을 발생하는 것들을 deduce해서 결정해야 한다는 것이다.

* [ ] 변수를 정의하다가 exception이 발생한 경우는 어떻게 되는가?
	* out of memory에 국한된게 아니다. 생성자에서 exception이 나오면 어떻게 되느냐는 것.
* [ ] 기호의 의미가 명확하지 못하다.
	* ?가 에러를 의미하는가? !가 의미를 의미하는가?
	* ?.는 뭘 의미하는가? !. 는 무엇을 의미하는가?
	* foo(a?, b!)는 각각 무엇을 의미하는가?
	* a?! 나 a??가 존재하는가?
* [ ] 에러를 내포한 타입에게 담아내는 것 까지는 좋다고 치자. 문제는 이 변수를 정의만하고 쓰고 버리게 되면 결과적으로 에러를 처리하지 않은게 되버린다. 개발자가 의식하지 않으면 에러를 처리하지 않게끔 코드가 유도된다는 점이다.

* * * 
# [o] Module 서버를 github을 통해 만들 수 있다
* Module을 중앙 서버를 두고 거기서 어떠한 github repo로 가야하는지를 서버에 직접 register하도록 할 생각이었다.
* 그런데 github을 응용하면 서버를 직접 만들지 않고도 적은양의 데이터는 대처가 가능한 방법이 있었다.
* 먼저 github repo를 하나 만든다.
* 해당 repo에 json 파일을 하나 업로드하고 거기에 module 코드와 배포가 담긴 repo를 작성한다.
* 그리고 앱에서 해당 파일을 curl로 긁어와서 파싱하면 된다.
* github의 repo를 서버처럼 쓰는 것이다. jekyll과 같은 방법.
* 단점은 모듈을 등록하는 과정이 조금 불편하다. PR을 받아서 넣어야 하니까.
* 하지만 github은 rest API가 아주 잘 지원을 해주고 있고, MS의 안정적인 서버장비와 합쳐져서 속도도 꽤 빠르다.
* 돈도 안든다.
* 하나의 모듈은 약 7줄 정도로 용량이 매우 적다.
	* 작성자
	* module Name
	* repo 위치 (baseUrl 적지 않도록 해야 한다. 바뀔 수 있자나)
	* 등등
	* 다운로드 경로를 직접 넣으면 안된다. 왜인지는 알지?
* obsidian에서는 1000개 이상의 플러그인을 이런식으로 관리하는데 속도도 무진장 빠르다.
* 3000개 까지도 충분히 가능할듯.
* rest API 사용법: https://docs.github.com/ko/rest/deployments/deployments?apiVersion=2022-11-28
* obsidian에서 이렇게 사용해서 알게되었다.
	* https://github.com/obsidianmd/obsidian-releases/blob/master/community-plugins.json
 * * *
# [o] 심볼명을 통해서 attribute를 지정할 수 있도록 하자. ==> **OK. 그러나 보편적인 코딩스타일에 준수해야만 한다.**
* 예를들면 앞에 `_` 붙이면 protected 이다.
* `able`로 끝나는 origin 객체는 interface이다. ==> **이건 좀 아니다. 작명이 영어권에서 굉장히 어색해지는 경우가 생기므로**
* * *
# [o] 과연 rhs를 getExpr()인지 아닌지로 판단하는게 옳은가? ==> **에러로 판단하자.**
```go
(if 2 > 5
	a
else
    b
) = 3
```
* [x] 이건 되는게 맞나? ==> **아니오.**
	* 내 경험으로만 봤을때는 `안된다`지만, `젤다적으로` 생각하면 되야 하는게 아닌가? ==> **문법 파싱 난이도가 너무 올라간다.**
	* [ ] 다른 언어는 어떻지?  ==> **당연히 이걸 해주는 언어는 없다.**
* * *
# [o] for문은 배열을 반환해야 한다.
* * *
# [o] Zen: 젤다 같은 걸 만들자.
* 이게 되나? 싶으면 되야 한다.
* 다른 것과 융합되고 시너지가 나는 곱연산이 되는 걸 만들자.
	* 이를테면 when.
		* 단순히 쓰면 swtich의 역할을 수행한다고 볼 수 있지만,
		* FP 언어에서는 합타입을 만들어서 모나드, 패턴매칭, 등까지도 가능하도록 했다.
		* 하나의 기능을 만족하는 데서 그치는 게 아니라, 그 기능을 다른 기능과 접목하면 색다른 기능이나 문법을 대체할 수 있는 걸 만들자.
  * * *
# [x] 변수를 정의하는 것과 함수를 정의하는 것을 하나로 하면 어떻게 되나? ==> **안된다. 정의인지, assign인지 구분이 안가니까.**
* 옛날에 한번 생각했던 거긴 하다.
* = 를 쓰는 것은 싫다.
```go
a := 5
main := fn(args str[])
	...blabla
```
* 아이디어1 `:`을 `:=` 대신 쓴다면?
```go
a: 5
main: (args str[])
	.....blabla
```
* [ ] 개인적인 질문: 그러면 def Object도 바꿔야 하는거 아닌가?
* * *
# [o] 프로토타이핑 vs 클래스 ==> **완전객체의 문법의 초안을 여기서 만듬**

> 결론:
> 1. def 객체정의시 소괄호를 넣지 않아도 기본생성자(parameter가 없는)가 있다면 그걸로 완전객체가 된다.
> 2. expr 로부터 객체를 상속받아 def를 확장할 수 있다. 이 경우 생성자와 완전객체는 다른 값을 가질 수 있다.

* 클래스는 플라톤의 이데아론에서 옴. 불변인 보편적 실체가 존재하고 사물은 모두 그곳에서 일부가 결여된 것이라는 이론.
	* 그러므로 클래스라고 하는 불변의 보편성을 상징하는 타입을 표현하는 뭔가를 만들 수 있고, 객체는 다 여기서 탄생한 것이다.. 라는 생각.
	* 처음부터 보편적 객체를 정의하고 가야하므로 정적타입을 갖게 된다.
	* 어떠한 보편적 객체는 처음부터 생성이 불가능하고, 런타임에 다른 객체의 도움을 통해서 값을 가질 수 있는 것들이 있다.
	* 그러므로 보편적 객체와 일반객체는 구별이 되어야 하며 각각 메소드, 변수가 일반 객체의 그것과 별도로 처리되어야 한다.
		* (== static)
* 프로토타이핑은 아리스토텔레스의 실체론에서 옴. 각 사물들의 공통적인 속성과 관점으로 보편성이 나타난다는 이론.
	* 그러므로 프로토타이핑은 걍 객체들이 너부러져 있고, 런타임에 메소드나 속성을 추가하면서 작자가 "이 객체가 보편성을 가지오" 라고 선언하면 그것이 보편적 객체가 된다는 관점. 객체들은 서로 복제될 뿐이라는 것.
	* 그러니 런타임에 타입이 결정되므로 동적타입을 갖게 된다.
* 나는 **정적타입**이 좋다.
* [x] 2개를 적절하게 mix해보자. --> 일단 구현은 가능하다.
	* [x] 함수의 결과값으로부터 상속을 할 수 있다.
	* [x] 생성자로 태어난 다른 객체로부터 상속을 할 수 있다
	* [x] 완전객체의 기본값을 정의하는 것이다.
	* [x] 기본생성자가 있는데, 소괄호를 적지 않으면 자동으로 완전객체가 된다.
	* [x] 기본값이 적용된 완전객체에 생성자를 호출하면 완전객체의 복제가 나오는게 아니다. 생성자에서 정의한 기본객체가 나오는 것 뿐

```go
def A // A는 newAge를 받는 객체이므로 A뒤에 아무것도 () 를 넣지 않으면 A는 불완전객체다.
	me(newAge int) -> age = newAge
def B A(2) // B는 뒤에 () 괄호가 없으나, 빈 생성자가 있으므로 완전객체다.
	me() -> super(0)
	// B생성자에서 A생성자를 호출할때 어떻게 되는가? --> 기본생성자가 호출된다.
	// 이 상태에서 B를 그냥 사용하면 A(2)가 적용된 객체를 사용하는 것이다.
B.age // ok
b := B() // b의 age는 0이 된다.
b2 := B(B) // b2.age 는 2가 된다.
age 3 // 이것도 되는가?
def C(3) // C라고 적었다면 C.val은 1이 되었을 것이다. C(3)으로 적었으므로 C.val은 3이 된다.
	me() -> me(1)
	me(newVal int) -> val = newVal
// 이런 기능이 필요한가?
```
* * *
* * *
# [x] #at_문법을_다시_한번_정리 ==> **없애자. 이제는 단점이 더 많아졌다.**
* 정말 이 문법은 쓸모가 있을 것인가?
* 단점은 몇개 꼽아볼 수 있는데 말이야.
    1. 이름 충돌을 더 많이 야기한다.
    2. 기호가 3개가 한자리에 나오게끔 만든다.
    3. 불완전객체는 대문자인데, 완전객체가 대문자처럼 보이게 만든다.
* 꼭 필요한 기능이 아니라 편의기능이란 점이다. 근데 과연 정말 편한가? 많이 편한가?
```go
def main
    @A // A A 라는 뜻이다.
    @A(5) // A A(5) 라는 뜻이다.
    @A := 5 // err. @A와 := 가 같이 올 수 없다.

// 원본은:
def main
    a A
    a := A(5)
    a A := 5
```
* 그러나 현재의 `@`는 다음처럼 불완전객체에 대해서 사용하면 헷갈리기 시작한다.
```go
def A // 불완전객체
    ctor(age): ...
    age := 0
def B
    with @A(5) // 1
    foo()
        print(A.age) // A는 불완전아니야?
// 원본:
def A
    ctor(@age): ret // @는 이제, `자동assign` 이라는 기호다.
    age := 0
def B
    with a := A(5)
        // A와 a는 scope이 다르기 때문에 에러는 아니다.
        // 그러나 완전객체를 A라고 명명하는 것은 에러다.
    foo()
        print(a.age) // 이제 자연스럽다.
```
* 1번에서 A는 완전객체다. 그러나 이름이 대문자로 시작하므로 불완전처럼 보인다는 것이다.
1. [u] 없앤다. 전체 문법 spec이 확정됨에 따라, 생각보다 쓸모없고 단점이 더 많아졌다.
* * *
# [o] abstract한 func은 어떻게 문법을 정의할까? ==> **body를 정의하지 않으면 된다. 이때 반환형, param은 반드시 적어야 한다.**
> 그냥 간단히 `= null`붙이면 되는거 아냐?
* 라고 생각하기 쉬울 수 있는데, 그렇지 않다. 이유는 이렇다.
    1. abstract한 def 객체는 어떻게 만들 수 있느냐는 물음이 뒤따른다.
        그건 `= null`안 붙이고 `abstract def` 나 `interface`를 쓸 생각이라면, `하나의 문법으로 다양한 곳에 적용한다` 는 ZEN과 맞지 않는다.
    2. protected는 이름에 `_` 를, interface는 뒤에 `able`을 붙이는 것으로 표현하고자 하고 있다.
        즉, `속성은 이름의 style로 표현한다` 라는 것이다.
        이걸 함수의 abstract 속성에 영향을 줄 수 있다면 best 일 것이다.
* [d] 1안: style로 해결한다. ==> **어떻게 해도 적절한 함수명을 찾기가 힘들다.**
    * [?] 지금은 객체의 경우는 `able` 인데, 함수는 함수명 `able`을 넣는게 조금 적절치 않아 보인다, 나는 왜 그렇게 생각할까? ==> **관례적인 style과 합치되지 않기 때문이다.**
        * interface에 able을 붙이는 것은 관례상으로 하는 것이다. 그러니 그런 style을 고수한다고 했을때 다른 사람들은 비교적 쉽게 받아들인다.
        * 그러나 override 함수명에 일종의 style을 강제하는 것은, 일반적으로 하지 않는 것이므로, 받아들이기가 쉽지 않을 것이다.
        * 또다른 문제로는, 함수명에 `able` 이 들어가는 것이 영어로 독해할 때 자연스럽지 않다는 점이다.
            * able처럼 `ADT 입니다.` 라는 뜻이 아니라 `override 합니다` 라는 뜻이 되어야 하며, 충분히 짧아야 한다. 아무리 못해도 4글자.
        ```go
        def A
            foolike() void
        def B
            foolike() void
        ```
        * 이상하다.
        * 백보 양보해서 B::foolike()는 이해한다고 쳐도 A::foolike()는 힘들다.
        * B는 foo()를 override한거니까 foo와 비슷한, 그러니 foolike()인 것은 알겠다. 하지만 A는 foo 자체인데? foolike가 아닌것이다.
        * [*] interface의 경우에는 attribute가 붙는 클래스명 1개에만 국한된 얘기다. 하지만 함수명은 원본 함수명과 override한 함수명이 일치해야 하기 때문에 모든 override된 함수명과 원본함수명이 영향을 받게 된다.
        * 그래서 이러한 어색함이 나오는 것.
* * *
# [o] override 탐지를 어떻게 할까? ==> **기호`+`를 앞에 붙여 표현한다**
* Why?
    * override 키워드는 3가지 실수를 방지한다.
        1. 나는 그냥 함수를 정의했을 뿐인데, `실제로는 이런 함수가 이미 있었구나` 싶은 상황
        2. 나는 이 함수를 override 해서 잘 쓰고 있었는데, `원본함수 signature가 수정되었구나` 상황
        3. `이 함수를 override 해야지!` 했는데 단순히 스펠링이 틀렸거나 인자가 틀린상황을 컴파일타임에 잡아내기
    * 을 빠르게 에러를 탐지하기 위한것이다. 특히 *3번은 아주 자주 만나게 되는 상황*이다. 그러니 꼭 넣자.
    * 그런데 이 함수/prop가 override를 한 것이라는 걸 어떻게 표현하면 좋을까?
* [d] 1안: 키워드를 추가한다. ==> **안된다.**
    ```go
    def A
        override foo() void
            ...
    def B A
        override foo() void
            ...
    ```
    * 이 방식의 가장 큰 문제점은, override 키워드를 넣게 되면, private, public, static 도 넣게 된다는 점이다.
    * [*] 즉 다 넣어서 다른 사람들이 하던대로 하던가, 아니면 아예 빼 던가 2택만 있을 뿐 어중간한 중간은 있을 수 없다.
* [d] 2안: 기호를 추가한다. ==> **가장 그럴싸한 기호가 `<` 였는데, 역시 혐오스럽다. 그리고 기호가 2개이므로 우선순위 문제도 생긴다. `_<`도 허용할 것인가 아니면 `<_` 만 허용하는가와 같은 문제다. **
    * `_` 를 어짜피 쓰고 있으니, 여기서 기호를 하나만 더 추가하자.
    * 대신 기호3개가 붙는 건 이상하다. 2개가 한계라고 생각한다.
    * 그러니 하나의 기호만 더 추가해서 abstract, override, interface 3개를 모두 표현했으면 좋겠다.
    * [d] `<` 혹은 `>` 를 사용한다.
        * abstract, interface를 `빈공간이 있습니다` 라는 의미다.
        * 반면 override는 `빈공간을 채웁니다` 라는 뜻이다.
        * 2개의 의미가 정반대이기 때문에 하나의 기호로 표현하는 것은 힘들다.
        * 다만 2개는 정반대이므로, 2개가 동시에 사용될 경우는 없다. 그러니 `총 3개의 기호`라는  목표를 유지할 수 있다.
        * 그리고 정반대이기 때문에 기호 또한 `정반대구나` 라고 직관적으로 인식할 수 있는 기호가 좋다.
        * 다음처럼 될 것이다.
            * `>`는 일반적인 독해 순서가 왼쪽에서 오른쪽이다.
            * 즉 왼쪽은 과거, 오른쪽은 미래를 의미한다.
            * 과거에서 미래로 지향하는 것이므로 `빈공간이 있습니다` 가 된다.
            * 반면 `<` 는 미래에서 과거를 지향하므로 `빈공간이 있었지요? 그걸 채웁니다` 라는 뜻이 된다.
        ```go
        def >A // A는 빈공간이라는 뜻이므로, A는 inteface다.
            >foo() void// foo는 빈공간, abstract라는 뜻이다.
            boo() void
                ....
        def B A
            <foo() void // override를 했다는 뜻이다.
                ...
            boo() void // 에러다. override를 했으므로 앞에 <를 붙여야 한다.
                ..

        // override, interface,
        ```
        * 일단 드는 생각은 `지저분`하다.
        * 의미를 생각해보면 `<`, `>` 를 쓴 이유는 알겠는데, 직관적이지는 못하다.
        * def B에서도 `def <B A` 처럼 해야 하는 것은 아닌가? 그게 ZELDA 스러운게 아닌가?
    * [d] 적절하게 mix 한다. ==> **`<` 가 들어간 순간 이미 혐오스럽다.**
        * able을 쓰면 interface로 간주한다.
            * interface는 변수를 가질 수 없다. 프로퍼티는 가능하다.
            * interface는 abstract func만 있을 수 있다. 구체 함수는 안된다.
            * able을 상속한 객체는 반드시 abstract func에 대한 override를 채워놓아야 한다.
        * `= null` 을 쓰면 abstract func 이다.
        * `<`을 쓰면 override 라는 뜻이다.
        ```go
        def fooable
            foo() void = null
        def B fooable
            foo() void
                ....
            boo() void
                ...
        ```
        * [*] `<`가 한개만 쓰여도 2개 쓰일때와 마찬가지로 혐오스럽다. 1개 쓰이나 2개 쓰이나 똑 같게 느껴진다.
* [d] 4안: 그럼 `override` 이 기능을 쓰면 경고로 대체하자. ==> **hiding 하지 마세요! 라고 경고는 줄 수 있겠지. 하지만 override 키워드를 달려는 이유는 그게 아니라 `원본 함수가 어딘가에 있어야 한다는 제약을 주는 것`이다.**
    * 처음에는 override를 쓰지 않았다고 해서 경고를 내보내줄 수는 없다고 생각했다. method hiding을 하려고 의도한 것일 수도 있다고 생각했기 때문이다.
        * C++에서는 method hiding을 지원하고 C#도 지원하기 때문에 모든 언어가 이를 지원할 거라 잘못 생각하고 있었다. 자바는 지원하지 않는다.
        * 그러면 c++를 왜 method hiding를 지원할까? 이 것의 가장 큰 장점은 type downcast가 지원된다는 점이다. 예제를 보자.
        ```cpp
        struct A {
            A getType() { .... }
        };
        struct B : public A {
            B getType() { ....}
            void boo() {...}
        };
        A* b = new B();
        // 이상태에서는 B::boo() 호출이 힘들지만,
        B* b1 = (B*) b;
        b1->getType()->boo(); // 일단 한번 downcast를 하면 여기서부터는 편안하게 구체화된 subtype들을 뽑아낼 수 있다.
        ```
        * 그렇다. 이렇게 굉장히 제한적으로나마 유용성을 갖게 된다는 점이다.
        * 하지만 이러한 downcast 외에 method hiding을 사용하게 되면 RSP도 어기게 된다. 같은 계열의 함수처럼 보이지만 동작이 저마다 다르게 된다는 것.
        * java 같은 경우는 virtual 키워드 자체가 없기 때문에, signature를 동일하게 하면 그냥 override로 간주한다. hiding이 아니라.
            * 대신에 java는 covariant를 지원한다.
            ```java
            public class A {
                public A foo() {...동작1...}
            }
            public class B extends A {
                public B foo() {...동작2...} // 반환형이 다르지만 A <|-- B 이기 때문에 지원하는 것이다.
            }
            A a = new A();
            a2 = new B();
            B b = new B();

            a.foo(); // 동작1수행, returns A
            a2.foo(); // 동작2수행, returns A
            b.foo(); // 동작2수행, returns B
            ```
            * 위의 예제처럼 java는 covariant를 사용한 경우, 구체타입에서 해당 override된 메소드를 수행한 경우에만 covaiant 타입을 반환한다.
            * [*] 내 언어도 이러한 기능을 지원해야 할 것이다. 그러면 method hiding을 지원해야 하는 이유가 많이 줄어들게 되니까.
            * 하지만 JAVA는 static 에 대해서는 method hiding을 지원하는 편이다. 예제를 보자.
            ```java
            public class A {
                public static void foo() {...동작1...}
            }
            public class B extends A {
                public static void foo() {...동작2...}
            }
            A a = new A();
            A a2 = new B();
            B b = new B();

            a.foo(); // 동작1
            a2.foo(); // 동작1
            b.foo() // 동작2
            ```
            * static은 상속되지 않기 때문에 `foo()`는 런타임 바인딩에 귀속되지 않고 정적으로 타입에 귀속된다.
            * [?] 내 언어는 static 구현을 with를 통해서 하려고 하고, 결정적으로 정적이 아니라 동적으로 구현된다는 점이 다르다.
                * 왜냐하면 내 언어는 static이라는 게 없고, delegation만 있는데, delegation이라는 게 런타임에 member variable를 통해서 질의하는 것이기 때문이다.
    ```go
    def fooable
        foo() void = null
    def B fooable
        foo(n int) void // override릂 하려고 했던 것인지, 아닌지를 알기 힘들다.
            ...
        boo() void
         ''   ...
    ```
    * 스타일 적으로는 좀 더 정돈 되긴 해 보인다. 새로운 키워드나 기호가 없기 때문에.
    * override 하려고 했다는 걸 알려줄 방법이 없다는 게 문제긴 하다.
* 다른 언어들의 경우에는 annotation을 주로 사용한다.
    * 왜 굳이 다른 언어들은 keyword로 안하고 annotation을 하는지는 조금 생각해볼 수 있다.
        * 구조와 컴파일에 영향을 주는 게 덜하고, 단순히 verification 단계에서 check만 한번 하면 되는 일이기 때문이다.
        * 예를들면
            * @override는,
                * super.sub(func.name) 이 있는지 체크만 한번 하면 되는 기능이라는 거다.
        * 즉 에러 탐지를 위한 기능이지, 런타임에 AST 구조를 변경하거나 하는 기능은 아니다.
        * `def`, `with` 와는 확연히 다르다.
        * 그러니 이미 annotation 기능을 지원하는 언어라면, 키워드로 하지 않고 annotation으로 하려는 거겠지.
5. [?] annotation으로 구현할까?
    * 만약 한다면, 다른 언어들과 다르게 `#` 로 해야 한다. 사실상 tag 니까.
6. [u] override를 위해 함수 앞에 기호 `+` 를 추가하면 어떨까? abstract는 body를 없애면 되게끔 하고.
    * 함수앞에는 `_`도 같이 쓰일 수 있다. 하지만 다 써봤자 기호 2개니까. 그정도는 괜찮지 않을까 싶었다.
        ```go
        def A // abstract 를 선언하기 위해서 대문자로.
            foo(): ret // 아무런 동작을 하지 않더라도 구현은 반드시 채워야 한다.
            boo() // err. body가 없다는 것은 함수의 선언만 한 것이다.
                  // 이 경우는 그 반환형도 반드시 써놓아야 한다.
            _boo() void // ok. 이 함수는 abstract 하다.
        def B
            with A
            boo()
                helper.doSomething() // err. doSomething() 의 반환값이 void가 아니라면 에러가 된다.
            +_boo() void // 1
            //_+boo() void // 처럼 적어도 된다. 근데 +_가 많는 convention rule.
                helper.doSomething() // ok. doSomething()이 뭔가를 반환하더라도 ret문을 직접 명시하지 않았으므로
                                     //     반환되지 않는다.
        ```
    * 사실 대문자로 했다고 해서 abstract라는 건 아니다.
    * 단순히 사용자가 `이 객체는 반드시 복사객체를 만들어서 사용했으면 좋겠다`
    * 라는 의미로 만든 것일 수도 있다.
    * prop도 모든 시나리오에서 앞에 붙이는 기호의 갯수는 2개다. 3개면 좀 그렇지만, 2개는 괜찮지.
    * 1처럼 모든 signature가 동일한데 오히려 `+`를  적어주지 않으면 에러로 간주한다. 내 언어는 method hiding을 지원하지 않는다.
> 요약:
>     override 키워드를 위해서 앞에 `+` 기호를 붙인다.
>     `_` 와 같이 사용될 수 있다. 이때 기호의 순서는 없다.
>     prop, func에 사용된다.
>    prop혹은 func의 반환형을 제외한 signature가, base와 같은데 `+` 를 적지 않으면 에러다.
* * *
# [o] abstract 함수/prop의 정의문법 및 구현방법 ==> **abstract def는 대문자로, abstract prop은 body 없애서, prop은 \_get;\_set으로 표현한다**
* why?
    * 구현 자체는 비교적 쉽다. eval은 동작하지만 run을 하면 반드시 죽는 더미 func이나 prop을 만들어 넣어두면 되는 것이다.
    * 문제는 문법이다.
1. [d] `= null` 을 사용한다. ==> **잘못 코드를 독해하기가 너무 쉽다. 안된다.**
    * 함수라면 괜찮다. 근데 prop이 문제다.
    ```go
    def A
        foo(a int) void = null // 이상하지만.. 뭐 OK.
        age B? = null // := 과 구분이 된다고 하지만 너무 비슷해서 한눈에 안들어온다.
        age2 B? := null // 이건 올바른 문법이란 말이지.
    ```
2. [?] `^@#` 같은 기호를 사용한다.
    * 기호가 너무너무 많다는 게 흠이다.
    * 하나 정도라면 그럭저럭 참아줄 만 한데, 이걸 허용해버리면 2개 3개가 되어버린다.
    * 그리고 abstract에 대한 이름에 대한 coding style도 존재하지 않는다.
3. [d] 어떻게든 생성자에 `pass`를 쓰고자 하는 니즈와 합쳐볼 수 없을까?
4. [d] 실행하면 반드시 죽는 keyword를 만들까?
    * go에 있는 fatal 같은 거.
    * `wtf` 같은 키워드로 넣으면 되지 않을까?
    * 같은 아이디어로 `pass`도 넣어서 생성자 문제도 해결하고.
5. [u] func은 body를 없애는 것으로, prop은 \_get;\_set 으로 표현한다.
    ```go
    def Base // abstract한 sub를 정의하니까 대문자로 해야 한다.
        foo(a int, b int) int // paramtype과 반환형을 모두 적어야, body를 날릴 수 있다.
        age int // 여기에 defAssign이 오면 안된다.
            _get // get, set 자체를 적지 않으면 기본동작으로 하라는 얘기다.
                 // 이 경우 age int는 기본값인 age int := 0으로 동작한다.
                 // get만 적고 body가 없으면 abstract func다. abstract는 호출하는 순간 exception이 발생한다.
            _set // age int로 했는데 이렇게, get, set 모두 abstract로 선언하면,
                 // 이제 이 prop은 abstract가 된 것이다.
    ```
* * *
# [o] 생성자에서는 return/ret을 쓸 수 있다.
* 생성자의 코드 실행에 따라서 abstract에 대한 with prop 초기화가 에러인지 아닌지가 판별된다.
* [d] return을 허용해버리면 이 에러 판별알고리즘이 매우 복잡해질 것이다. ==> **새로 바뀐 알고리즘인 --> 를 사용해서 해결한다.**
* [?] 그런데 생성자에서 return을 못쓰면 `ctor(attr)` 같이, 어떠한 body도 필요없는 생성자는 어떻게 되는건가?
    1. [?] python의 `pass` 같은 새로운 키워드 추가한다.
* * *
# [o] 함수식별자 접근 문법 ==> **`A.B(C D)` 로 접근한다.**
* why?
    * sub를 접근할때 `obj.A` 문법으로 접근하게 된다.
    * 이때 overloading을 한 함수가 있을 경우 함수의 이름만 가지고는 모호해진다.
    * 이때의 접근 문법은?
```go
def a
    foo() void: ..
    foo(n int, n2 int) flt:...

a.????
```
* 다른 언어들은?
    * kotlin: reference를 만들때 타입추론을 쓰지말고 추가정보를 주는 식으로 해결한다.
        ```kotlin
        val f = a::getitem // err. getitem이 2개 이상이다.
        val f: (string) -> item = a::getitem // ok.
        ```
    * java: kotlin과 비슷하지만 더 번거롭다. interface로 param, returntype을 다 명시해두고, 이걸로 값을 초기화해서 받아온다.
        ```java
        public interface foosjsjwer {
            int anyName(int n, int n2);
        }
        public class Util {
            public static int thisFunc(int x, int y) {
                return x + y;
            }
            public static int thisfunc(float x, float y) {...}
        }
        foojsjwer ref = Util::thisFunc;
        ref.anyName(2, 3);
        ```
    * python: overloading 자체가 없음
    * go: overloading 자체가 없음
    * swift: 로직이 조금 복잡하다. 근데 사용법은 간단하다.
        * parameter label라는 기능이 있다.
            * 이는 함수호출시 순서에 관계없이 argument와 parameter 바인딩을 해주는 기능이다.
            ```swift
            func test(a: Int, b: Int) -> Int {
                ....
            }
            test(b:33, a:22)
            ```
        * 함수의 참조는 기본적으로 A.B 로 참조한다.
        * 그런데 B 함수가 overloading일 경우 A.B만으로는 어느 함수인지 구분이 가지 않는다.
        * 이럴때 parameter label을 사용한다.
        * 왜냐하면 swift는 타입이 같아도 함수를 만들 수 있기 때문이다! ~~미친언어야...~~
        ```go
        struct File {
            foo(name: String) {...}
            foo(path: String) {...}
        }
        let fun = File.init // err. 이렇게 하면 모호하다.
        let fun = File.init(path:) // ok.
        ```
    * dart: method overloading을 지원하지 않는다.
1. [?] swift와 비슷하게 한다. 기본은 타입추론, 실패시 `A.B(C D)` 의 형태
2. [u] 일단은 `A.B(C D)` 처럼 하는 걸 가이드해주고, 여유가 생기면 타입추론도 구현한다.
    * 여기서 타입추론을 전제로하지 않는 이유는, 이 타입추론은 다른 것들 과 방향이 다르기 때문에
    * 구현이 어렵기 때문이다.
        * 지금까지는 top down 방식의 verification을 사용해왔다. 근데 이 방식은 bottom up 방식으로 추론이 돌아가야 한다.
        * 예를들어보자.
        ```go
        def a
            foo(name str) void
            foo(age int) void
            foo() void
        a.foo // 모호하다.
        a.foo(x str) // ok. `x`는 실제로는 어디에서도 사용하지 않는다.
        a.foo(void) // ok? 이렇게 쓰면 예외로 `foo()` 를 찾으라는 명시적인 구문이 된다.
                    // [?] 타입접근은 항상 A B 형태였는데 여기서만 1개? 일관성이 너무 없는 거 아냐?
        onFoo() void // body가 없고 반환형이 있다. 즉, 이건 decl이다. 메소드 호출이 아니라.
        init(fooer onFoo)
            fooer()
        init(boo(5).foo) // 1: init의 param은 onFoo다 --> onFoo는 param이 없어야 한다. --> 아 그럼 a.foo중에서 foo() void가 되어야 하겠다.
        // 타입추론이 이렇게 되어야 한다.
        ```
        * 1 부분을 봐보자. 현재의 구현대로라면 callstack이 다음과 같을 것이다.
            ```cpp
            at verifier::onVisit(getExpr&) // a.foo 부분. me는 runExpr("boo", {5}) 이다.
            at verifier::onVisit(runExpr&) // init() 부분
            ```
        * a.foo 부분을 검증할때의 getExpr는 a안에 foo가 3개라는 걸 알아낼 수 있다.
            * foo 중에서 하나라도 prop이 있다면 이것은 명백한 오류다.
            * 하지만 3개가 모두 함수라면 getExpr은 이 시점에서 에러인지 아닌지 판단이 불가능하다.
            * 타입추론을 해야하는데 타입추론 정보가 func의 parameter, 즉 func을 들고있는 runExpr에 있기 때문이다.
        * 하지만 위의 예제를 직접 작성해보니 좀 알겠는데, 1번 코드를 어떻게 변경해봐도, `foo` 로 overloading된 함수에 접근하는 코드의 부모는,
        * 반드시 그 필요한 func 정보를 들고 있는 `init()` 이 되는게 아닐까??
        * 만약 이게 맞다면, a.foo부분을 verification할때의 onVisit(getExpr&)에서는 `visitInfo.parent.cast\<runExpr\>()` 을 하면
        * runExpr을 통해서 parameter 정보를 얻어올 수 있는게 아닐까?
        * 그렇게 되면 우리는 타입추론을 제공하는 방향으로 구현이 된다.
    * 정말 getExpr::visitInfo.parent가 runExpr이 될것인지 코드를 더 작성해볼까? ==> **안된다.**
        ```go
        init(Obj(boo(5).foo).foo.getName())
        ```
        * 위의 경우 명시적으로 접근해야 한다.
        ```go
        init(Obj(boo(5).foo(age int).getName())
        ```
* * *
# [o] ADT에 대한 with의 정합성을 탐지할때 생성자 안에 if가 사용된 경우도 고려해야 한다.  ==> **각 expr에게 ADT assign 여부를 질의한다. 분기expr은 양 blockExpr에 공통부분만 답한다.**
```go
def A
def B
    with A
def myObj
    with a A // ctor에서 채워야 한다.
    ctor(@B)
        if foo(3)
            a = B
        // else라면 a 에는 비어있다는 얘기가 된다.
        // 혹은,
        foo(3)
            on true: boo(a = B) // 이것도 탐지가 되어야 하고,
            // 역시 true가 아니면 a는 비어있다는 얘기가 된다.
```
* non null 타입 ADT도 with를 지원한다는 것은 이걸 탐지할 수 있어야 한다는 얘기다.
* 코틀린의 경우 어느정도는 지원하지만, 조금만 복잡하게 만들어버리면 정신을 못차린다.
```kotlin
class Mini {
    var age: Int = 0
    constructor(a: Int) {
        age = a
    }
}
class A {
    var mini: Mini
    var mini2: Mini
    constructor(m: Mini) {
        if (m.age < 0)
           mini = m
       else
           mini2 = m

       if (m.age < 0) { // 조건식이 위와 동일하기 때문에 사실상, 어떠한 경우에도 mini와 mini2는 항상 값을 가지게 된다.
           mini2 = m
        else
           mini = m
    }
}
// 하지만 결과는 컴파일에러다. mini와 mini2의 초기식을 넣어달라는 얘기가 나온다.
// 그럼 `아 이 기능은 애초에 지원 안하나보다. 무조건 초기식을 넣어줘야 하는 구나?` 싶겠지만, 처음 if 블록문 안에
    constructor(m: Mini) {
        if (m.age < 0) {
           mini = m
           mini2 = m
       } else {
           mini = m
           mini2 = m
        }
// 처럼 하면 잘 된다.
```

* 조금만 생성자의 로직을 복잡하게 짜면, 이 문제가 꽤 어렵다는 게 이해된다.
```go
def A
    mini Mini // Mini는 incomplete이다. 생성자에서 채워야겠지.
    mini2 Mini
    ctor()
        if n % 2 < 2 // 사실은, 항상 true가 되는 조건식이다.
            mini = Mini(1)
            mini2 = Mini(2)
        // 하지만 컴파일러는 경우의 수까지는 모르기 때문에
        // 여기서 `어! else에는 mini, mini2 참조를 채우지 않고 있네! 에러야!` 고 할 것이다.

        // 혹은

        if 조건1
            mini = Mini(1)

        if 조건2
            mini2 = Mini(2)

        if 조건3
            mini2 = Mini(3)
        else
            mini = Mini(4)
```
* 크게 2가지다.
    1. if 의 경우의 수를 알기 어렵다는 것.
    2. if가 3, 4개 존재하게 되면 각각 true/false냐에 따라서 초기화되는 prop과 아닌 prop이 있을텐데, 어떠한 경로를 탔을때만 에러인지를 찾아내지 못한다는 것.
1. [d] if의 경우의 수를 파악하는 방향은 말이 안된다.
    * 즉, `if 조건절이 항상 true가 되는가 아닌가` 를 판단하거나,
    * 먼저나온 if에서 when으로 1, 3, 5을, 뒤에 나온 if에서 when으로 2,4,6을 커버했다면 사실 모든 것을 커버한 것이니 이걸 계산한다든가
    * 이렇게는 하면 안될 것이다. 그건 너무 갔다.
2. [d] 알것 같으면 통과 모르겠으면 에러?
3. [u] 분기가 보이면 공통만 뽑는다? ==> **가능하다**
    * 아, 코틀린은 이렇게 돌아가는 거다. 자세히 말을 안해줘서 우리가 모를 뿐.
    * 그러니까 if가 있으면 if의 조건식은 판별하지 않는다. 설사 if (false) 라고 했더라도 then블록이 실행될 가능성을 항상 고려한다.
    * then블록과 else블록 안에서 각각 어떠한 prop에 assign을 했는지를 체크한 후, 공통부분만 반환한다. 누구에게? 이 if문에서 *너의 공통부분이 뭐니* 라고 물은 verifier에게.
    * 다시 정리해보겠다.
        * verifier는 생성자에 있는 구문들에 대해서 **너는 어떤어떤 ADT assign을 하였니?** 하고 물어볼 수 있다.
        * blockExpr이 아닌 구문이라면 **엥? 내가 assignExpr인가?** 만 따져서 반환하면 된다.
        * 분기가 아닌 일반적인 blockExpr이라면, 자기가 소유한 구문들에 대해서 다시 반복적으로 **너는 어떤어떤 ADT assign을 하였니?** 라고 물으면 된다.
        * 분기인 blockExpr이라면, **양쪽 분기를 담당하는 blockExpr에 각각 물어본 뒤, 두 blockExpr에서 대답한 assign항목중 공통 부분만 뽑아내면** 된다.
        * return문에 대한 예외처리도 해야 한다. blockExpr은 위에서부터 아래쪽으로 가다가 return문으로 평가되는 stmt를 발견하면 그 밑으로는 다 skip한다.
            * 알고리즘 초안은 이렇다.
                * 핵심
                    * 분기문의 블록중 return이 보이면, 해당 시점까지의 ADT assign이 얼마나 되었는지를 체크한다.
                        * 다 되어 있다면, 이 블록문은 처음부터 없었던 것처럼 취급한다.
                        * assign이 안된 prop이 있다면 부족한 애들을 목록을 `얘네들은 앞으로도 assign 절대 안됨` 으로 위로 올리고, 이 블록문을 없었던 것으로 취급한다.
                    * return이 없으면
                        * 양쪽 블록문 중 공통부분만 추려서 `assign 되었음` 하고 올린다.
                        * 즉 2개의 블록문 중 한쪽에만 return이 있으면 분기문이 아닌 것처럼 판단하고 전부다 평가해버리면 된다.
                    * 이렇게 `절대로 에러인 목록` 과 `assign이 완료되었음` 목록 2개를 가지고 생성자 검증을 한다.
                    * 생성자 내부 구문 파악이 모두 끝나면 정산을 한다.
                        * 전체 assign할 목록에서 `assign이 완료되었음` 목록을 뺀 나머지가 에러 목록이다.
                        * 이 중에서 `절대로 에러인 목록` 과 합집합을 구해서 이걸 에러로 반환한다. (중복은 제거)
                * 각 함수별로 쪼개서 다시 서술하면, 대충 이런 모양이 된다.
                    ```cpp
                    class checker : visitor {
                        nchain _candidates; // 전체 assign 해야할 목록
                        map<string, str> _errs; // 확실한 에러로 판명남.
                        struct partialCheck { // 각 blockExpr 당 체크한 목록
                            tstr<nchain> done; // assign이 완료됨.
                            bool hasRet; // ret/return이 있었음
                            partialCheck(nchain& newDone, nbool newHasRet): done(newDone), hasRet(newHasRet) {}
                            partialCheck(PartialCheck& parent) {
                                done.link(parent.done);
                                errs.link(parent.errs);
                            }
                            partialCheck(): hasRet(false) {}

                            partialCheck operator+(const partialCheck& rhs) const {
                                partialCheck ret;
                                ret.hasRet = hasRet && rhs.hasRet;
                                errs += rhs.errs;
                                done = done.교집합(rhs.done);
                            }
                        }

                        me& setFunc(func& f) {
                            _func.bind(f);
                        }
                        void start() override {
                            _func->accept(...);
                        }

                        map<blockExpr*, partialCheck> _partials; // 각 blockExpr별로 assign
                        vector<blockExpr*> _blockStack;
                    };
                    partialCheck& checker::getPartial(blockExpr& b) {
                        static partialCheck _stub(_candidates, false);
                        if(_partials.has(&b))
                            return _partials[&b];
                        return _stub;
                    }
                    partialCheck& checker::getPartial() {
                        return getPartial(_blockStack->front());
                    }
                    int checker::onVisit(assignExpr& a) {
                        getPartial().done[a.getName()].bind(a.getEval());
                    }
                    int checker::onVisit(retExpr& r) {
                        partialCheck& partial = getPartial();
                        partial.hasRet = true;
                        return DONT_VISIT_FURTHER; // 이제 traverse가 더 되지 않음.
                    }
                    int checker::onTraverse(blockExpr& b) {
                        // 대부분 super와 동일.
                        int n = 0;
                        narr& stmts = b.getStmts();
                        int len = stmts.len();
                        for(auto& stmt : stmts) {
                            int res = stmt.accept(visitInfo {"", &b, n++, len, i.depth+1}, *this);
                            if(res == DONT_VISIT_FURTHER)
                                return DONT_VISIT_FURTHER; // 혹은 이 코드를 visitor에 박아놓던가.
                        }
                    }
                    int checker::onVisit(blockExpr& b) {
                        blockExpr& parent = _blockStack.front();
                        _blockStack.push_back(&b);
                        _partials[&b] = partialCheck(_partials[parent]);
                    }
                    int checker::onLeave(blockExpr& b) {
                        _blockStack.pop();
                        partialCheck& partial = getPartial();
                        if(partial.hasRet || &b == &_func.getBlock()) {
                            auto rest = // _candidates - partial.done 해서 남는게 있는가?
                            _errs.add(rest);
                            partial.done.rel();
                        }
                        _partials.remove(partial);
                        return 0;
                    }
                    int checker::onVisit(ifExpr& i) {
                        auto& thenBlock = getPartial(i.thenBlock);
                        auto& elseBlock = getPartial(i.elseBlock);
                        getPartial().done.add(thenBlock.done.교집합(elseBlock.done));
                    }
                    ```
                        *
    * 분명히 가능한 로직이라고 본다. 다만 간결하게 쉽게 잘짜기란 조금 어렵다.
    * 또, 이 로직은 verifier에서만 사용하기 때문에 node같은 runtime에도 사용하는 부분에는 API를 두지 않는게 좋을 것이다.
1. 항상 if, when 밖에서, 즉 생성자 함수의 바로 direct sub에서 초기화하도록 하는 것이다.
    * 이건 비교적 가능성이 있다.
    * 그리고 사용자의 코드가 살짝 더러워지긴 하겠지만, 불가능한건 아니다.
    ```go
    def A
        mini Mini
        mini2 Mini
        ctor()
            mini := if n % 2 < 2
                Mini(1)
            else
                Mini(2)
            // 라던가
            newMini Mini?
            if n % 2 < 2
                newMini = Mini(3)
            else
                newMini = Mini(4)
            mini2 = newMini
            // 처럼 하는 것이다.
    ```
* * *
# [o] 인자 뒤에 `?` 만 붙이면, 해당인자가 null이 아닐때 해당라인이 실행되게 한다.
* safe-navigation은 여러모로 편한데, 불편한 경우가 간혹 있다.
* 그것은 nullable 객체의 메소드를 호출할때가 아니라 nullable을 인자에 넣어야 하는 경우. 예를 들어보자
```go
a.b.c?.foo()?.doo() // 이럴때는 편하다. 그런데,

getAOrNull()?.let {
	foo(a) // 인자로 null이 아닌 걸 넣을 때는 좀 불편하다. 특히, 인자가 2개 이상이라면..
	doSomething(a)
},
```
* 이걸 해결하기 위해서 뒤에 ?를 붙이는 문법을 지원하고자 한다. 그러면 이렇게 사용할 수 있다.
```go
foo(getAOrNull()?, getB()?) // 2개 중 하나라도 null인 경우 실행하지 않는다.
```
* 구현 알고리즘
    * class safeNullNode : public baseObj {}
    * 를 만든다.
    * mgdFunc::\_evalArgs()에서 p.getOrigin().as\<node\>()의 결과가 safeNullNode면 mgdFunc::run()을 그냥 로그 없이 tstr(safeNullNode::singleton) 만 넣어서 종료한다.
* * *
# [o] null체크는 어떻게 하는가? => **nullable인 경우 if (a) 처럼 할 수 없다. null체크 한답시고 if (a)도 안된다.**

* 쉽게 생각하면 C++처럼 생각하기 쉽다.
```go
a := getAOrNull()
if a
	print("a is null!")
```
* [x] 그런데 a가 bool? 이라면 어떻게 되는 거지?
    * 코틀린은 에러가 발생한다. if (a) 처럼 쓰지 말고, if (a == false) 처럼 쓰라고 한다.
    * [x] 다른 언어는? => **Swift도 마찬가지다. 따라가야 겠지.**

> 정리:
>     null체크를 하려면 if a == null 처럼 해야지, c++처럼 `if a` 식으로 할 수는 없다.
>     bool? 타입일 경우 if a 처럼해버리면 에러다. if a == true 처럼 해야 한다.
* * *
# [o] on을 switch, try-catch 양쪽에 모두 사용되도록 쓸 수 있나? => **예**

* on으로 빠져버리면 원래의 context로 복구가 안되어야 한다. 예를 보자.
```kotlin
try {
	val visible = getView(someId).visibility
	visible = false
} catch (e: NameNotFoundException) {
	return false
}
```

* try 블록이 있기 때문에 try 안에서 만든 변수는 밖에다 영향을 끼치지 못한다. 이걸 자연스럽게 이해가 된다.
* 그런데 `on` 방식은 사실상 블록을 없앤 거기 때문에 이 부분에서 괴리가 오게 된다.
* [x] 어떻게 하면 자연스럽게 사용자가 `아 on 에서 만든 변수는 밖에다가 영향을 미치지 못하는 구나` 하고 인식하게 할 수 있을까?
	* 내가 하고자 하는 것은 `on`을 패턴매칭이라는 기능으로 만들어 버리는 것이다.
		* 이 패턴 매칭을 exception에서 사용하든, switch로 사용하든 둘다 사용이 가능하도록.
        * [x] 새로 변경된 `on` 에 대해서 요약하면,
            1. 블록문에는 on을 사용하지 못한다.
            2. on은 trigger statement와 다른 scope에 속한다.
            3. `$`가 사용되지 않을 경우, trigger statement의 최종값을 사용한다.
            4. 최종값을 사용한 경우는 trigger statement가 전부 실행되고 나서 해당 on이 평가된다.
            5. 정의문에는 on은 사용될 수 없지만, def assignment 예외적으로 trigger statement로 사용 된다.
            6. def assignment의 경우 rhs 부분이 trigger statement가 된다.
	```go
	a := status // defAssignment의 경우 rhs 부분이 trigger가 된다.
		on CREATED, PROGRESS // $가 없으므로 status의 최종평가값이 == CREATED냐는 패턴매칭이 된다.
			doSomething() // doSomething()의 반환값이 status에 평가값이 된다.
			// fallthrough가 되진 않는다.
		on DONE: ....
		else
			....
		// [?] finally가 필요한가?
	doFinal() // 여기도 실행이 되야 하는 거겠지.

	visible := getView(someId).updateVisibility()		​
    	is NameNotFoundException // 별다른 타입 명시가 없어도 모든 타입은 에러타입에 대한 합타입이다.
			// 블록문 처럼 되어있지만 on의 블록문은 외부와 구분되지 않는다.
			// 즉. visible이 존재하는 블록에서 이 구문을 실행하는 것과 같다.
			ret
	visible = false
	```
* 변수의 정의를 expression으로 한다는 게 이렇게나 문제를 낳다니.
* * *
# [x] 여러개의 메시지를 처리하는 함수를 만들면 무슨 이득이 있을까? => **큰 이득이 없다**
* 객체는 이미 여러개의 메시지를 처리한다. 생성자 오버로딩을 통해서.
* [d] 그렇다면 함수 오버로딩 또한 `메시지를 여러개 처리하는 composition메소드를 만드는 것`라고 볼 수 있을까?
    * 다시말하면, 예전에는 객체 안에 함수가 담기는데, 일반 함수도 있고, 오버로딩 된 함수들도 있었다.
    * 오버로딩된 함수들은 객체 바로 밑에 있을 뿐이지, 얘네들을 묶어서 하나로 관리하고 이러한 구조가 아니었다.
    * 이것들을 하나로 묶는 방향으로 접근했을때 과연 문법적/개념적 인 혁신이 일어날 수 있는가?
        * 문법적으로만 본다면
            * 오버로딩된 함수들끼리의 공통점은 함수명 뿐이다.
            * 그러니 줄일 수 있는 부분도 함수명 뿐이다.
            * 문법적으로는 큰 이득은 없다.
        * 개념적으로 본다면
            * 메시지를 하부 원소에 redirect 해주는 거라고 볼 수 있다.
            * 이거는 사실상 composition을 생각할때 나왔던 아이디어다.
            * 현재로써는 도입이 어렵다.
* * *
# [o] 완전객체는 자동으로 만들어진다? 이걸로 static을 대체할 수 있을까? ==> **with로 해결한다.**
* 프로토타이핑을 좀 더 적극적으로 적용해보자.
* 클래스의 불완전성을 더 없애보려고 노력하자.
```go
def a // a는 완전객체다.
    doSomething() void: print("wow")
def B // b는 불완전객체다.
    @ctor(age int)
        ......
    doSomething() void: ....

def c // c는 완전객체다.
    @ctor()
        ......
    doSomething() void: ....

a.doSomething() // ok
a1 := a() // a에서 복제되는 것이 아니라, 원본a로부터 복제가 된다.
a2 := a(a) // 이제 a로부터 복제가 된다.
B.doSomething() // err
B(22).doSomething() // ok
```
* 왜 이걸 사용해야 하는가?
* [u] 이걸로 static method, static variable을 대체할 수 있는 방법은 안될까?
    * 간단히 생각해보면 2가지가 떠오른다.
        1. [u] def 안에 def 를 만들고, 그 def를 바깥쪽 def에서 바로 사용할 수 있는, redirection을 한줄만에 끝내버리는 뭔가 키워드를 제공한다. ==> **with 키워드가 이 역할을 한다.**
            * 그리고 이거는 composition에도 응용 가능?
            * 예전에 composition 생각하면서 다뤘던 주제다. `2개 이상을 redirection을 하는 상황에서 겹치는 함수가 있거나, 메소드명만 겹치면 어떻게 되는가` 를 처리할 수 있어야 한다.
            * 자세한 내용은 그 쪽 참초
        1. 하나의 def 안에 불완전객체일때 사용하지 못하는 변수가 무엇인지를 지정하도록 한다.
            * 즉 kotlin의 lazy 같은 문법이 될 것이다.
            * [ ] 문제는 컴파일타임에 이 사실을 알 수 있도록 해야만 한다.
                * lazy처럼 런타임 에서야 알 수 있는 에러가 된다면, 너무 사용성이 안 좋다.
* * *
# [x] 변수 정의와 함수 정의하는 문법을 하나로 통일이 가능한가? ==> **메리트도 크게 없고, 지금와서 바꾸면 너무많은 문법에 영향을 준다.**
* [?] 만약에 통일을 해냈다고 하자. 그러면 def도 바꿔야 하는게 아닌가?
* * *
# [o] for문은 배열을 반환하도록 해달라? ==> **OK**
* blockExpr::getExpr()은 return stmt[len-1].getEval() 으로 되어있는데, 이거 고쳐야 한다.
* forExpr::getEval() { return new arr(\_block.getEval()); }
* * *
# [o] static 을 없애는 방법 ==> **with로 없앴다**
### 함수내 변수의 경우
* [ ] def 를 사용한다면? => **def는 싱글톤이기 때문에, 괜찮아보이는데?**
```go
foo() void
    def val 5 // 초기값이 5인 셈
    print("val=${++val}")
```
### staitc 메소드의 경우는?
* [d] 1안: 그냥 origin 완전 객체를 이용하도록 하면 되는 거 아닌가?
    * 안된다.
    * 왜냐하면 어떠한 static은 제공하지만 불완전객체로 하고 싶은 경우가 생기기 때문이다.
* * *
# [o] 정의는 Expression이 아니다? => **네. 아니다.**
* 변수의 정의를 expression으로 했을때의 demerit가 너무 많긴 하다.
    * 정말로 온갖 문법에서 에러가 발생한다.
    * 게다가 변수의 정의가 함수 인자 깊숙이 나올 수 있으므로 한눈에 파악이 어려운 곳이 많다.
* 정의는 origin객체의 정의든 여러가지 있으므로 `이것들도 포함해서 모두 expression이 아니다..` 라고 해야만 할 것이다.
* 그리고 다른 expression 기반 언어를 보더라도 변수의 정의까지 expression으로 한 경우는 드물다.
* if 문에서는 약간의 이득을 볼 수 있는 경우가 있었다. 예를 들면,
	```go
	view := getView(someId)
	if view.visible != false
		doSomething(view)
	// 이걸 한번에 쓰고 싶은 충동이 가끔 생긴다.
	// 그래서...
	if (view := getView(someId)).visible != false
		doSomething(view)
	// 그런데 보다시피 문법이 더럽다.

    // 물론 비교적 깨끗한 경우도 있다.
    when(a := getFoo())
        is Foo: ....
        is Boo: ....
    a.doSomething()
	```
	* 물론 보기에 더럽다. 그러니 지원하지 않는 것도 괜찮은 생각이 들었던 거다.
	* [x] 지원하지 않는다고 쳐도, 이 코드를 더 간단하게 줄이는 게 가능하다.
	```go
	if getViewBigFunctionOhYeah(someId).visible != false
		doSomething($getViewBigFunctionOhYeah) // 암시적 중간 변수 정의로 간략하게 사용이 가능해졌다.

    // 2번째 케이스의 경우에는 pattern matching 문법을 조금 바꾸면 가능해진다.
    a := getFoo()
        when is Foo: ...
        when is Boo: ...
    a.doSomething()
	```
### 정의를 expr로 해주는 다른 언어들은 뭐가 있을까?
* kotlin
    * assignment는 expr 아님
    * 그런데 when 안에서는 변수 정의를 할 수 있다. if안에서는 안된다. *이거 뭐야. 에휴 역시 일관성 없는 코틀린*
    ```kotlin
    when (val f = foo()) {
        ....
    }
    ```
* Expression based 라고 자칭하는 Rust는 역시 변수 정의는 지원하지 않음.
* [*] 굳이 지원할 필요를 모르겠다.
* * *
# [o] 변수명에 대문자 스네이크를 쓰면 상수로 취급한다? ==> **그렇게 하자**
* 이 것 역시 `스타일을 attribute로 사용한다`는 아이디어에서 온 것이다.
* 예제를 짜보자.
* * *
# [o] overloading 구현Task ==> **어떻게든 구현이 가능은 하다는 건 알았다.**
* why?
    * orgObj는 scope --> scope는 tnmap -> tnmap은 multimap 사용한다.
    * multimap이므로 중복해서 name을 담을 수는 있다.
* 구현은 문제없을테고. overloading을 구현할때 아래의 내용들을 잘 잊지말고 구현하도록 하자.
* [ ] 체크리스트1: node.subAll(string& name)이 효율이 떨어진다.
    * 자주 사용하는 건데, name일때는 multimap의 전용함수를 쓰면 더 빠르거든.
* [ ] 체크리스트2: sub duplication verification할때 `무조건 2개 이상의 같은 key가 있는가`로 하고 있다. 이러면 안된다. msg를 던지고, 해당 msg를 처리할 수 있는 무엇인가 2개인가를 봐야한다.
* * *
# [o] 람다는 함수호출 안에서만 만들 수 있다? 문제는 없나? 문법은 어떤가? ==> **네 함수호출에서만. 문법은 나왔는데, 구현과 bison 코드는 아직 모르겠다. 나중에 잘 구현해보자.**
* 현재 람다 문법은 어떻게 생겼지?
```go
def a
    lambA(n int) flt
    foo(value flt, l lambA) flt
        l(value)
main() void
    // 방법1: 중첩함수 사용
    l(n int) flt
        n * 2.5
    a.foo(3.5, l)
    // 방법2: 람다 사용
    a.foo(3.5, (n): n * 2.5)
    a.foo(3.5, (n, n2): n * 2.5)
    a.foo(3.5, (): 2.5)
    //     혹은
    a.foo(3.5, (n, n2)
        doSomething()
        ret n * n2
    )
    list.map(3.5, (n, n2)
        res := n * n2
        ret res
    , doSomething())
```

1. [u] 위의 방안을 유지한다.
    * 일관성이 있다는 건 알겠다.
    * 소괄호(즉 tuple) + indent는 함수라는 것이다.
    * 파싱 난이도가 올라가는 것은 사실이다.
    * 한줄짜리 람다를 `:` 등으로 정의 할 수있는 방법을 꼭 제시해야 한다.
    * 위의 예제에서 본다면 `foo((n): 2.5)` 라고 했을때 `:`의 끝은 `)` 앞 까지라는 걸 알게끔하는게 좀 어려워 보인다.
1. `->` 를 사용한다.
    ```go
    main() void
        a.foo(3.5, (n) -> n * 2.5) // 한줄로 붙여쓸때가 있다는 것이다.
        a.foo(3.5, (n, n2) ->
              ret n * 2.5
        )
        a.foo(3.5, (n, n2) ->
              doSomething()
              ret n * n2
        )
        list.map(3.5, (n, n2) ->
            res := n * n2
            ret res
        , doSomething())
    ```
    * 이렇게 해도 1번처럼 소괄호는 결국 들어가야 한다. 인자가 2개면 소괄호가 없어져버리면 어디까지가 람다의 인자인지 알 방법이 없다.
        ```go
        a.foo(3.5, n -> n * 2.5) // 얼핏보면 소괄호 없어도 되겠다 싶겠지만.
        a.foo(3.5, n, n2 -> 2.5) // 봐라. n이 foo의 인자인지 람다의 인자인지 애매하지.
        ```
    * 파싱난이도는 더 낮다. `->` 보면 람다라고 인식하면 되기 때문이다.
2. [d] 코틀린처럼 `{}`를 쓴다.
    ```go
    a.foo(3.5, {n -> n * 2.5})
    a.foo(3.5, {n, n2 -> n * 2.5})
    a.foo(3.5, {n, n2 ->
        doSomething()
        ret n * n2
    })
    list.map(3.5, {n, n2 ->
        res := n * n2
        ret res
    }, doSomething())
    ```
    * 결국 소괄호대신 중괄호가 앞뒤로 들어가는 것 뿐이다.
    * 뒤에 붙은 닫는 중괄호가, 코드를 더 보기 어렵게 만든다.
3. [?] go, python 방식
    ```go
    a.foo(3.5, lambda n, n2: n * n2)
    a.foo(3.5, lambda n, n2:
          doSomething()
          ret n * n2
    )
    list.map(3.5, lambda n, n2: res := n * n2; res ret, doSomething())
    list.map(3.5, lambda n, n2:
            res := n * n2
            ret res
    , doSomething())
    ```
    * 앞에 `lambda` 키워드를 넣어서, 뒤에 나올 `,`가 어느 함수에 속한 것인지를 분명히 해주는 것이다.
    * lambda 를 보고 람다 부분을 쉽게 독해할 수 있지만 함수의 일관성이 없고, 타이핑이 늘어난다.
* C#, dart도 살펴봤는데 크게 차이는 없다.
* 위의 예제들도 사실 서로간에 크게 차이가 없다.
* 그러면 최대한 일관성이 있는 문법으로 선택하자.
* * *
# [x] 함수의 반환형은 inference 하게 해달라. ==> **싫다. 대신 `void` 로 반환형이 고정되도록 한다. 왜냐하면 이걸 해주면 expand시 종속성을 풀어내는 난이도가 급상승한다. 물론 구현도 어렵지만.**
* [d] 가장 큰 문제는 함수 호출과 구분이 더더욱 힘들어진다는 것이다. ==> **이미 파싱 잘 하고 있었다.**
* 언제 inference 하는가?
1. [?] preEval에서 하자
    * 다른 컴파일에 영향을 주는 거(주로, orgObj와 그 sub들)라면 preEval에서 하는게 맞다.
    * verification에서 하자는 의견도 있겠지만, 만약 함수 안에서 중첩함수A를 사용하는 코드는 위에 나오고, 정작 A의 정의는 코드 맨 밑에 따로 나온다고 생각해보자.
    * [x] 이때 에러가 있어야 하는가? ==> **어. 에러다**
        * 어. 에러다. 위에서 아래로 훓어야 한다.
        * 왜냐하면 지역변수 capture 문제가 있거든.
        * 지역변수는 해당 라인가기전까지 생성되지 않는다. 내 언어는 C처럼 미리 쓸 변수들을 함수 맨 위쪽에 몰아넣어야 하는 언어가 아니다.
        * 그때 그때 변수정의 구문을 만날때마다 생겨야 한다.
2. [d] 함수내에서 정의된 객체/함수(즉 중첩객체/중첩함수)는 verification에서 수행한다. ==> **즉, eval을 시켜주는 애가 하나 있는거고, 이걸 verifier와 expander가 함께 사용하는 식이다.**
* orgObj에 달려있는 sub들에 대한 종속성은 expand 단계에서 무한루프를 돌면서 풀어낸다.
* 함수의 반환형이 없다면, 그 함수의 모든 코드를 전수조사할 수 밖에 없다. 왜냐하면,
    * 기본적으로 `returnExpr` 은 싹 다 뒤져봐야 한다.
    * 문제는 `returnExpr` 에 rhs로 blockExpr이 온경우, 이 blockExpr의 evalType을 알아내기 위해서 이 blockExpr도 싹 다 뒤져봐야 한다.
    * blockExpr의 마지막 line도 뒤져봐야 한다.
    * 이렇게 뒤져본 expr들을 모두 모아모아서 하나의 타입으로 merge 시켜야 한다.
    * 그런데 이 expr중에서 다른, 아직 verification 되지 않은 타입을 참조하는 코드가 있다면???
* 따라서 종속성 풀기가 실패할 확률이 매우 높아진다.
* 그리고 반환타입을 적지 않으므로 라인이 긴 함수라면 사용자가 보기에 직관적으로 어떤 반환형이라는 사실을 알아내기가 어렵다.
* 그리고 다수의 언어들은 이걸 지원하지 않는다.
* 그래서 함수의 반환형을 적지 않으면 `void` 로 자동입력되는 걸로 변경한다.
> 요약:
>     eval 즉 타입추론만 담당하는 전용 클래스가 따로 있다.
>     expander와 verifier는 얘를 통해서 타입추론을 수행한다.
>     이 타입추론 클래스가 func을 타입추론 할때는 return문을 잘 케어 해야한다.
>         함수 어딘가 구석에 return 하나 있을지라도, 이것에 따라서 결과가 달라지게 된다.
* * *
# [x] 가능하면 변수명을 지을때 \` 도 가능하게 하자? ==> **하지말자. 그럼, 다른 기호도 해야지 일관성이 있을 것이다.**
* `다시` 라는 뜻이 있으니까.
* * *
# [o] blockExpr을 가진 (함수, on, for 등)의 타입추론 알고리즘 ==> **blockExpr::getEval()이 재귀적으로 처리한다.**
* 다음 코드를 보고 어떻게 구현할까?
    ```go
    get(val int) // Type이 없다. Inference 해야 한다. A가 나와야 겠지?
        val
            on 1: return A()
            else: return B(0)
    ```
* 개념적으로는 비교적 명확하다.
* 어떠한 Type으로 Inference되어야 할까?
1. [u] blkExpr evalType을 들게끔 한다.
    * 기존코드에서는 blkExpr.getEval()하면 무조건 마지막 stmt의 getEval()로 redirection 할 뿐이었다.
    * 그런데 이래서는 중간에 return하는 것들을 알지 못한다.
    * verifier는 어짜피 함수 하나를 위에서부터 아래로 뒤지기 때문에
    * 그걸 이제부터는, val을 switchExpr로 정의하고 switchExpr을 기존에 있던 expr을 재사용해서 구성하면 된다.
    * 예를들어,
        ```cpp
            switchExpr* loweventer::onSwitchExpr(expr& value, vector<onExpr>& ons) {
                // onExpr은 condition절 1개와 blockExpr를 가지고 있는 것에 불과하다.
                return new switchExpr(value, ons);
            }
            void verifier::onLeave(switchExpr& s) {
                // onLeave라는 점이 중요하다. 이게 최적화가 된다.
                // blockExpr::getEval()은, blockExpr 안의 stmt 안에 어딘가 구석에 있는 return문에 의해서 크게 영향 받는다.
                // 그래서 blockExpr::getEval()은 blockExpr안의 stmt를 모두 한번은 verifier가 지나가고 나서 평가하는게 좋다.
                // 그러나 항상 이렇게 verifier를 타입추론이 동작하는 것은 아니다. 그러니 다음처럼 알고리즘을 작성한다.
                //     1. blockExpr은 기본적으로 _eval은 null이다.
                //     2. blockExpr.getEval()을 했을 때, _eval이 null인 경우, blockExpr은 자신의 stmt들에게 getEval()을 재귀적으로 물어본다.
                //     3. blockExpr::getEval()에서 자신의 stmt들에게 getEval()을 한 결과를 받고나서, 해당 stmt가 returnExpr이었을 경우,
                //        자신의 _eval과 해당 stmt의 getEval() 결과값과 join해서 좀 더 일반적인 타입(node)로 자신의 _eval을 갱신한다.
                //     4. stmt가 마지막 stmt일 경우, 이것이 returnExpr인지 상관없이 자신의 _eval과 join한다.
                //     5. 이제 이 blockExpr에게 getEval()을 또 물어보게 되면, 이제부터는 _eval이 그냥 나갈 것이다.
                //     6. mgdFunc또한 별도로 _retType가지고 있는 게 아니라 blockExpr의 eval을 redirection해서 사용한다.
                // 이처럼 재귀적인 동작은 blockExpr::getEval()에서 다 처리한다.
                // 근데 blockExpr과 관련된 애들은 왜 onLeave() 에서 검증해야 최적화가 된다고 하는가?
                //     onVisit()은 onTraverse()보다 빠르다.
                //     그러니 onVisit(blockExpr&) 에서 getEval()을 해버리면, getEval() 안에서 일단 모든 구문을 deep 하게 한번 탐색한다.
                //     그리고 getEval()이 끝난 뒤에 visitor에 의해서 다시 한번 더 deep search로 탐색하게 되므로 2번 탐색하게 되는것이다.
                //     그러나 onLeave(blockExpr&) 등에서 getEval()을 해버린다면 _eval 값을 그대로 전달만 하면 되므로 더 편하다.
                str evalType;
                for(onExpr& e : s.getOns()) {
                    e.getEval(); // e.blockExpr.getEval()을 호출한다.
                                 // blockExpr::getEval()은
                }
            }
        ```
    * 이렇게 해버리면 **타입추론은 verifier에서도 되야하고 expand에서도 되야한다**라는 요구사항도 만족하게 된다.
        * blockExpr을 가진 타입추론은 blockExpr자신이 처리하는 것이다. 그러니 expander도, veriifer도 쉽게 blockExpr보고 타입추론을 하라고 다룰 수 있다.
        * 물론 모든 타입추론이 하나의 클래스, 하나의 로직으로 다 처리되는 것은 불가능하다.
            * 정확히는가능할 수 있겠지만, 퍼포먼스가 매우 비효율적이라서 안하는 거다.
        * 이렇게 각개격파하듯이 case by case로 처리하고자 한다.
2. [d] 그냥 기존대로 verifier가 알아서 잘 판단하도록 한다. 그 알고리즘은?
* * *
# [o] exception은 모든 타입에 들어있는가? 아니면 `?` 로 지정해야 하는가? ==> **`?`로 표현한다. 모든 종류의 exception이 들어간다. 특정 exception을 합타입으로 갖게끔 할 수는 없다.**
* 다음 코드로 무슨 문제인지 설명해보겠다.
```go
getView(someId int) ?? // 이것은 무슨 타입일까?
    if someId < 0: throw NoViewFoundException // return이 되면 안된다? parser와 verifier는 이게 에러인지 아닌지 모르잖아.
    return views[someId]
```
1. [d] View이며, Exception은 모든 타입에 합타입으로 되어있는 상태다?
    * 이경우 View타입이라고 어디선가 객체를 받아왔어도, 그것은 사실 Exception일 가능성이 있다.
    * Exception이 들어있는 상태에서 해당 객체를 사용한 경우 crash 같은 게 발생될 것이다.
2. [d] View이며 Exception은 바로바로 외부에서 처리를 해야만 한다. 합타입은 아니다?
    * 이 경우, 일반적인 OOP와 비슷한 컨셉을 따르는 것이다.
    * exception을 사용한 함수를 외부에서 호출하는 경우, 반드시 on을 사용해야만 한다.
    ```go
    foo(getView(id), getView(id2).doSomething())
        on NoViewFoundException: ....
    view := open(boo(getView(id3).getUpdatePriority()))
        on NoViewFoundException: return
        on NoFileExist: return
        on Exception: return
    view.koo()
    ```
 3. [u] `?` 는 에러에 대한 합타입임을 표현하는 것이다? ==> **고민을 해보고 다른 언어도 봐봤는데, 일단 이걸로 해보자.**
     * 이 경우 에러에 대한 지연처리를 할 수 있다.
    ```go
    view := open(boo(getView(id3)))
        on nullErr: return // null일때는 이 함수를 벗어나므로 view는 null이외의 에러타입에 대한 합타입이다.
        on err: panic "wow" // 나머지 에러가 발생한 경우는 프로그램이 죽어버리기 때문에
                            // 이 view는 err 타입이 들어갈 가능성이 0다.
                            // 그러므로 이 타입은 open() 의 반환형이다.
    view.koo() // err일 가능성이 없으므로 ?. 로 쓰지 않는다.

    view2 := open(getView(id4))
    view2?.koo() // view2가 err가 아니여야 koo()가 호출된다. err이면 아무런 일도 발생하지 않는다.
    ```
    * [x] null에 대해서 ?.를 지원하는 것은 흔히 있는 일이다. 하지만 모든 에러에 대해서 ?.를 지원하는 것은 없었다.
          무슨 문제가 없는가?
         * 쉽게 떠오르는 문제는 에러를 무시하는 범위가 커진다는 것이다. 바로 exception을 처리하지 않고, 코드를 떠돌게 되는 비율이 커진다는 것.
             * 근데 이렇게 했을때 얼마나 큰 문제인지, 사소한 문제인지는 잘 모르겠다.
             * 종래의 OOP언어는 exception은 비교적 빨리 처리하고, null은 익숙하므로 천천히 처리되는 방향으로 개발되어 왔다.
4. [d] Sumtype을 지원해서 exception을 처리하도록 하는게 자연스럽지 않나.
    * 위의 3은 err에 대해서만 sumtype을 지원하겠다는 것이다.
    * 그런데 enum이라는게 있잖아. 어짜피 enum을 만들거잖아. enum을 sumtype 기능으로 하게끔 만들 수도 있긴 하잖아.
    * [?] 첫번째 문제는 사용성이다. ==> **간편한 합타입정의문을 만들면 해결할 수 있을지도 모른다.**
        * int를 반환하는 함수를 만들었다고 해보자.
        * 특정상황에서는 int를 반환할 수 가 없어서 exception/err을 같이 보내기로 한다.
        * 이때 이 함수의 반환형을 작성한다고 해보자.
        * 만약 enum을 통해서만 합타입을 정의할 수 있다고 한다면 이 함수를 위해서 enum을 만들어야 한다는 얘기다.
        * 이게 얼마나 귀찮고 비효율적인지 잘 알겠지.
        * 즉 합타입정의문은 enum을 통해서 이루어지면 안된다.
        * 반대로 가야한다.
        * 합타입정의문이라는 게 존재하고, 이걸 응용하면 enum을 할 수도 있다는 방식으로 가야한다.
    * [x] 두번째 문제는, safe-navigation이다. ==> **응. 문제다. 해결 힘들다.**
        * 합타입을 지원한다는 것은 n타입을 합칠 수 있다는 걸 의미한다.
        * 기존에는 main 타입과 err타입이라는 게 존재했다.
        * 그런데 합타입을 지원해서 이걸 함수의 반환하려고 한다면, main 타입도 sub타입도 존재하지 않게된다.
        * 합타입으로 반환된 에러가 잠재된 결과값에서 main으로 값을 동작할지, 예외처리를 수행할지 여부를 바로 알기는 어렵게 된다.
        * `res.b` 같은 코드가 있다고 해보자. res의 합쳐진 수많은 타입들 중에서 몇번째 타입을 놓고 b에 접근하도록 수행할 것인가?
        * 맨앞?? 이 경우 함수를 작성하는 사람이 맨앞에 주의깊게 타입을 할당해야 하는데, 매우 이상하게 느껴진다.
        * 즉 합타입을 에러로 만들어서 safe-navigation을 하겠다는 아이디어는 잘 융합되지 않는다.
> 요약:
>     익셉션은 `err` 라고 명한다.
>     err은 특수한 객체로, err에서 with를 한 것들은 모두 err이 된다.
>     err을 return 하게 되면 main으로 return한게 아니라 errType으로 return을 한다는 것이 된다.
>     main과 errType을 동시에 return하는 것은 불가능하다.
>     verifier는 returnExpr에서 rhs가 err타입인지를 확인후, errType으로써 return하는지 mainType으로써 return하는지를 파악해서 체크해야한다.
>     따라서 namu는 합타입을 지원하지 않는다.
* * *
# [o] on을 패턴매칭으로 만들자.
* 구체적으로 어떠한 문법을 가져야 하는지는 모르겠지만, 단순히 switch에서 끝나는 게 아니었으면 좋겠다.
* 어떤 문법이 가능해질까?
* [x] 블록문에 대해서는 on을 사용할 수 없다? 그렇게 하면 이상해지는 코드가 있지 않을까? ==> **소괄호를 넣어라**
    ```go
    value := if a == b
        doSomething()
        22
    else
        34
        on .... // 봐바.. 이상하잖아.
    ```
    * 뒤에 소괄호를 넣으면 된다.
    ```go
    (value := if a == b
        doSomething()
        22
    else
        34)
        on ....
    ```
> 요약:
>    1. `on <expr>[, <expr>]* blockExpr` expr은 값이다. expr값과 일치되면 해당 값일때 뒤에 나올 블록문을 수행한다.
>        expr 뒤에 , 를 붙여서 다른 값을 또 넣을 수 있다.
>    1. `is <NAME> blockExpr` 뒤에 타입과 일치하면 blockExpr을 수행한다.
>        앞서 얘기한것 처럼 err을 with하면 모두 err이다.
>        그러니 value에 대해서 딱 1회만 is() 체크를 해주면 된다.
>    2. `in <expr> blockExpr` expr은 container로 eval되어야 한다. container.has(value)를 해서 true가 반환되면 blockExpr을 수행한다.
>        expr 뒤에 , 를 붙여서 다른 값을 또 넣을 수 있다.
>    3. `else blockExpr` 나머지 모든 패턴이 들어맞지 않음면 이게 실행된다.
>    4. 위의 모든 패턴에 대해서 expr이 만족되면 blockExpr을 수행하기 전에 `it` 변수를 smartcast가 된 타입의 값으로 변환해서 stackFrame에 add한 뒤에 blockExpr을 수행한다.
>    5. failthrough를 지원하지 않는다. 겹친다면 중첩함수를 통해서 해결하라.
>    6. 블록문에 대해서는 on을 사용할 수 없다.
* * *
# [x] 함수정의시 사용하는 소괄호는 tuple을 응용해서 만들 수 있다? ==> **없는 언어들도 충분히 많다. 이 이상 복잡한 문법으로 만들지 말자.**
* 만약 된다면, 사용자는 튜플을 갖게 된다.
* [?] 튜플이 얼마나 도움이 될까?
* [?] 튜플이 없는 언어는 없나? 없으면 언어로써 많이 불리한가?
* * *
# [x] pair를 쉽게 만드는 문법 정의해서 errType 반환 하는 문법하고 합친다? ==> **pair는 값2개를 하나로 묶는 문법이다. 반면 `?` 는 합타입을 의미한다. 2개는 완전히 다른 의미다.**
* why?
    * err문법은 errType에 대해서만 2nd value로 보낼 수 있다는 문법이다.
    * err는 `?`로 표현한다.
    * pair 문법은 `A;B` 로 표현한다.
    * 그러면 드는 생각이, pair와 ?를 합치면 좋지 않을까?? 이런 생각이 드는 것이다.
* * *
# [o] 현재 lhs를 판단 로직은 괜찮은가? ==>**네, 지금처럼 구현**
* why?
    * 현재는 다음 코드를 돌리면 어떠한 에러도 보여주지 않는다.
    ```go
    def A
        age := 25

    main() void
        A = A()
    ```
    * 안되는 예는 또 있다.
        ```go
        main() void
            arr := {1, 2}
            arr[0] = 3 // 1
        ```
        * 1번에서 `arr[0]` 은 assignExpr의 lhs는 `runExpr(getExpr(null, "arr"), "@getElem", args{1})` 로 파싱된다.
        * 즉 항상 getExpr이 아니다. runExpr이지.
        * 현재 구현을 보면 case by case로 처리하고 있다.
            1. 모든 getExpr은 lhs다.
            2. elem을 꺼내기 위한 runExpr이라면 lhs다.
        * 라고 처리하고 있다. 여기서 2번은 구현은 되지 않았지만 주석처리된 걸 보니 확실히 인지하고 있었다.
    * 아무튼 현재의 구현은 모든 시나리오를 조사해서, getExpr 혹은 elem을 가져오는 runExpr만 lhs라고 하고 있는 상태다.
    * 그런데 getExpr로 가져온게 incomplete인지 아닌지 봐야하는데 그런 로직이 없었다는 문제가 발견된 거고.
* [x] 과연 이렇게 건 by 건으로 처리하는 게 과연 맞는가. 뭔가 공식적으로 분석해서 근본적인 규칙을 찾아내야 하는 것이 아닌가? ==> **언어마다 lvalue에 대한 기준이 다를 수 있다는 통찰을 얻었다.**
    * 조금만 생각해보면 근본적인 규칙을 알 수 있다.
    * c++에서의 lvalue의 구분의 핵심은 *추적 가능한 메모리* 를 lvalue라고 하는 것이다.
        * 예를들어 변수명이 붙은 변수는 추적가능하다.
        * 이름없는 객체는 추적이 불가능하다.
        * 변수로써의 배열의 `[0]` 은 element는 비록 이름이 없어 추적이 불가능하지만 간접적으로 추적이 가능하다. 그러니 추적가능하다.
        * 함수의 반환형 `A`라고 해도, 함수 안에서 return A()로 되어있으면 이는 추적이 불가능한 것이다. C++에서는 이 경우 함수의 반환형이 `A*, A&`  가 아니라 `A` 로 값으로써 표현이 된다.
            * **근데 당연히 by object 를 따르는 언어들은 이런게 없지?** ==> 즉, java와 c++에서 정의하는 lvalue는 조금 다를 수 있고, 그에 따른 동작도 다를 수 있겠다는 통찰을 얻을 수 있다.
* [x] 따라서 다른언어들도 C++ 처럼 lvalue를 판단하고 그에따라서 assign이 되고 안되고를 동일한 컨셉으로 가져가는 지는 조사를 해봐야 한다. ==> **생각보다 대다수의 언어들이 lvalue취급을 한다.**
    * [x] c++
        * lvalue 범주
            1. 이름있는 객체, 함수
            2. 그리고 1번에 대한 참조, 주소
            3. 1번을 도출할 수 있는 표현식 **(!)**
                * 예를들면 이게 된다: `(i < 3 ? i : j) = 7;` 놀랍다. C++.
        * rvalue
            1. 이름없는 객체
            2. 리터럴 상수
            3. const 화된 lvalue
    * [x] python
        * 임시객체로부터의 field는 lvalue임.
    * [x] java
        * 임시객체로부터의 field는 lvalue임.
    * [x] swift
        * 임시객체로부터의 field는 immutable속성으로 rvalue임.
    * [x] go
        * lvalue
            * 메모리 장소를 참조하는 것들
            * 이름이 붙은 변수/함수
            * 변경가능한 (mutable)한 것들
        * rvalue
            * 상수
            * 항상 우측에만 나오는 것들
            * 임시객체
    * [x] rust
        * 임시객체로부터의 field는 허용. lvalue임.
    * [x] kotlin
        * `(if (boolean) a else b) = 22` 가 된다.
        * `(if (boolean) 22 else b) = 22` 는 안된다.
        * 즉 if에 대해서 eval된 값이 rvalue int인지 lvalue int인지를 구분하고 있다는 얘기가 된다.
* 컨셉적인 면에서 case by case로 대응하지 말자.
    * 사용자에게 문법을 가르칠때 a = 0 되고 22 = 0 안되고 그런데 if (boolean) a else b) = 22는 되는데 if (boolean) a else 22) = 22는 안됩니다.
    * 라고 가르치면 안된다.
    * 문법을 관통하는 하나의 법칙. 그 법칙만 알면 위에서 뭐가 안되고 뭐가 되는지를 바로 알 수 있도록 해줘야 한다.
    * 물론, 그 것을 구현할때는 case by case로 해도 괜찮다.
* 고찰
    * `23 = 34` 는 허용해주면 안된다. 이건 자연스럽지?
    ```go
    foo() A
        return A()
    foo() = A() // 이건 어때? 이상해?
    foo2() A
        def a1: with A()
        return a1
    foo2() = A() // 이건?
    foo2().name = "wow" // 2: 이건? 자연스럽지?
    foo().name = "wow" // 2-1: 그럼 이건?
    foo3() int
        33
    foo3() = 22 // 이건?
    foo4() int
        def val
            with 33 // with int(33) 과 같은 것이다.
        return val
    foo4() = 23 // 이건?
    print(foo4()) // 1: 이건?
    ```
    * 위의 예제를 적고 나니 좀 납득이 가는 점이 있다.
        * 엄밀히 말하면 이 lvalue 문제는 필요가 없다. 에러 예외처리를 하지 않는다고 해도 동작에 치명적인 문제가 생기는 건 아니다.
        * 컴파일이 안된다거나 다른 의미로 인식되어서 전혀다른 코드가 된다거나 하지 않는다.
        * 하지만 이 lvalue 예외처리가 없게되면 1번 라인에서 볼 수 있듯이, 사용자는 치명적인 착각을 하기 쉽다.
        * 그것은 immutable 변수인데도 `마치 할당이 되었으니, 여기서는 변경된 값이 들어오겠지?` 라는 착각을 한다는 것이다.
            * 하지만 2, 2-1을 보자.
                * verifier는 돌려보지 않고 반환값 A가 lvalue인지 rvalue인지 알 방법이 없다.
                * 즉, 이 1번 문제를 잘 막았다고 하더라도 `할당이 되었으니, 여기서는 변경된 값이 들어오겠지?` 라는 착각은 2번에서 일어날 가능성이 있다.
                * 2번을 verifier에서 완전히 막을 수 있는 방법을 제시하지 못하는 이상, 1번을 기껏 막아봤자 반푼이밖에는 안된다는 거다.
        * 즉 사용자의 착각을 막아서 에러를 예방하는 차원이라면, lvalue를 에러로 간주하는 것을 어느정도 납득할 수 있다.
        * 실질적으로 처러한 코드를 작성하는 것은 99% 의미가 없으니까.
 * lvalue냐 rvalue냐 하는 문제는 생각보다 복잡하다.
     ```go
     foo(a A) A
         ....???....
     foo().name = "wow" // 1
     ```
     * 위 함수가 있다고 해보자. 이때 foo()의 구현이,
         1. return a 일 경우: 1번 코드는 옳다.
         2. return A() 일 경우: 2번 코드는 옳지 않다.
             * 2번 코드가 옳다고 주장한다는 것은, A().name = "wow" 가 된다는 것이다.
             * 이게 된다는 것은, int(33) = 22 무슨 차이가 있느냐는 질문이 된다.
     * 물론 직관적으로 2-1은 자연스러워보이고, 2-2는 부자연스럽지만, 그건 내가 코딩을 많이 해봤기 때문에 느끼는 것이다.
     * 둘을 놓고 처음 이걸 본다는 관점에서 생각해보자. 도대체 무슨 차이가 있는가?
         * 둘다 추적이 불가능하다.
         * 둘다 이름이 붙여져 있거나 메모리로 참조가 불가능하다.
         * 둘다 의미가 없다. 즉 둘다  *일반적인 rvalue로* 보는게 맞다.
     * 문제는 컴파일 시간에는 rvalue인지 알 방법이 없다는 것이다. 돌려보지 않고서는 rvalue를 반환한 것인지 lvalue를 반환한 것인지를 모르니까.
     * 즉 rvalue냐 lvalue냐 하는 것은 타입에 종속된 것이 아니라 런타임에 어떠한 객체를 만들어 냈는가에 달려있다.
         * 같은 타입이라고 할지라도 label이 달려있으면 추적이 가능하므로 lvalue 라는 얘기다.
     * 그러니, 명확한 컨셉을 놓고 lvalue, rvalue를 구분하기 보다는, 그때그때 컴파일러의 에러 탐지의 한계를 무마하기 위해서 급조된 느낌이 진하게 나지 않는가?
> 요약:
>     lvalue냐 rvalue냐 하는 문제는 생각보다 복잡하다. 근본적으로 런타임에만 해결이 가능하다.
>     타입 T에 대한 lvalue 타입, rvalue 타입을 만들어내지 않는 이상(C++처럼 하지 않는 이상), 대다수 언어들이 하고 있는 lvalue 구분이라는 건
>     헛점이 반드시 존재한다.
>     그러니 나도 같은 언어를 만들고 있으므로 이 lvalue를 완벽히 탐지해낼 생각은 하지 않는게 좋다.
>     그러면 내가 할 수 있는 선택은,
>         1. lvalue/rvalue 에러를 전혀 내지 않는다.
>         2. 완전히 해결하기 위해 lvalue타입, rvalue타입을 만들어 낸다.
>         3. 그냥 대다수의 언어들이 지원하는 수준을 case by case 구현으로 맞춘다.
>     인데, 3번으로도 사실 대부분이 커버가 된다.
>     그래서 3번으로 일단 진행하도록 하겠다. 1번으로도 생각해봤는데 문법이 너무 이질적이고, 사용자로 하여금 `착각`을 일으켜서 더 큰 문제를 발생시킬 수 있다는 걸 알았다.
>     **지금처럼 verifier는 getExpr, getElementExpr** 만 2가지 케이스에 대해서만 lhs 에 올 수 있다. **if는 아니다** if를 허용하면 if 안에 상수가 있는지, 변수인지, A타입이라도 A()인지 아니면 a 인지 또 구분을 해줘야 한다.
* * *
# [o] 불완전 객체에 대한 정보 접근
* namu코드에서 불완전객체에 대해 접근하고자 하는 경우, 어디까지 허용해야 하는가?
    1. [d] 값의 read 허용
    2. [u] 내부 완전 obj 에 대한 메소드,변수 호출 허용
    3. [u] 메타정보 획득 허용
        * [u] 획득한다면, (불)완전 객체인 이 타입에 어떠한 prop이나 func이 있는지를 반환하는 거겠지?
    4. [u] 3번을 더 확장해서, java처럼 reflection으로 값조차 가져올 수 있는가? 트라이를 할 수 있다. 물론. 값이 없다면 런타임익셉션이 나겠지.
    5. [u] 생성자 호출
    6. [u] 완전객체로부터 확장된 함수들을 호출
    7. [u] 정의할당문을 사용해서 불완전객체에 대한 참조를 생성
        * 불완전객체에 대한 할당문을 사용할 수 없다.
        * 불완전객체 대한 참조를 생성하려면 정의할당문을 통해서만 가능하다.
        * 이때 프로퍼티명을 대문자로 시작해야 한다.
        * 이렇게 만들어진 프로퍼티는 사실상 불완전객체인 origin 객체 취급을 하면 된다.
* 문제2: 불완전 객체는 접근이 허용된다고?  ==> **접근, 정의할당만 허용된다**
* [x] verifier는 타입만 기억한다. 타입에 불완전객체를 넣었는지 아닌지를 어떻게 아는가? ==> 프로퍼티명을 같이 정의할때만 불완전객체를 정의할 수 있다.
    ```go
    def A // 불완전
        foo() void: ...
    A.foo() // 에러다.
    A.foo // 이건 OK????

    // 근데 접근이라는 건 말야, 타입으로 넣을 수도 있다는 거야.
    f := A.foo() // 그리고 일단 한번 넣어버리면 말야,
    f() // verifier는 이 타입에 들어있는 변수가 foo()인지 아닌지 알기가 쉽지 않지.
    ```
    * 즉, 불완전객체를 타입에 넣는 행위조차도 막아야 한다.
    * 한번 넣어버리면 거기 안에 불완전객체가 있는지 아닌지 알기가 보통 어렵지 않으므로.
    * [?] 불완전객체를 타입에 넣는 것을 막으려면 정의할당문, 할당문, `ret` 만 막으면 되나?
        * 또 다른 경로는 없고?
        * import 대신 사용하는 `:=`를 떠올려보자.
            ```go
            Gson := com.google.test.Gson // 1) 이렇게 import 대신 사용하라고 가이드를 했었다.
            Gson := com.google.test.Gson() // 2) 이렇게 하면 객체를 생성한 것이다.
            ```
            * 1은 불완전객체여야 한다. 2는 완전객체여야 한다.
            * 문제는 현재 문법에서 verifier는 타입만 검사하고, 2개는 모두 같은 타입이다.
            * 그러니 1번과 2번은 동일한 함수,문법을 적용할 수 있다.
            * 불완전객체도 할당한 후, 그냥 쓸 수 있는 것이다.
            * 문법을 고친다면 가능성이 없는 건 아니다.
            1. [u] 불완전객체는 할당/정의할당 하려면 `:=` 와 함께 프로퍼티 명을 대문자로 시작한다.
                * [u] 프로퍼티명이 앞이 대문자이므로 이 프로퍼티도 불완전객체라는 걸 암시하는 것이다.
                * [u] 대문자로 하지않으면 불완전객체를 정의할당할 수 없다.
                * [u] 할당 될 수 없다. 문제가 고역해진다.
                    ```go
                    def A
                        foo() void
* [x] 프로퍼티때와 마찬가지로, 함수의 반환형 역시 뒤에 옵니다.
```go
// foo() 함수는 int, flt, char를 인자로 받고 아무것도 반환하지 않는(void) 함수입니다.
foo(a int, b flt, c char) void
    print(a + b + c) // print문은 기본 제공되는 함수로, 화면에 값을 출력합니다.
```

* [x] 위에서 제가 언급한 함수 정의에 함수명이 없다는 점을 눈치채셨나요?
* [ ] 함수명을 적지 않으면 람다함수가 됩니다. 단, 람다함수는 반드시 함수 호출 안에서 적어야 돼요.
* [ ] 람다함수는 parameter타입과 반환형을 생략할 수 있어요.
```go
if true
  runLambda(val1, (a, b)
    a + b
  , 33) // indent를 한번 한 후, comma를 적었다는 걸 주의하세요.
```
* [ ] 앞에 정의한 람다를 다음처럼 한줄에 적을 수 있습니다.
```go
runLambda(val1, (a, b): a + b, 33)
```
* `ret` 는 값을 반환하고 함수를 종료합니다.
* [ ] `...` 로 가변 인자를 표현할 수 있어요. 가변인자는 인자목록 끝에 정의해야 돼요.
```go
sum(args... int) int
   sum := 0
   for a in args // args 는 int[] 과 같은 거예요.
       sum += a
   ret sum
```
* * *

## 객체 정의
* [x] namulang은 OOP언어입니다.
* [x] 객체를 만드는 방법은 2가지가 있어요. 하나는 새로운 객체를 만드는 것이고, 다른 하나는 이미 만든 객체를 복제 하는 거예요.
* [x] 새로운 객체를 만들때는 다음 처럼 하면 돼요.
```go
// def <객체이름>
//    <정의블록문>
def person
  age := 0 // 정의블록문에는 프로퍼티나 함수 등 정의하는 구문만 올 수 있습니다.
  hello() void // 객체에 함수도 정의할 수 있죠.
    print("I'm foo and $age years old!\n")
```
* [x] 객체를 만드는 또다른 방법은 이미 만들어진 객체를 복제하는 거예요.
* [x] 함수에 대고 호출하면 함수호출이 되듯, 객체에 대고 호출하면 객체 복제가 되요.
* [x] 함수 안에서 이 함수를 소유한 객체를 `me` 로 접근합니다.
* [x] `me` 는 생략이 가능합니다. 자세한 내용은 Scope에서 다룹니다.
```go
def Person
  age := 0
  say() void: print("I'm $age yo.\n")

main() void
  p1 := Person() // a)
  p1.age = 1
  p2 Person // a와 같은 코드입니다.

  for p in {p1, p2, Person()} // 이름없는 객체를 만들 수도 있습니다.
    p.say()
```
<<결과>>
* * *
## 생성자
* [ ] 생성자는 `ctor` 이라고 하는 고유 함수명을 사용합니다.
* [ ] 생성자를 정의할 때 반환형은 생략합니다.
``go
def Food
  name str
  price int
  ctor(name str, price int)
    me.name = name
    me.price = price
pizza := Food("pizza", 15000)
```
* [ ] 생성자 안에서만 `ctor`로 생성자를 호출할 수 있습니다.
* [ ] 내부적으로 생성자는 객체 생성되고 나서 자동으로 호출됩니다.
* [ ] 즉, 생성자 안에서 `ctor`로 또 호출한다고 해서 객체가 또 생기는 건 아니란 얘기입니다.
```go
def Food
    name str
    price int
    ctor()
        print("call constructor!\n")
        ctor("defaultName", 100)
    ctor(name str, price int)
        me.name = name
        me.price = price
 print(Food().name) // "defaultName"
> 요약:
>     verifier는 어떠한 값을 read/write하는 모든 expr에 대해서 그 값을 읽어올 대상이 불완전객체인지를 항상 검사해야한다.
>     이러한 expr에는,
>         runExpr:
>             1. args 중에 불완전객체가 있으면 안된다.
>             2. meObj가 불완전이면 안된다.
>         assignExpr: lhs, rhs 둘 중 하나라도 불완전이 있으면 안된다.
>         returnExpr: rhs가 불완전이면 안된다.
>         fboExpr: lhs, rhs 둘다 안됨
>         fuoExpr: lhs 안됨
>         asExpr: lhs 안됨. rhs는 OK
>         .... 이런식이다 ....
* * *
# [o] namu의 코딩스타일을 cpp 코드에 적용하자.
1. 클래스는 대문자로 시작.
* * *
# [o] kotlin의 let, apply, with, also, 등을 내 언어도 사용할 수 있는가? 아니면 비슷하게 간단하게 할 수 있는 방법이 있는가?
```kotlin
// 1:
val res = foo()
res.doSomething()
res.name = "wow"
// 개량:
foo().apply {
    doSomething()
    name = "wow"
}
// namu
with foo()
    doSomething()
    name = "wow"

// 2:
val res = foo()
if (res != null) {
    res.doSomething()
    res.name = "wow"
    runActivity(res)
}
// 개량:
foo()?.let {
    it.doSomething()
    it.name = "wow"
    runActivity(it)
}
// namu:
with foo()? // null이 아니어야 with를 실행한다.
    doSomething()
    name = "wow"
    runActivity(me)

// 3:
val views = Views(name, if (hasPermission) layout1 else layout2))
initialize(views)
return views
// 개량:
return Views(name, if (hasPermission) layout1 else layout2)).also { initialize(it) }
// namu:
return with Views(name, if (hasPermission) layout1 else layout2)): initialize(me)
```
* 확인 결과, 대부분의 경우 with가 2가지 기능을 추가로 가져가면 될 것 같다.
    1. `with expr?` 처럼 expr이 null로 판정되면 with를 아예 skip하는 기능이 필요하다 ==> **다른 expr에 대해서도, 심지어 expand에 대해서도 동작해야 한다.**
    2. with를 eval하면 blockExpr을 모두 실행한 다음에 expr 자신을 반환한다.
* * *
# [o] finally를 대신할 문법을 제공하는가? ==> **swift의 defer를 `end` 라는 이름으로 제공한다.**
* [u] 다른 언어는 finally를 제공하나? 안하는 경우라도, 뭔가 마무리 작업을 해줄 수 있도록 기능을 넣어준다.
* [x] 제공안하면 죽나? c++도 안 하는 거 같은데. 안하면 많이 안좋나? 대체 가능하거나 코드 몇줄로 치환가능하면 그냥 이대로 가는게 좋을 것 같긴 하다.
    * 문법을 늘리고 싶지 않다.
* [x] 패턴매칭에 finally를 추가하자는 아이디어도 있다. ==> **패턴매칭에 국한시키지 말고, RAII를 지원한다는 관점에서 접근해야 한다.**
    * [u] 하지만 finally를 쓰는 이유는 대부분은 RAII 같은게 아닐까?
    * [u] 만약 그렇다면, RAII를 위한 문법을 추가하는 게 더 우아한 방법 아닐까?
1. [?] swift 처럼 한다.
    * swift 는 `defer blockExpr` 라는 키워드를 제공한다.
    * defer 뒤에 있는 blockExpr가 함수를 빠져나갈때 반드시 실행되도록 해주는 키워드다.
    * defer까지 실행되지 않고 도중에 return되면 그냥 return된다.
    * defer를 만나고, 또 defer를 만나면 먼저 만난 defer가 먼저 발동된다.
    * A 변수를 만들고 A에 대한 close() 호출을 앞에서 미리 작성하고 들어가니까 코드를 이해하는 데도 확실히 편하다.
    * 그리고 도중에 return을 하더라도 close()을 빼먹은것은 아닐지 걱정할 필요도 없다.
    * [x] 내 구조에서 구현은 쉬운가? ==> **네**
        * returnExpr의 동작
            * return하려는 값을 frame::setReturnValue()에 넣어둔다.
            * blockExpr은 다음 stmt를 run()하기전에 returnValue에 값이 있으면 이걸 바로 return 하는 식이다.
            * 이 흐름은 거슬러 올라가서 결국은 mgdFunc::run()까지 올라간다.
            * defer한 blockExpr들을 순차적으로 수행해주면 구현이 가능할 것이다.
    * [x] 구현 문제1: defer는 사실상 closure라는 사실이다. ==> **block문을 벗어나는 순간 defer가 실행되게 하는게 좋은 것 같다.**
        * why?
            * 다음 코드를 볼까?
                ```go
                foo()
                    a := 22
                    defer
                        print(a) // 1
                    if a > 5
                        a := 55
                        defer
                            print(a) // 2
                ```
            * 1의 a와 b의 a는 다른 a다.
            * 하지만 아무 생각없이 defer를 구현하면 어떻게 될까? 그냥 mgdFunc::run()이 종료되기 직전에 blockExpr()을 순차적으로 실행하려고만 할 것이다.
            * 그럼 어떻게 되는가? 종료 직전의 stackFrame이 유지된 채로 해당 blockExpr이 실행된다.
            * 즉 도중에 return을 종료했다면 그 returnExpr이 어느 블록문에 있느냐에 따라서 서로 다른 a 변수를 참고하게 된다.
        * 해결방법은?
            1. [u] block문을 벗어나는 순간 defer가 실행되게 한다.
                * [u] 이게 더 맞는거 같긴 한데, 다른 언어들은 어떻게 만들어져 있지?
                    * [x] go
                        ```go
                        defer f.close() // 한줄짜리르 쓸 수 있다.
                        defer func() {
                            f.close()
                        }() // 익명함수를 만들어서 여러줄을 처리한다.
                        if true {
                            defer f.close() // 블록문이 끝난다고해서 이 defer가 실행되지는 않는다.
                                            // 함수가 끝날때 모았다가 한번에 실행한다.
                        }
                        defer foo(boo()) // 이 boo는 바로 실행된다. 그 값이 foo()로 binding된 상태에서 defer 된다.
                                         // 그러니 go의 defer는 closure가 아닌셈이지.
                        ```
                    * [x] kotlin: 키워드가 없음
                    * [x] swift: go와 비슷한데, 블록문이 벗어날때 defer가 불림.
                    * [x] python: 키워드가 없음
            2. [d] defer를 blockExpr가 아니라 closure로 만든다.
* 한가지 사용성 단점이 있다.
    * java의 경우는 autocloseable을 통해서 어떻게 정리하겠다는 내용을 객체에 담을 수 있다.
    * 그리고 이 객체를 try에 담기만 하면 된다. 정리는 일괄적인 코드로 처리한다.
    * 그런데 defer는 직접 어떠한 함수를 불려줘서 메모리 해제를 해줘야한다.
    * 어떠한 함수를 불려줘야하는지는 defer하는 객체의 타입에 따라서 다르게 된다.
* [d] autocloseable을 defer와 합칠 수 있는가?
    * autocloseable을 구현하는 가장 좋은 방법은 객체가 죽을 시점에 알아서 close()를 부르게 하는 점이다.
    * c++은 이게 된다. 왜냐하면 객체로 생성하면 scope을 벗어나면 죽고, new로 생성하면 사용자가 알아서 delete를 해줘야하는,
    * 라이프사이클을 사용자에게 다 맡겨버렸으니까.
    * swift는 ARC라고 하는 reference counting으로 GC를 대신한다고 한다. 그러면서 동시에 c++처럼 필요가 없어지면 바로 delete를 해준다.
    * 그래서 swift는 RAII가, 소멸자가 있다.
    * [x] 어떻게 한걸까? ARC는 어떻게 다른걸까? ==> **그냥 smart pointer를 사용자에게 하나 준 셈이다**
    * Swift는 C++처럼 메모리 관리를 한다.
    * 그래서 소멸자가 있다. 소멸자가 있으니 쉽게 RAII가 된다. 이런 흐름이지.
    * 순환참조 같은 부분을 자동으로 해결하고 싶나? --> 그럼 GC가 있어야 한다. --> GC는 순환참조를 언제 해결할지 정확한 시점을 알려줄 수 없다. --> 그러니 소멸자가 의미가 없다. --> 그러니 RAII를 소멸자 기반으로 하면 안된다.
    * RAII를 위한 함수를 만든다.
    * 그리고 키워드를 추가하거나 defer를 사용해서 RAII처럼 동작할 객체들의 이름을 쭉 쓰게 한다.
        * 객체에 RAII 함수를 추가했다고 해서 자동으로 호출되게 하는 것도 물론 가능하지만 안되는 이유가 2가지 있다.
            1. 특정 함수를 키워드처럼 특별하게 취급할 순 없다.
            2. GC가 있는 언어에서 객체가 블록문을 빠져나간다는 게 곧 소멸을 의미하지 않는다.
                ```go
                foo() A
                    if true
                        return A(5) // 객체가 블록문 안에서 정의되었지만 A가 소멸되어서는 안된다.
                    A(2)
                ```
        * 그러니 자동은 안된다. RAII를 위해서는 defer와 함께 RAII로 쓸 객체명의 나열이 반드시 필요하다.
* 예시 코드
    ```go
    def A
        ....
        defer()
            defer socket
    foo()
        a := A()
        defer: a.close()
        // defer a // 이렇게?? 근데 이렇게 하면 A::defer() 라는 함수가 있는건가? A.defer()를 직접 호출 할 수도 있나?
        // defer a, b 도 가능한가?? 왜 defer만 , 과 되나? 그럼 with a, b 도 하고 싶어지지 않나?

        // 아니면:
        // defer는 2가지로 사용된다:
        //   1. defer <expr>
        a := defer A() // defer는 표현식이다. 뒤에 나올 expr을 함수 종료시에 등록하고 expr 자체를 반환한다.
        //      이렇게 사용 할 수도 있다.
        a := A()
        defer a
        //      그리고 모든 blockExpr이 오는 자리에는 1개짜리 expr이 올 수도 있다고 하자:
        if a B else C // 정의문 `a B` 처럼 파싱될까봐 걱정되나? 새로운 문법에서는 정의문은 표현식이 아니다. 그러니 모호하지 않을 것이다.
        for n in 2..3 print(n)
        foo(n int) c // 아... 이건 모호하다. c가 반환형인지, 아니면 1줄짜리 구문인지.
        foo(n int) void print(n) // 이렇게 반드시 반환형을 적으라고 하면 괜찮긴 하다.
        (n) print(n) // 이상하다.
        // 그리고 무엇보다 defer a 를 defer: a로 보겠다는 거잖아? a 만 달랑 있으니 이건 a.defer() 호출이 아니다.
        // 그러니 defer <expr>과 defer <blockExpr>은 아예 동작이 다르다. 그 동작이 하려는 목적만 같을 뿐.
        //   2. defer <blockExpr>
        a := A()
        defer
            a.close()
        // 혹은
        defer: a.close()
    ```
* [u] defer는 이름이 적절치 않다. ==> **end 로 변경하자. 끝낸다는 의미, 마지막이라는 의미, 그러면서도 친숙한 단어다.**
    * `defer: a.close()` 에서 defer는 적절하다.
    * 하지만 `defer a` 에서 defer는 의미가 이상하다.
    * 게다가 `A::defer()` 는 더더더 이상하다. 단어만 보면 `안에있는 코드를 지연시키는 건가?` 처럼 느끼겠지만 실상은 `작업 마무리, 리소스 해제` 이기 때문이다.
    * 뭔가가 마무리하는, 끝내는, 마지막에 실행하는, 그러면서도 짧고, 익숙한 단어인,
    * 그런 포괄적인 의미를 다 담은 단어로 변경하자. ==> **end!**
> 요약:
>     RAII를 C++, swift 처럼 자동으로 하려면 소멸자가 필요하다. 소멸자가 있으려면 GC가 있으면 안된다.
>     그러니 내 언어는 어떤 객체를 close() 할 것인지를 명시해야 하는 문법을 써야 한다.
>     defer는 expr 이다. eval이 가능하다.
>     defer 키워드는 2 문법으로 사용한다.
>         1. defer \<blockExpr\>
>             blockExpr을 나중에 수행한다고 등록한다.
>             eval하면 blockExpr::eval()을 반환한다.
>         2. defer \<expr\>
>             expr::end() 함수를 호출하는 코드를 나중에 수행한다고 등록한다. ==> \<expr\>.end()
>             end는 특수목적 함수로 사용자는 이 이름으로 함수를 만들 수 없다. 같은 종류의 함수로 ctor이 있다.
>             end는 사용자가 직접 호출도 가능하다.
>             eval하면 expr::eval()을 반환한다.
* * *
# [o] ARC 공부하기 ==> **이 기능 별로다. 잊어버리자.**
* Reference Counting 맞다.
* 신박한 뭔가가 있는 것도 아니다.
* 그냥 `weak` 라는 키워드가 있어서, 사용자가 직접 strong인지 weak인지 관리해줘야 한다.
* 요즘같은 시대에 참.
* * *
# [o] indent를 무시하고 1줄짜리를 표현하는 방법이 있어야 한다. ==> **`:`과 `;` 2가지를 제공하자.**
1. [?] 유력한 방법은 `:` 을 쓰는 건데, 너무 생각이 안일하지 않나?
    * 게다가 같은 라인을 붙여쓸 수도 있어야 하므로 `;` 도 필요해진다.
* 개행 + indent를 무시하고 한줄에 작성하는 문법에 대해 다시 생각해보자.
```go
for a in {1, 2, 3}
	x = a + 1
	print(x)
// 위의 코드를 줄여보자.
for a in {1, 2, 3} -> x = a + 1
	print(x)
// 현재 스펙으로는 이렇게 밖에 안된다.
```
* 또다른 방법은 `;` 일 것이다.
```go
for a in {1, 2, 3}: x = a + 1; print(x) // 된다.
// 그러면 이경우는?
// a = if x -> -1 ?: 1   ==> ; 대신에 scope을 벗어낫다는 표현이 되어야 한다.
a = (if x: -1) ?: 1 // 이건 현재는 불가능하다.
a = (if x
	-1) ?: 1 // 이게 되므로 안된다. \new line 이 없기 때문에.
// 컴파일러가 ->를 한 뒤에 한 statement가 나오고 그 뒤에 )가 나올경우 \n을 끼워넣어준다면 가능하다.
```
* 다른 방법은 없나? `->`가 최선인가?
* python 같은 경우는 그냥 한줄로 작성할 수 있도록 해주었다.
```python
if v > 5:
	print(0)
elif v < 10:
	print(1)
else:
	print(2)
# 위에가,
print(0 if v < 5 else 1 if v < 10 else 2)
for i in v:
	if i == 12:
		print(i)
# 위에가,
print(i for i in v if i == 12)
# 심지어는,
for i in v: if i == 12: print(2) # 한줄이라면 indent 없이 바로 붙이면 된다.
```
* 어떻게 이게 가능한가? 내 언어도 가능한가?
```go
if v > 5 print(0) else print(1) // 내 파서를 고치면 이게 가능한가
```
* 안된다. 다음과 같은 케이스가 있으니까.
    ```go
    if x > a b
    ```
* NIM이라는 언어도 offside-rule을 적용한다. 여기에도 `:`, `;` 를 사용해서 indent를 잠깐 무시하게 해주는 기능이 들어가 있었다.
* 일단은 `:`과 `;` 방식으로 해보자.
* * *
# [o] with를 무슨 기능이라고 이름을 붙이지? ==> **Type Expansion**
* * *
# [o] `pack` 키워드 이전에 나온 것들은 해당 소스코드 파일 내에서만 유효하다.
* * *
# [o] aka는 정말 필요한가? ==> **aka를 없앤다. `A := B`로 대신한다.**
* `aka A B` 는 `B := A` 와 같은 것 아닌가??
* A가 완전객체라면 그렇다.
* [x] 한번 해볼까? ==> **되는 거 같다.**
    ```go
    def A
        age := 0
        grade int
            get: // 안에서 foo()함수를 호출할지 알수가 없다.
        context Context
        foo() void
            ... // 안에서 context를 사용하는지 안하는지 컴파일러는 모른다.
        ctor(context): ret // 불완전객체. 여기서 context값이 채워진다.

    a A(context)
    a.foo() // ok
    print(a.age) // ok
    A.foo.name // ok
    A.foo() // err. 불완전객체다.
    A.age // ok.
    print(A.grade) // err.
    A(context) // ok

    aka A My
    My.foo.name // ok
    My.foo() // err
    My.age // ok
    // My와 A는 같은 것이다. 거의 문자열치환에 가까울 정도로 동일한 정책을 갖는다.

    My := A // 이걸 만약 허용한다고 해보자.
    My.foo.name // ok
    My.foo() // err
    My.age // ok
    // 이렇게 나오게끔 할 수 있는가?
    ```
    * [x] 얼추 비슷하게 나오는 것 같다. 함수에 대한 aka는 어떨까? ==> **불완전객체로 참조하는 함수로 클로져를 만들려는 시도는 무조건 컴파일 에러다.**
        ```go
        myFoo := A.foo // 이것도 가능한가?
        myFoo.name // 1
        myFoo() // 2
        ```
        * `A.foo` 는 클로져 문법이다. 즉 위 구문은 클로저를 가져오는 지극히 일반적인 구문이다.
        * 여기서 클로저는 원본 함수에 대한 메타API를 기본적으로 delegation해야 한다는 걸 알 수 있다. 즉 1번은 이걸로 가능해졌다.
        * 그런데 문제는 2번이다. `A.foo` 때문에 이 클로저의 me obj는 이미 A로 capture가 된 상황이기 때문에 이걸로 call을 한다는 것은 의미가 없기 때문이다.
        * 따라서 클로져로 변환하는 문법을 만났을때 me obj가 불완전이면 컴파일 에러를 내보내야 한다.
    ```go

    myFoo()
    grade := A.grade // 이것도 가능한가?
    ```
* [?] pack scope에서 aka를 쓰는 경우라면?? aka는 중복이 허용된다??
    * aka를 쓴다고 해서 무조건 중복이 허용되면 안된다고 본다. 이걸 허용하겠다는 생각은 C++적인 마인드를 가지고 있어서 그렇다. 이 기능은 너무 코드가 헷갈리게 된다.
        ```go
        a := 55
        aka myObj a // 이건 에러인가? 중복을 허용하니 이것도 허용하는가?
        aka b a // 이건 에러인가? 중복을 허용하니 이것도 허용하는가?
        ```
    * c++를 typedef 중복을 허용하지만, 이건 어떻게 보면 c++의 `include`가 워낙에 멍청하기 때문에 어쩔 수 없이 들어간 거라고 봐야한다.
    * 실제로 다른 OOP들은 c++처럼 강력한 typedef를 제공하지 않는다. 그들이 능력이 없어서? 아니 그렇게 안해도 되니까.
    * [x] 같은 pack 다른 파일에서 각각 `aka A.B.C C`를 하는 것은 허용된다. 하지만 aka 대신 각각 파일에서 `C := A.B.C` 를 하는 거라면?? ==> **`pack` 기능으로 해결한다.**
        * `pack` 보다 앞서서 정의한 것들은 해당 소스코드 파일내에서만 유효하다. `pack`보다 나중에 나오면 pack전체에 유효하다.
        * 이것과 `A := B` 응용하면 기존의 `import` 문을 대체할 수 있다.
        * 위의 시나리오도 대응이 가능하고.
* * *
# [o] assign은 expr이 아니어야 하지 않나? ==> **defExpr은 expr에서 빠졌으므로, lhsexpr, rhsexpr을 구분해서 다시 파싱문법을 짜보자.**
* 문제1은 일단 parser를 통과한다는 점이다. 왜냐하면 뭔가 expr 과 관련된 문법을 추가할 때 conflict이 발생하기 때문.
* 대표적으로 이런 것이다.
```go
a := b < c > () = if true -> 1
a := b < c = if true -> 1
```
* 왜 문제가 되냐면 `<`까지 읽었을때 다음 문자는 `c`가 되는데 이것만 LA 해서는 위에껀지 아래껀지 S/R 에러가 나오기 때문이다.
* 무시를 해도 되지만, 무시하고 싶지 않다.
* 파이썬은 expr과 assignment을 엄격하게 구분하고 있기 때문에 이런 문제가 생기지 않는다.
* [x] 즉 생각해보면, rhsExpr하고 일반 expr하고 구분을 해야 한다는게 아닐까? ==> **그런것 같다. assign 이 문제가 아니라**
* * *
# [o] Multi Line String 지원 ==> **""" 를 사용한다.**
* 대부분의 언어가 triple quotes를 사용하기 때문이다.
* * *
# [o] when과 else와 TypeInference 알고리즘
* 다음 코드를 보고 어떻게 구현할까?
    ```go
    get(val int) void // 1
        val // 2
            // 이 경우 int로 inference 되는게 아니라, 이 when들을 따져봐야 한다.
            on 1: return A()
            else: return B(0) // A도 되고, B도 되어야 하므로 이 val은 void 다.
                              // 그리고 void에 대해서 return을 명시적으로 하면 에러다.
    ```
* 1에서 함수는 반드시 반환형이 있어야 한다. 함수 반환형에 대한 TypeInference는 굉장히 퍼포먼스가 많이 필요하기 때문이다.
    * 람다는 반환형을 없애도 된다. 이때 TypeInference를 하는게 아니라, 함수타입의 반환형을 그대로 가져온다.
* 2에다가 getEval()을 하면, 2는 `whenExpr` 이기 때문에 모든 `case` 들의 eval을 merge 해야 한다. 즉 void가 된다.
* 참고로 각 `return` 들을 void에 대해서 명시적으로 반환하려고 하고 있기 때문에 에러다.
* * *
# [o] non null type에 대한 runtime error 처리 ==> **verifier는 non err type에 값을 넣었는 가를 검사한다.**
* why
    * 다음 코드를 namu 코드로 구현하려고 한다.
    ```kotlin
    fun foo(n: Int): Int {
        return arr[n] // throw OutOfException 될 수 있다.
    }
    var a: Int = 0
    try {
        a = foo(-1)
    } catch (e: OutOfException) {
        print(e.msg)
        a = -1
    } catch (e: Exception) {}
    print(a)
    ```
    * 현재 컨셉으로는 non null type에 대한 `case` 처리가 불가능하다.
    * 위의 예제를 보면 a 는 Int?가 아니라 Int다.
    * 그러나 try 블록이 따로 있기 때문에 try 밖에서도 이 값이 계속 사용되려면 어쩔 수 없이 try 밖에 a를 정의해놓아야 한다.
    * 그 과정에서 a에 대한 초기값이 반드시 명시적으로 들어가게 되므로 이 문제가 발생하지 않는다.
    * 하지만 namu는 한 줄에 대한 try만 있을 뿐이다.
    * 그러니 defAssign의 초기식 도중에 err가 발생해서 처리한 경우는, non null type 이었던 a에 어떠한 값이 들어가야 하는지가 매우 모호해진다.
    * 그 `case` 처리 이후에 a 값을 계속 사용이 가능하게 하려면 어떻게 해야 하는가?
    * 어떻게 하면 좋을까?
1. [o] runtime err는 변수에 담을 수 없는, `case`로 처리되지 않으면 panic에 빠지는 에러다.
    * 기존의 컨셉이나 구조를 최대한 살려서 조금만 변경해서 해결해보자.
    ```go
    foo(n int) int
        arr[n]
    a := foo(-1)
        is outOfBoundErr
            print(it)
            // 1. [?] 이제 a의 값은 무엇인가?
        else:;
    ```
    * 1번을 보면 a의 값은 무엇이 되는가. `is` 앞에 식별자가 없으므로 이 `is`는 targetExpr인 `a := foo(-1)` 를 돌린 값에 대해서 `is`를 한 것이다.
    * 즉, a의 값은 outOfBoundErr가 들어가 있는 상태다.
    * 현재 err 규칙에 따르면 err타입이 `T?` 도 아닌 `T` 타입의 반환형을 가진 함수에서 나올 수 있다.
        * 즉 verifier는, 함수내에서 갑작스럽게 err를 return하더라도 OK 해준다는 것.
        * `T?` 로 하는게 원칙이지만, 그렇게 할 경우 API사용성이 매우 떨어지는 경우를 방지하기 위해서 이렇게 처리하는 것이다.
    * 이렇게 미리 고지 없이, 반환된 err는 runtime err로 분류되며, 바로 handling을 하지 않는다면 에러로 간주된다.
    * blockExpr은 자신이 방금 돌린 stmt를 돌렸는데 runtime err 발생했다는 flag가 켜져있으면 panic 상태에 들어간다.
        * panic 상태에 들어가면 프로그램은 현재의 callstack을 찍고 runtime err에러의 메시지와 함께 종료한다.
    * 이 runtime err는 절대로 다른 변수에 담을 수 없다.
    * 그러나 return으로 올리는 것은 가능하다.
    * runtime err를 처리하는 유일한 방법은  `case`를 사용하는 것이다. 그 외의 회복할 수 있는 수단은 없다. 오히려 터져야 한다. 그래서 빨리 실패해서 빨리 고치도록.
    * 위의 1번에서 a의 값은 outOfBoundErr다.
        * verifier는 whenExpr를 만났을때, whenExpr.targetExpr이 defAssignExpr일 경우,
        * 해당 defAssignExpr.lhsName에 값을 채우는 로직이, 각 err타입에 대한 `case` 들마다 들어가 있는지를 검사해야 한다.
        * 검사방법은 간단하다.
            * verifier는 whenExpr.targetExpr이 defAssignExpr이며, non error 타입인지를 확인한다.
            * non err 타입일 경우, caseExpr를 모두 순회할때 각 caseExpr의 condition이 err타입에 대한 것인지를 체크한다.
            * err타입에 대한 `case`를 돌리기 전에 visitInfo에 `a 변수에 값을 넣었는가?` 항목을 preMap에 추가한 뒤 traverse 한다.
            * 각 assignExpr은 항상 어떠한 변수에데가 assign을 하였는가를 preMap에 기록시도한다.
            * `whenExpr`은 caseExpr을 traverse한 후, visitInfo에 `a 변수에 값을 넣었는가?` 항목이 false인지 true인지를 보고 에러를 올린다.
            * `whenExpr`은 preMap을 dummy로 교체한다.
        * 따라서 위 1번 코드에서는 `a = ....` 같은 assignExpr이 없으므로 에러로 간주한다.
* * *
# [o] visitor에서 visit 하는 node 에게 전달해야 하는 데이터가 있다. ==> **preMap이란 걸 만들어서 사용한다**
* why?
    * 다음과 같은 구조가 있다고 하자.
    ```cpp
    obj {
        func f;
        nInt v;
    };
    ```
    * 이때 경우에 따라서 verifier::onVisit(obj&) 에서 하위 node(즉 f와 v)를 traverse 할텐데 verifier::onVisit(f&/v&)에서 이러저러한 행동을 하였는가를 알고싶을 경우가 생긴다.
    * 쉬운 방법은 verifier에 member variable을 추가하는 것이다.
    * 하지만 이 행동여부 데이터는 오직 onVisit(obj&) 까지만 필요한 경우, 굳이 member variable로 만들어야 하는가라는 물음이 생긴다.
    * 게다가 이런식으로 하나하나 넣다보면 visitor가 기본적으로 메모리로 차지하는 비용도 어마어마하다.
    * 어떻게 하면 좋을까?
1. [o] visitInfo를 preMap으로 만든다.
    * preMap은 내가 만든 용어인데, predefined 된 key/value에만 값이 할당되고, 나머지 pair에 대해서는 기본값이 나간다는 뜻이다.
    * string이 일반적이니까 string으로 하면 되겠지.
    * 다음처럼 될 것이다.
        1. visitInfo은 preMap 객체 1개를 가진다.
        2. visitor는 preMap객체를 돌려 쓴다. 매번 만드는 게 아니라 부모로부터 받은 걸 그냥 나도 쓴다는 뜻.
        3. 처음 visitor가 할당하는 preMap은 dummyPreMap이다. 모든 동작이 가능한 것처럼 외부에 보인다. get, set, add 등
            하지만 dummyMap인 만큼, 실제로 새로운 key를 만들거나 value를 메모리에 넣거나하는 동작은 일체 하지 않는다.
            그래서 아무리 add/set을 하더라도 get을 하면 기본값인 빈 string만 나온다.
        4.  상위노드 (여기서는 obj) 에서 진짜 preMap을 하나 만들고, 하위노드로부터 어떠한 정보를 받고 싶은지를 key/value pair를 미리 활성화 해둔다.
        5. 하위노드들은 자신들의 모든 행동들에 대해서 일일이 preMap에 남기려고 시도한다.
            그러나 preMap인 만큼, 상위노드가 미리 활성화 해두지 않은 정보일 경우에는 add/set이 아무런 동작을 하지 않으므로 퍼포먼스가 하락하지 않는다.
* * *
