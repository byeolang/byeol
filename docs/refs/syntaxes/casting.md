# casting 

## Casting은 3 종류가 존재한다.
- Native에서의 dynamic cast
- worldlang ast를 대상으로 한 묵시적 형변환
- worldlang ast를 대상으로 한 명시적 형변환

## 명시적 형변환
  - 월드의 형변환은 1가지 문법으로 100% 대체가 가능한데, as() 함수다. as 함수는 다음과 같은 순서로 우선순위를 갖는다.
    - 사용자가 정의한 캐스팅코드
    - 거기에 없으면 클래스 계층상 구체클래스타입을 원하는 경우(= RTTI)
    - 거기에 없으면 주체자(= This)의 생성자를 통한 호환
    - 거기에도 없으면 실패. 끝.
  - 1번을 제외한 2-3번은 모두 WorldFrx 안에 탑재되어있어야 한다.
  - 월드Frx의 실체는 Native에 있기에 형변환을 실질적으로 수행하는 코드는 Native여야 한다. 따라서 Node를 binding하는 Refer가 반환형이기 때문에, Node에 정의된 virtual Refer as(Class&) 함수가 실질적인 형변환을 수행한다.
  - Native환경에서는 타입이 구체적으로 나와야 편하기 때문에 TRefer<T> as<T>()를 제공한다.

- 추가적으로 지역변수에다가 as를 사용한 경우에는 #로컬바인딩 을 가능하게 함으로써 해결되었다.

## 사용자가 정의한 생성자는 캐스팅에 이용된다.

* 사용자는 외부 타입에 대해 메소드를 끼워넣을수 있다. (extend)

## as함수의 반환형은 Strong Refer다.

- as함수는 World에 visible해야 하므로 반환형은 Bind가 될 수없다. Refer다. Refer는 Strong을 기본으로 하고 있다.
- Strong로 나간걸 Weak로 받을 수 있다. 따라서 as함수로 Strong인채로 나가야만 한다. (weak로만 나가면 as함수 안에서 새로 객체를 생성해서 내보낼 수가 없게 된다는 얘기다. 선택권은 호출자(caller)에게 줘야하므로 Strong으로만 내보내야 한다)

## 묵시적캐스팅

ast를 대상으로 해서 부모클래스로의 캐스팅 + 일부 primitive 변환이 해당된다.

묵시적 캐스팅의 의의는 함수 디덕션 과정 (참고로 함수디덕션은 단순히 함수호출을 의미하는게 아니다. World는 모든 것이 msg의 송수신, 즉, 함수로 보기 때문에 생성자 생성과 연산자, if 같은 keyword까지 포함한 모든 것을 의미한다)에서 주어진 인자로 이 함수를 호출 할 수 있는 지를 판단하기 위해 타입의 교량역할을 하는 것이다.

- 이 우선순위가 어떻게 정해질 것인가
- 이 우선순위를 정하는 코드를 어떻게 어느 클래스가 소요하도록 할것인가가 중요해진다.

## pretype에 대한 묵시적 형변환 목록

- 애매모호한것보다 번거로운게 낫고, 버거로운것보단 심플한게 낫다.
- built-in 타입들에 대해서 최소한의 묵시적형변환을 지원해준다. 그 이외에는 직접 개발자가 캐스팅을 코드에 명시해야 한다.
- 사용자가 작성한 타입을 부득이 다른 타입으로 변환한다는 것은 World가 적절한 타입으로 변경해준다는 걸 의미한다. 여기서 "적절함" 이란 일종의 AI를 의미한다. AI를 넣을 수 없다면 그걸 대신 할 수 있는 대중의 합의점에 해당하는 데이터가 필요로 해진다.
- 형변환 테이블에는 비슷한 그룹군이 담겨있다. 우선순위는 존재하지 않는다.
  - 원칙
    - 작은것은 큰것으로 흘러가는 것이 원칙이다. 그러나 사용성을 위하여 몇가지 예외를 둔다. (int -> float, char -> int, int -> string)
    - 예외적으로 숫자 그룹군끼리는 서로 호환된다.
    - 대부분의 built 타입은 string으로 변환될 수 있다.
  - int --> float, char, bool
  - float --> int, bool
  - char --> float, int, bool
  - bool --> int, string
  - result --> string, bool

* 예외적으로 0과 null은 false로 변환 될 수 있다. 0 이외의 값은 true다.

## str은 묵시적캐스팅에 해당하지 않는다.

산술연산인 int, char, byte, 등만 해당된다.
자바와 같은 방법이다. str도 포함되면 모호성 오류가 너무 많다는 걸 알았다.
단, 자바처럼 str + int 식의 + 에 한해서만 묵시적 캐스팅을 지원해 줘야한다.

## 메소드 호출시 인자에 대해서는 묵시적 변환만 이루어진다.

이 말은, 어떤 메소드를 호출해야 하는지 바인딩을 선택하는 과정에서 묵시적 변환으로 판단해야 한다는 것이다.
캐스팅의 주체는 객체 자체가 해야 한다. 따라서 메소드 호출을 담당하는 객체는, 각 인자들에게 해당 타입으로 변환이 가능한지를 질의한다.

## 연산자 우선순위는 파서에 의해서 구현된다.

## 캐스팅 문법

    <expr> as <identifer>
    <expr> as? <identifier>

* 모든 변수는 캐스팅의 타입으로 사용 가능하다.
* as에서 casting이 실패하면 런타임 에러가 된다.
* as?에서 casting이 실패하면 null이 들어간다.

## is

    <expr is <identifier>

* casting이 가능하면 true, 불가능하면 false가 나온다.

```cpp
def A
    bla bla...

def B from A

a := B()

b := a as b // err. b는 아직 정의되지 않았다.
b := a as B
b := a as B() // err.

A get()
    return B()

b2 := get() as a as B as b // (b) ((B) ((a) get()))
```

## 상수를 명시적 캐스팅에 이용해서는 안된다.

```cpp
a := 35
a1 := int 35
a2 := 35 a // err
```

* 착각하지 않도록 하자. 상수도 묵시적 변환은 이루어진다.

## 묵시적 형변환으로 다른 타입이 되어 setter 메소드에 넘겨도 괜찮다.

다음의 시나리오를 보자.

```cpp
def A
    void print(string a)
        a += "msg = "
        Console.out(a)

A.print(35)
```

여기서 35는 string으로 형변환 된다. print 메소드 안쪽에서 parameter a에 값을 반영하지만 모든 pretype은 immutable 이기 때문에 형변환 여부와 관계없이 메소드 내부에서의 set 연산에 외부가 영향을 받지 않는다.
만약 array 같은 것이 묵시적형변환이 된다고 했다면 문제가 심각했을 것이다.

## 커스텀 명시적 캐스팅은 지원하지 않는다.

* 왜냐하면 캐스팅이 가능한지 가능하지 않은지 여부를 컴파일타임에 알 수 없기 때문이다.
* 또한 자바는 커스텀 캐스팅을 지원하지 않지만 크게 문제될 것이 없다. parseInt() 같은 함수를 사용하므로.

## 다만 빌트인 타입에 대한 캐스팅은 native API "as"로 지원한다.

* 임의 타입에 대해서 다른 타입으로 명시적 변환이 가능하도록 하려면 @as를 오버라이딩한다.

```go
def base
def my base
    name := ""

    @as(to str) str
        sys.term.out("as")
        ret name 

base1 := my() as base
base1 as str // as
base1 as my
