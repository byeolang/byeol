ScriptList에 다음의 NENode집합을 넣는다고 하자.
	0인덱스:	5번인덱스에 대한 id 연관성을 가지고 있음
	1인덱스:	...
		.
		.
		.
	5인덱스:	...
이것처럼, 앞에 있는 노드가 뒤에 존재하는 노드에 대한 연관성 (createNodeFromId(n) 과 같은)을
지니고 있는 경우, 이 정보는 ScriptList에 넣는 순간 사라져버린다.
실례로 위의 경우, ScriptList에 들어간 0번인덱스는 -1번인덱스에 대한 연관성(즉, id없음)을
지니게 될것이다.

이것은, 매번 노드가 들어갈때마다 ScriptList에서 동기화를 실시하며, 여러개의 노드가 들어갈
때를 염두해 두지 않았기 때문이다.
이것에 대한 개선책은 두가지가 존재한다.
	1. 동기화 시점을 외부에서 컨트롤하게 만든다.
		이경우, "끄는 것"까지는 좋으나 다시 "켜야" 하므로, 2번 신경써야 한다.
		또한, 키는 걸 잊어버린경우, 어디서 꺼진지를 찾기란 상당히 힘들다.
		
	2. 몇개의 노드를 넣을 것인지 알린다.
		별도의 함수를 만들게 되면 아무래도 지저분한 코드가 되기 십상이고 기존에 존재하는
		insert와 혼동해서 사용하기 쉽다.
		
		push(NECollector)와 같은 함수를 이용하면 좋을 수 있겠으나 아시다시피 push는 
		virtual이 아니다. 
		따라서 오로지 이 문제를 해결하기 위해서 push를 virtual로 선언해야한다는 상황이
		되어버린다.
		
현재 상황:
	현재는 1번도 2번도 아닌, 현황유지다. 즉, 이 이슈에 대해서 직접적인 해결책이 존재하지
	않는다.
	마땅한 좋은 해결책이 없다는 것도 있지만 가장 큰 이유는, "필요가 없을 듯 해서" 다.
	
	만약 위의 상황이 벌어졌다면 노드를 일단 삽입하라. 그리고 id 정보를 변경하라.
	그리고 가만 생각해보면, 노드를 집어넣고나서 동기화된 id를 살피고, 이를 0번인덱스에서
	연관성을 획득한다고 하는 수순이 더 적합해 보이기도 한다.
	
	다만, serialize의 경우는 반드시 필요한 "본 이슈"에 해당하는 문제 인데다, 내부적으로 동기화
	on, off 스위치를 적용하면 되는 "훌륭한 해결책"이 존재하므로 이에대한 지원은 제공된다.