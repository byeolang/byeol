모듈의 생성자에서 initialize를 호출할 수 없기 때문이다.
이는 "생성자에서는 가상함수를 호출하지 말아라" 라고 하는 클래스 설계의 팁 때문이다.
모듈 하나만 등장하는 경우에는 별다른 문제가 없을 지도 모르나,
그 모듈은 다른 모듈이 상속하게 될지도 모를일이다.

상속하게 되면 문제가 복잡하게 흘러갈것은 자명하다.


그래서 이 문제를 Kernal 2012-05-03 버전에서는 _initialize를 두고, 이를 생성자에서 호출하는 방식으로 
해결하고 있다.

물론 다른 방법도 있다.
처음에 생각해낸 해결책은 모듈매니져에서 intiailize를 호출하게끔 하는 것이었으나, 이건 잘못된 생각이었다.

1. 이러한 문제의 근본적인 원인은 처음에 모듈에게는 initilize와 관한 3가지 함수가 존재했기때문이다.
그것은, "생성시 초기화 이벤트 콜", "초기화인 intiizlie", "execute"

모듈매니져에서 initilaize를 호출하게된다면, 모듈매니져에 추가되는 순간 강제로 initialize가 발생하게 될것이다.
이것은 문제를 발생하는데, 모듈매니져에 추가되는 "커널부 모듈"의 initialize에는 의존성이 존재하기 때문이다.

따라서 이방법을 고수하고자 한다면 뭔가의 방비책을 추가적으로 구현해야 한다.
커널부 모듈에서 initilize를 사용할 수 없으므로 "초기화인 initialize"와 "생성시 이벤트 콜" 부분이 합쳐져 버린것이다.
이를 나누기 위한 별도의 이벤트 핸들러를 둘 수도 있다.
예를 들면, onFetchedToModulManager와 같은 핸들러다.
그러나 다른 방법도 있다.


+ _initialize()
1. 이 함수는 단순한 메소드이므로 생성자에서 호출해도 무리가 없다.
내부적으로 수행하는 것은 만들어진 키셋의 가상함수를 사용하는 것일뿐 모듈의 가상함수를 사용하지도 않는다.

2. _release의 구조와 상당히 닮아있다. 이 구조를 이해하는데 _release의 구조를 이해했다면 쉽게 이해할 수 있다.


단점.
개발자가 이러한 부분을 신경써가면서 _initialize를 만들어야 한다는 것이다.
다시말하면, "개발자는 _onFetchedToModuleManager 이벤트에 코드를 추가하면된다" 와 "_initialize"를 만들어라"는
개발자의 입장에서는 "왜 _initalize"를 만들어야 하는가에 대한 추가적인 이해가 필요하다는 것이다.
onFetchedTo..를 쓸경우, 이해없이 직관적으로 "아 여기다 쓰면 호출될때 사용되나 보군" 하겠지만, _initialize의 경우,
왜 굳이 그렇게 해야 하는데? 라고 생각이 들수 밖에 없을 것이다.

