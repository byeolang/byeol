2012년 3월 25일
ID동기화 알고리즘의 변경

이유:	기존의 알고리즘의 문제점을 발견함	->	기존의 알고리즘은 동기화 수행 이벤트가 발생
		시 모든 노드를 검색하여 동기화를 수행하는데, 키에 대한 부분을 생각하지 못하고
		구현에서 배제되어 있었다.
		
		따라서, 노드 스크립트 셀렉터의 경우는 동기화가 수행되지 못한다.
		또한 키에 IDKey를 추가할 경우, 이것을 적용이 불가능하다.
		
해결법:	
		1) 기존의 insertNameCode()와 같은 식으로 가변적인 아이디값을 삽입/삭제 2가지 방법
		으로 제공하는 방법이다.
		이 경우, 필요한 만큼만 동기화를 수행할 수 있으므로 효율이 좋으나, 현재의 경우는
		"동기화 이벤트" 하나만 처리할 수 있는 구조를 띄고 있으므로 이것을 적용하려면
		NENode, NEManagedNodeSet, NEManagedModuleSet, StandardManagedScriptList등등..
		관련된 모든 부분의 코드를 변경해야할 필요성이 있다. (변경 범위가 넓다)
		
		2) 기존의 "동기화 이벤트"에 구조를 흔들지 않고 적용하는 방법이나 효율이 나빠서
		속도 저하가 의심되는 방법이다.
		
		여기서는 2번을 사용한다.
		
		알고리즘은 다음과 같다.
		1) 동기화 이벤트가 발생하면 (노드번호=아이디=인덱스, 주소값, 바뀌어진 ID)을 기록하는 2차원 테이블을 
		생성한다. 
		2) 테이블 기록후, 동기화를 수행한다. 이때는 노드의 데이터만 동기화가 된 상태다.
		3) 이제 다시한번 노드를 탐색하여 1번의 테이블의 3열인 "바뀌어진 ID"정보를 기록한다.
		4) 완성된 테이블을 근거로 해서 모든 키를 조사하여 "셀렉터의 코드값, IDKey"를 수정한다.
			3.1) 모든 아이디 코드값에 대해서, 
				id_belonged_to_key = new_table[id_belonged_to_key].changed_id
				를 수행한다.
				이렇게 함으로써 각 키에 변경된 아이디코드값이 적용된다.
		5) 테이블을 버린다.
		
		여기서 테이블을 완성할때 변경이 없는 행은 버리는 방법도 있으나, 속도면에서는 떨어지
		게 되므로 비추.
		
준비:	
		1) 특정 노드리스트를 스크립트 셀렉터에 넣어야 하므로, 이게 가능할 수 있도록 셀렉터를
		변경해야 한다.
			-> 노드리스트를 받는 CallStackUnit이 존재하는 노드셀렉터는 스크립트 셀렉터
			밖에 없으므로 이를 virtual 인터페이스로 할 수는 없고 스크립트 셀렉터에
			특화시키는 수밖에는 없을 것이다.
		
		2) 모듈셀렉터에 setNodeToNewPosition()를 지원해주고,
			-> 가능한가?
		3) NEKeySelector에 setModuleToNewPosition()를 지원해주자.