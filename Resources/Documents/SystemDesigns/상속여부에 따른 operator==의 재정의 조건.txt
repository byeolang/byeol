왜 이런 문제를 논해야 하는지를 먼저 말해보자.
operator=는 매 클래스에서 컴파일러가 자동적으로 생성해주는 함수다.
단, operator==같은 경우는 코더가 직접 만들어 줘야 한다. 여기서 "굳이 만들 필요가 있을까" 하고
애매해지는 상황이 벌어지는 것이다.

예를들면
A클래스에서 모든 작업을 수행하고(NECharSet)
B클래스는 Wraper클래스라고 하자. (NEString)
이때 당연히 A::==(A&)가 존재하는데 굳이 B::==를 만들어야 되나? 하는 생각이 들게된다.

1. 일반적인 경우는 B::==를 만들지 않아도 OK.
2. 다만, B에서 융통성있는 생성자 효과(... 이걸뭐라고 하나)를 노릴때는 ==를 재정의 해줘야
한다.
	-> 융통성있는 생성자 효과??
		정확한 정의를 모르므로 예제를 내보면
		NEString::NEString(int); // int를 받는 생성자.
		NEString::NEString(float); 
			.
			.
			.
		이렇게 하면 NEString::operator==(NEString&) 만 하더라도,
		
			NEString == 3.5f;
		
		같은 구문을 컴파일러가, 
		
			NEString == NEString(3.5f);
			
		로 바꾸어주어서 동작이 가능해진다. 코더는 NEString::==(float)과 같은 함수를 추가적
		으로 만들지 않아도 되므로 편하고.
	
	다만, 이 효과를 얻기 위해서는 NEString::operator==가 있어야 한다.
