<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
	<title>Wunderlist - 차후 Node 프로젝트</title>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<style type="text/css"> 
			body {font-family:"Myriad Pro", Arial, Sans-Serif}
			.wunderlist-wrapper { width:700px; margin:50px auto}
			h1, h3, p {text-align:center}
			h3 { margin-top: 30px; margin-bottom: 10px; margin-left: -10px !important; }
			h3.first { margin: 0; margin-bottom: 10px }
			p.small {font-size:14px; color:#777;}
			a {color:#2B96F1; text-decoration:none;font-weight:bold}
			a:hover {text-decoration:underline}
			ul.wunderlist { border-radius:10px;-moz-border-radius:10px;-webkit-border-radius:10px;background:#fff;border:1px solid #ddd;padding:15px 30px}
			ul.wunderlist li {padding:10px 0px 2px 20px; list-style:none; position:relative;}	
			ul.wunderlist li span{border-radius:3px;-moz-border-radius:3px;-webkit-border-radius:3px;background:#fff;border:1px solid #ddd; height:16px; width:16px; position:absolute; left:-12px;top:9px;}
			ul p {text-align:left; color:#555; font-style:italic; font-size:14px;margin-bottom:-3px;margin-top:5px;}
			* html ul.wunderlist li span {left: -30px;} /* IE 6 */
		</style>
	</head>
	<body onload="window.setTimeout('window.print()', 200);">
		<div class="wunderlist-wrapper">
			<h1>차후 Node 프로젝트</h1>
			<ul class="wunderlist"><li><span></span>노드 : DLL 파일간의 의존성 문제가 존재한다.<p>예를들어, 오그.디엘엘 파일과  그것을 재생하는 오디오.디엘엘 모듈패키지가 있다고 가정하자. <br/>이때, 오디오.디엘엘 모듈패키지는 오그.디엘엘에 묵시적 링킹하고 있기 때문에 오그.디엘엘 파일을 로드하기 전에는 <br/>모듈매니져가 바인딩에 실패하게 된다.<br/>하지만 오그.디엘엘 파일도 외부 프로젝트로부터 가져온 파일이기 때문에 이 파일 안에 모듈패키지를 위한 엔트리 포인트가 없다.<br/>따라서 모듈매니져는 어떻게 되도 오디오.디엘엘 모듈패키지를 읽을 수 없다.<br/><br/>해결법:<br/>이를 해결하기 위해서는 다음과 같은 방있다.<br/><br/>1. 프로그램 실행파일과 함께 오그.디엘엘 파일을 같은 폴더에 둔다.<br/>   하지만 배포시에 벌거롭겠지. 동시에 가장 정상적인 방법이기도 하다.<br/>2. 디엘엘을 정식으로 등록시킨다.<br/>    마소의 정책 변경으로 엑스피부터는 사이드바이사이드 바잇ㄱ을 통해서 디엘엘을 등록 사용하게 된다.<br/>   이전처럼 시스템 폴더에 한꺼번에 몰아넣는 것을 권장하지 않는다.<br/>    근데 이거 사이드-바이-사이드 만드는 방법도 모르겠고. 모듈만드는 사람들이 일일이 그런걸을 신경쓸까?<br/><br/>3. 정적링킹해버린다.<br/>   이것도 한가지 방법이기는 하다. 근데 모든 모듈을 다 정적링킹해버릴 수 ㄴ도 없는 노릇이다. 다이렉트엑스<br/>처럼 정적링킹을 지원하지 않는 경우라면 더 그렇고.<br/><br/>4. 플랫폼에서 특정폴더에 들어있는 디엘엘을 모두 읽겠다는 방침을 적용한다.<br/>예를들어. 실행파일이 있는 곳에 서브 디렉토리로 하나 지정하여 그곳에 디엘엘 파일이 있다면 언제나 링킹한다는<br/>정책을 쓰는 방법이다. <br/>이역시 좋다. 다만근본적으로는 1번방법과 다를바가 없는 방법이며, 해당 폴더안에 파일명이 동일하나 버전이 다르다면 어떻게 <br/>처리해야 하는가 와 같은 문제점들이 존쟇나다.<br/><br/>5. 내 전용의 매니페스트를 만든다.<br/>해당폴더의 모듈을 탐색하기 전에 매니페스트를 먼저 읽어서 어떠한 파일들을 강제 로드하고 어떤 모듈을 먼저 읽어드릴것인지를<br/>판단한다.<br/>이것도 좋겠지. 매니페스트를 만들어야 한다는 추가적인 모듈개발자의 부담감이 더해지지만.<br/><br/>6. 탐색하는 폴더에 "특정 이름의 독특한 폴더명" 에 들어있는 디엘엘은 무조건 읽어드린다는 약속을 한다.<br/>편하다. 1번의 확장판인데 배포도 좋다. 문제가 있다면, 이러한 방식은 그리 깔끔하다고 보기는 힘들다는 점. <br/><br/><br/>일단 현재는 1번으로만 진행을 하기로 한다.</p></li><li><span></span>노드 정적라이브러리 프로젝트도 만들것</li><li><span></span>노드 하나의 프로젝트에 솔루션을 서로 달리해서 저장하도록 할것. 오그 프로젝트처럼</li><li><span></span>찾은 웹SVN으로 여기의 노드 프로젝트들을 옮길것</li><li><span></span>버튼 리소스 그리기</li><li><span></span>노드에서 MDK의 폴더 구조가 source -&gt; Sources로 다 바꾸어야 한다.</li><li><span></span>MDK의 하위 디렉토리가 Sources가 아니라 바로 HTML등이 나오기 때문에 다른 프로젝트와 보기에 안좋다.</li><li><span></span>DirectXSound 모듈화</li><li><span></span>가끔 메세지를 끊어먹는 상황이 발생한다.</li><li><span></span>DirectXSound Ogg 모듈화</li><li><span></span>모듈화 테스트</li><li><span></span>SIG 결정하기</li><li><span></span>코드 변환 함수가 지원되지 않는다. 각 노드의 NameCode, 같은 변환은 된다. 다만, NameCode 3을 5로 바꾼다고 했을때, insertNameCode, removeNameCode로는 한계가 있다. 한계1. 이미 NameCode5에 노드가 존재하고 이것들에 NameCode3을 append 하 코드 변환 함수가 지원되지 않는다. 고 싶을때 한계2. Node를 일일이 수동으로 변경해줬다고 한다해도,  <p>코드 변환 함수가 지원되지 않는다.<br/>각 노드의 NameCode, 같은 변환은 된다. 다만, NameCode 3을 5로 바꾼다고 했을때, insertNameCode, removeNameCode로는 한계가 있다.<br/>한계1. 이미 NameCode5에 노드가 존재하고 이것들에 NameCode3을 append 하 코드 변환 함수가 지원되지 않는다.<br/>고 싶을때<br/>한계2. Node를 일일이 수동으로 변경해줬다고 한다해도, <br/></p></li><li><span></span>리스트 패널 작성</li><li><span></span>WNDDomainManipulator 패널 작성</li><li><span></span>WNDDomainManipulator 테스트</li><li><span></span>메세지 박스 패널 작성</li><li><span></span>Window 패널 작성</li><li><span></span>WNDShowManipulator 패널 작성</li><li><span></span>set, get의 혼재를 해결하라<p>대표적인 예가 Kernal::Settings로써,<br/><br/>getINIDirectory()로 set도 겸하게 만드는 함수가 있는가 하면,<br/>setModuleDirectory(), getModuleDirectory()로 구분하는 함수도 있다.<br/><br/>이렇게 된 원인에는 초기에 "1.클래스는 get만, 2. primitive는 set,get"<br/>이라는 원칙을 세우고 작업을 했기때문이다.<br/>작업 도중, set,get을 다른 정책을 두고 적용하는 것 보다는, 클래스도 모두 set,get을 쓰는게 더 가독성 있지 않겠냐는 생각때문에 변경전과 변경 후가 혼재하고 있는것.<br/>어느쪽이든 통일 시키는 게 시급하다.<br/> </p></li><li><span></span>MouseSpy 패널 작성</li><li><span></span>버전을 정식으로 0.0.1 alpha로 전부다 변경하라. DLL의 속성도 포함해서</li><li><span></span>노드의 주소만으로도 삭제가 가능한, 효율좋은 방법을 구상해야 할것이다.</li><li><span></span>웹 SVN 붙임</li><li><span></span>test5에서 오류 발생</li><li><span></span>모듈셀렉터에서, STL 처럼 필터링에 해당하는 함수를 외부에서 지정할 수 있도록 하자. 그렇게 함에따라서 외부에서 지역클래스를 통해 지정할 수 있도록.</li><li><span></span>추가작업을 여기에 추가해놓기</li><li><span></span>모듈의 identifier가 seriailze시 일치하지 않을경우 시스템이 굉장히 취약해짐</li><li><span></span>ListModule과 WND 모듈을 보면 알겠지만, 이미 키가 있는 모듈을 상속하는 모듈의 경우, 부모모듈의 키가 몇개인지 알수가없다. 헤더를 구하는 방법은 너무 돌아가는 방법이며 동적으로 구할수 밖에 없다. 왜냐하면 getHeader가 static이 아니기 때문이다. 그렇다고 static 메소드는 virtual이 되지 않는다. 이를 해결할 수 있는 방법이 없을까? 하다못해 define WND_KEY_NUMBER로 define.hpp를공개하던가.</li><li><span></span>웹상에서 제공되는 SVN를 살펴볼것. GitHub가 좋겠다만.</li><li><span></span>ElementExtractor 패널 작성</li><li><span></span>ListModule과 WND 모듈을 보면 알겠지만, 이미 키가 있는 모듈을 상속하는 모듈의 경우, 부모모듈의 키가 몇개인지 알수가없다. 헤더를 구하는 방법은 너무 돌아가는 방법이며 동적으로 구할수 밖에 없다. 왜냐하면 getHeader가 static이 아니기 때문이다. 그렇다고 static 메소드는 virtual이 되지 않는다. 이를 해결할 수 있는 방법이 없을까? 하다못해 define WND_KEY_NUMBER로 define.hpp를공개하던가.</li><li><span></span>ScriptFileLister 패널 작성</li><li><span></span>셀렉터. STL처럼 외부에서 지정하는 필터링</li><li><span></span>Logic  패널 작성</li><li><span></span>모든 selector 및 추출하는 곳에 지역클래스를 활용한 함수필터링 기법을 채택한다. 이를 CUIHandler에서 NEModule&amp; getQuickModule( functionPtr ) 처럼 사용해서, 주어진 함수에 일치하는 모듈만을 리스트의 형태로 핸들러에서 출력하고, 이를 선택한 모듈의 주소를 넘겨받는 식으로 작성해 보자.</li><li><span></span>NodeSaver 패널 작성</li><li><span></span>CUI핸들러에서 modifyKey중, ByteKey를 2를 넣으면 이걸 char로 해석해버려서 50이 되버림. CUI에서 ByteKey는 처리를 따로 해줬다. 단, ByteSetKey는 아직 안했음. 나중에 할것.</li><li><span></span>각 표준 모듈의 패널 작성</li><li><span></span>스크립트 런타임 include, exclude 기능의 구현 알고리즘<p>스크립트의 include, exclude를 사용한다.<br/>스크립트 매니져와 노드매니져에 각각 해당 인터페이스를 넣고 스크립트는 1차원의 배열이나 인클루드한 스크립트 파일에 따라서 가상의 공간을 나눈다. 그리고 그 나눠진 공간의 작업이 끝났을때 스크립트 개발자의 입력으로부터 공간을 해제한다.<br/><br/>이때 주의해야 할점은 노드공간을 해제시 스크립트 공간도 해제되어야 한다는 점이다. 왜냐하면 지운 스크립트 등에서 createNode와 같은 모듈이 있을수도 있다.<br/><br/>또는,<br/><br/>노드매니져만 해제하는 경우는 문제가 없으나, 이때도 스크립트를 해제시키는 것이 좋다는 것이다.</p></li><li><span></span>ElementInserter 패널 작성</li><li><span></span>리스트 클릭 이벤트 캐치 모듈</li><li><span></span>WNDShowManipulator 테스트</li><li><span></span>FrameCounter 테스트</li><li><span></span>NodeFileLister 테스트</li><li><span></span>NodeCollector 패널 작성</li><li><span></span>ErrorSpy 패널 작성</li><li><span></span>Logic 테스트</li><li><span></span>-&gt; 해결책 제시. 템플릿인자에서 NEType을 제거하는 것이다. 그렇게 해야할지 결정하라. 이걸 하기위해서는 NEKey.assign에서 사용했던 정책인 "자료형으로 구분하지 말고, 사용용도로 구분한다. 즉, char와 byte를 구분한다" 라고 하는 부분을 개선해야만 한다.</li><li><span></span>initializeNodeSelectorPosition()하게 되면 _noder도 &lt;-- Kernal::NodeManager로 변경되기 때문에 한번 실렉터가 돌고나면 setNodePosition이 초기화되버리고 만다.</li><li><span></span>FrameCounter 패널 작성</li><li><span></span>Extender 패널 작성</li><li><span></span>ElementExtractor 테스트</li><li><span></span>NameChanger 테스트</li><li><span></span>IfElese 패널 작성</li><li><span></span>ScriptFileLister 테스트</li><li><span></span>GroupChanger 패널 작성</li><li><span></span>ModuleEnabler 테스트</li><li><span></span>Assigner 테스트</li><li><span></span>int와 같은 primitive 멤버변수도 NETString&amp; getString 처럼, type_code&amp; getCountLimit로 하는게 어때? 일관성 있잖아?<p>int와 같은 primitive 멤버변수도 NETString&amp; getString 처럼, type_code&amp; getCountLimit로 하는게 어때? 일관성 있잖아?</p></li><li><span></span>Assigner 패널 작성</li><li><span></span>ModuleEnabler 작성</li><li><span></span>IfElese 테스트</li><li><span></span>에러가 발생할 수 있는 bool은 type_result로 해놓고 RESULT_TRUE, RESULT_FALSE를 사용해야 한다. 예를 들면, boolNEKey::operator&gt;(NEKey&amp; source) { return ! isLower(source) &amp;&amp; ! isEqualTo(source); } 로 되어있는데,  NodeSelector1 &gt; NodeSelector2를 하게되면 isLower(NodeSelector) = flase, NodeSe<p>에러가 발생할 수 있는 bool은 type_result로 해놓고 RESULT_TRUE, RESULT_FALSE를 사용해야 한다.<br/>예를 들면,<br/>boolNEKey::operator%3E(NEKey&amp; source)<br/>{<br/>return ! isLower(source) &amp;&amp; ! isEqualTo(source);<br/>}<br/>로 되어있는데, <br/>NodeSelector1 %3E NodeSelector2를 하게되면<br/>isLower(NodeSelector) = flase,<br/>NodeSelector1 != NodeSelector2이므로<br/>결과적으로 true가 나오게 된다. 이는 잘못된 값이다. 올바른 값은 <br/>RESULT_TYPE_ERROR가 나오는것.<br/></p></li><li><span></span>에 concate 함수 추가하기</li><li><span></span>NameChanger 패널 작성</li><li><span></span>If 패널 작성</li><li><span></span>NodeLoader 테스트</li><li><span></span>NENodeIdKey가 수정될때 synchronize가 안되는건 그렇다고 쳐도 뭔가 대책을 세워줘야 하는거 아닌가?</li><li><span></span>콜렉터에서도 ++, --도 지원했으면 좋겠다.</li><li><span></span>NEScriptManager로부터 선택을 아이디를 통한 getElement방식을 사용한다</li><li><span></span>NodefileLister 패널 작성</li><li><span></span>모듈끼리 operator=가 되는 경우, connector가 존재하는 모듈은, _connector = source._connector가 되어서는 안된다. 그런데 모듈에 operator=를 정의하지 않으면 자동으로 컴파일러가 shallow copy 하도록 operator=를 만들지 않는가.</li><li><span></span>FileLister 테스트</li><li><span></span>NodeLoader 패널 작성</li><li><span></span>Editor의 관리자급 클래스도 역시, serialize가 되도록 하자. Editor를 보면 serialize가 비어있음</li><li><span></span>Enabler 패널 작성</li><li><span></span>NEKeyTemplate에서 T가 collector일경우에는 assign(index, Key), Key&amp; extract(index), insert(index, Key), remove(index)를 제공하라. 이를 위해서는 TemplateChecker::isCollector를 4번째 인자로 사용, 이를 부분 특수화 시킴으로 동작시켜야 할것이다.</li><li><span></span>NodeRemover 패널 작성</li><li><span></span>가능하다면, 노드 커널부분과 일반 모듈 부분을 분리해서 솔루션을 작서앟라</li><li><span></span>ModuleCollector 패널 작성</li><li><span></span>Extender 테스트</li><li><span></span>PriorityChanger 패널 작성</li><li><span></span>ElementInserter 테스트</li><li><span></span>모듈헤더에 각 키 혹은 컴포넌트별로 정보를 입력할 수 있도록 하는 게 좋다. 내가 만들어보니까. comment 변수 하나로는 모든 정보입력하는 게 좀 까다롭네.<p>모듈헤더에 각 키 혹은 컴포넌트별로 정보를 입력할 수 있도록 하는 게 좋다.<br/>내가 만들어보니까. comment 변수 하나로는 모든 정보입력하는 게 좀 까다롭네.<br/></p></li><li><span></span>NEMoudleSelectorInterface : public NodeSelectorInterface 처럼 하지 말고, NodeSelectorInterface&amp; ModuleSelectorInterface::getNodeSelector()를 하면 어때?<p>NEMoudleSelectorInterface : public NodeSelectorInterface 처럼 하지 말고, NodeSelectorInterface&amp; ModuleSelectorInterface::getNodeSelector()를 하면 어때?</p></li><li><span></span>Looper 패널 작성</li><li><span></span>If 테스트</li><li><span></span>ElementRemover 패널 작성</li><li><span></span>NodeRemover 테스트</li><li><span></span>PriortiyChanger  테스트</li><li><span></span>Module -&gt; WindowModule로 캐스트 하는 과정이 identifier를 확인하는등.. 복잡하다. 좀더 단순화 시킬 수 어는 없을까?</li><li><span></span>NodeCreator 패널 작성</li><li><span></span>NodeSaver 테스트</li><li><span></span>NEStringList에도 split, extract를 넣을것</li><li><span></span>-	셀렉터의 변경은 핸들러에서 담당하는 것으로 바뀌었다. 그러나 제한/권한 설정은 현재로써는 불가능하다.  	예를 들면, 노드코드가 Group, Script만 된다던가, CodeSet이 3개 이상만 된다던가. 이러한 설정을 어떻게 하지<p>-	셀렉터의 변경은 핸들러에서 담당하는 것으로 바뀌었다. 그러나 제한/권한 설정은 현재로써는 불가능하다. <br/>	예를 들면, 노드코드가 Group, Script만 된다던가, CodeSet이 3개 이상만 된다던가. 이러한 설정을 어떻게 하지<br/></p></li><li><span></span>Enalber---&gt; NodeEnabler로 개명</li><li><span></span>ErrorSpy 테스트</li><li><span></span>GroupChanger 테스트</li><li><span></span>에러를 처리하는 방식에 대한 명확한 기준이 필요한것 같다. A::fun1()를 하자 여러개의 함수를 거쳐서 B에 도착했다. B에서 처리하는 도중 에러가 발생했다. 근데 이 에러는 A의 시점에서 미리 발견할 수 있으며, A에서 처리하는 것이 무엇보다 효율적이다. 하지만 각각 분산되어 B에서 에러를 처리하는 모양새가 더 깔끔하다.  2번째 케이스---&gt; A::operator==가 호출되면 B::operator==가 호출되고 C::operator==가 호<p>에러를 처리하는 방식에 대한 명확한 기준이 필요한것 같다. A::fun1()를 하자 여러개의 함수를 거쳐서 B에 도착했다. B에서 처리하는 도중 에러가 발생했다. 근데 이 에러는 A의 시점에서 미리 발견할 수 있으며, A에서 처리하는 것이 무엇보다 효율적이다. 하지만 각각 분산되어 B에서 에러를 처리하는 모양새가 더 깔끔하다. <br/>2번째 케이스---%3E A::operator==가 호출되면 B::operator==가 호출되고 C::operator==가 호출된다. 각각의 함수에서는 if(this==&amp;source)를 비교하는 코드가 들어가 있다.<br/>낮음완료되지 않은잘못되었던 operator=와 operator==의 개념. 자세한 내용은 resource/document 참조해서 읽어보고, 보다 맞다고 생각되는 쪽으로 고치자.<br/></p></li><li><span></span>Looper 테스트</li><li><span></span>NEFileSystem에서 FindFirstFile에러 에러발생시 자동으로 PopUpMessageBox 윈도우가 발생한다. 이거 없애는 방법은 없을까?</li><li><span></span>함수명과 변수명에 change와 set을 구분해서 사용했으면 좋겠다. set은 값 자체의 변경. change는 값이 변경되고 그것이 적용.</li><li><span></span>윈도우모듈을 네임스페이스로 감싸기</li><li><span></span>NEScriptManager로부터 선택을 아이디를 통한 getElement방식을 사용한다. 대신 selecter를만들어서 지원하게 하라.그렇게되면 아이디 이외에도 그룹코드등을 사용해서관련스크립트를 다가져오는것이 가능하다.</li><li><span></span>에디터 패키지에서 serialize는 지원하지 않는다. 삭제하라.</li><li><span></span>1프로젝트가 다른 솔루션에 있어도 디버깅이 가능한가?</li><li><span></span>노드엔진에서 NEFileSystem::TaskUnit에서 324, 357, 358, 214, 252, 292, 538에서 size_t가 type_index로 캐스팅되면서 생긴 데이터 손실 경고 처리</li><li><span></span>NENode의 소멸자에도 unenroll을 자동으로 호출한다. 그런데 NEManagedNodeSet에서도 소멸시 노드를 unenroll 시킨다. 이거 쓸데없는 중복작업 아닌가?</li><li><span></span>리센트 셀렉터를 로컬셀렉터로 개명</li><li><span></span>operator연산자 오버로딩에서 쓸데없는 경우는 상위클래스로부터 연산자오버로딩을 상속하라</li><li><span></span>로그 시작시에, 시스템 정보와 커널정보를 출력할 수 있도록 하라</li><li><span></span>NEAbstractKeySelector처럼 일반적인 셀렉터를 제공할 수 있다면 좋을텐데</li><li><span></span>NETextComponentPreset로 이루어진 미리 정의된 클래스 템플릿</li><li><span></span>using::operator=;는 사용할때 생각을 잘 해봐야 한다. 왜냐하면 리턴값의 타입이 상위 클래스가 나오기 때문이다</li><li><span></span>ElementRemover 테스트</li><li><span></span>ModuleEnabler 패널 작성</li><li><span></span>그랜드 루트 노드를 참조할 수 있는 로컬스택. 그리고 Parent노드, 노드셋노드를 참조할 수 있는 로컬스택</li><li><span></span>Kernal를 비롯한 매니져클래스들의 serialize 조치.</li><li><span></span>CANCEL 가능한 패널 및 다이얼로그</li><li><span></span>Identifier에서 String 한개로 "모듈이름", "개발자", "개정버전"을 다 fetch 하는 기능이 꼭 필요하다.</li><li><span></span>Dialogue가 아니라 Dialog</li><li><span></span>각 프로젝트별로 히스토리를 만들어야 하나? 어떻게 하면 좋은지 표준안을 통일 시키자.</li><li><span></span>왜 로그파일은 UNICODE가 아니라 ANSI 인가</li><li><span></span>isEnable() 검사. Kernal이나 Editor에 뺀호은 부분이 있지는 않은가?</li><li><span></span>블로그 형태의 책과 노드엔진 책, secret 음악 책을 추가해볼지 생각중</li><li><span></span>스크립트 셀렉터는 저장이 되는가?</li><li><span></span>MDK 마무리작업(버전관리 등등)</li><li><span></span>NETextComponentPreset과 같은 클래스 템플릿은 NE_DLL로 선언되어서, 에디터 및 커널에 정의되어있는 템플릿 클래스만 외부에서 사용할 수 있다.</li><li><span></span>Priority를 PriorityCode로 통일</li><li><span></span>식별자로써 이름이 아니라, 안드로이드처럼 식별자문자열("android.sample.Sample01")와 같은 걸 쓰는 건 어때?</li><li><span></span>NETYpe에서 innerclass: 란을 없애고, 철저하게 상속에 의거해서 재배치</li><li><span></span>모듈있는 네임코드를 어떻게 부여할 거지? 이걸 어떻게 seriailze 하나?</li><li><span></span>에러메세지가 나와야 하는 부분은 골격자체는 만들어놓기</li><li><span></span>그랜드 루트 노드를 참조할 수 있는 로컬스택을 이용하여, 이를 이용하는 리센트셀렉터의 추가</li><li><span></span>접근자에서 널의 레퍼런스를 반환할때 ALERT_WARNING 혹은 INFORMATION을 울리도록 하는건 어떤가. 대신 이때는 디버그가 initialize되고 나서 울려야 한다는 전제조건이 있다.</li><li><span></span>NEScriptSynchronizer와 NEScriptManager를 합치고, script의 synchronize를 외부 유저가 알아차리지 않아도 되겠끔 고쳐 라</li><li><span></span>module::serialize시 중복해서 initialize()를 호출, 퍼포먼스가 하락한다. 근데 아직은 보류하기로 했음. initilize를 없애기는 좀..</li><li><span></span>FileLister 패널 작성</li><li><span></span>커널이건, Editor의 모든 빌트인 모듈에서 isEnable()이면 false일경우 동작하지 않도록 되어 있는가?</li><li><span></span>로케일 지원</li><li><span></span>온갖곳에서 노드안의 모듈셋과 노드셋을 탐색하는 코드가 사용된다. 이걸 대표하는 하나의 셀렉터를 만들어서 효율을 높을 수는 없을까?</li><li><span></span>Window -&gt; MouseSpy 처럼, Window 모듈의 serialize가 되면 언제 인스턴스를 만들어야 하는가. serialize때마다 Window에서 createWindow를 하게 되면 스크립트를 로드할때도 윈도우가 새성되고 만다</li><li><span></span>NEModuleSet의 새로운 정의</li><li><span></span>같은 컴포넌트가 2개의 다이얼로그를 연속으로 내보낼 수 없다는 점을 수정하라</li><li><span></span>String 클래스에 tokenize 함수 추가. 이경우, NEWStringSet을 tokenize 리턴값으로 해야하나? 가능하나?</li><li><span></span>TemplateKey에 List 형태도 지원?</li><li><span></span>커널 스위칭</li><li><span></span>ModuleHeader에 module_dependencies는 StringSet이면 안되잖아. Identifier로 해야지.</li><li><span></span>구현 idea 1. ModuleSelector에서 getModule(NEModule&amp;mod)를 지원하는건? 이렇게 하면 NEModule*를 저장할 수 있게 된다.</li><li><span></span>위에 걸 하기 위해서는 당연히 NEString시리즈에서 split 이나 tokenize를 제공해야 함. sub나 mid도 있음 좋겠다.</li><li><span></span>Editor패키지가 로드되면 뭔가 표시가 나면 좋겠다.</li><li><span></span>MDK에 버그가 존재한다 -&gt; Execute 해제가 안됨</li><li><span></span>현재의 설계로는 NEPanelSet을 그대로 노출하게 되므로 외부에서 NEPanelSet.release()를 해버릴 수도 있는 보안에 치명적인 허점이 있다.</li><li><span></span>MDK와 레퍼런스사이트간에 버전관리 페이지 연동</li><li><span></span>컴파일러가 기본으로 생성하는 함수들(생성자, 소멸자, 할당연산자)를 그래도 표기를 할것인가...아닌가.</li><li><span></span>NEList에서 _getBeforeTail이 한번도 사용되지 않는다.</li><li><span></span>isValid혹은 operator==등에서 에러가 발생하거나 false가 뜨면 ~~~때문에 그래 하면서 ALERT 해주기</li><li><span></span>자동생성되는 생성자 명시 안함?</li><li><span></span>NEDebug에서 log기록시 파일이 이미 존재했을때 에러처리</li><li><span></span>유니코드 관련 코드를 NEFileSystem 혹은 NEFileAccess에 넣기</li><li><span></span>extractor 혹은 path의 dev.dbg 붙이는 규칙을 통일. 어디서는 dev.dbg.ini라 하고, 어디서는 script.dev.dbg라 하네</li><li><span></span>커널에서 널이 나오는 객체의 에러판단</li><li><span></span>NEPanel과 NEModule에서 serialize(loader)에서 꼭 initialize안해도 될것 같은데</li><li><span></span>에디터 패키지가 로드되는 순간, 무슨 패널 및 모듈때문에 로드 되었다는 메세지가 나타나면 좋을듯</li><li><span></span>INI 포맷 정하기</li><li><span></span>외부로부터 Target을 settable 하는 유연해진 셀렉터</li><li><span></span>ADT 들도 역시 연산자 오버로딩이 있어야 한다</li><li><span></span>왜 cin &gt;&gt;NETString.toCharPointer()가 안되는 걸까?</li><li><span></span>커널의 인터페이스들의 연산자 오버로딩을 어떻게 해야 하지????</li><li><span></span><a href="http://support.microsoft.com/kb/99456/ko">http://support.microsoft.com/kb/99456/ko</a>를 참고해서 WINAPI를 CRT로 바꾸기</li><li><span></span>콜렉터에 T* [] {1, 3,..} 같은 생성자도 지원할 수 있으면 좋겠다</li><li><span></span>pure Virtual을 중복선언이 가능한가? 예를 들면, 상위클래스에서도 선언하고 하위클래스에서도 선언하고?? 된다면 표기해주는 편이 좋겠네.</li><li><span></span>셀렉터의 설계를 다시 수정-----&gt;이거 추가작업으로 빼자.</li><li><span></span>작업 NENodeSelectorDialogue와 NEModuleSelectorDialogue에서 initiate가 서로 충돌하는 현상</li><li><span></span>바뀌어진 설계를 적용한 runnable.</li><li><span></span>Dialog를 필수 에디트 모듈쪽으로 빼야 할것이다.</li><li><span></span>NEMoudleSelectorInterface : public NodeSelectorInterface 처럼 하지 말고, NodeSelectorInterface&amp; ModuleSelectorInterface::getNodeSelector()를 하면 어 때?</li><li><span></span>ModuleSelector나 NENodeSelector에서 getModuleSet()를 지원하는건?</li><li><span></span>잘못되었던 operator=와 operator==의 개념. 자세한 내용은 resource/document 참조해서 읽어보고, 보다 맞다고 생각되는 쪽으로 고치자.</li><li><span></span>MDK에서 에러코드를 추가하는 페이지를 추가</li><li><span></span>NEStringSet에 concate 함수 추가하기</li><li><span></span>Iterator나 모듈셀렉터의 getModule()를 사용하는 경우, NEModule* module = NE_NULL; while( module = &amp;(selector.getModule()) ) 과 같은 코드가 더 깔끔하다</li><li><span></span>int와 같은 primitive 멤버변수도 NETString&amp; getString 처럼, type_code&amp; getCountLimit로 하는게 어때? 일관성 있잖아?</li><li><span></span>할당연산자에서 반환값 const 빼기</li><li><span></span>모듈과 패널을 나누어서 프로젝트를 작성할 수 있도록 해야한다.</li><li><span></span>콜스택의 구현이 가능한 ALERT_ERROR 알고리즘. 만약, if(NEResult::hasError(result)) ALERT_ERROR("\t at ....(35)") 와 같은 코드를 반복적으로 이용해본다면?</li><li><span></span>MDK에서 GUI부분을 손봐서, 패널 프로젝트인지 모듈 프로젝트인지 확실하게 선 택하게 만들어야 한다.</li><li><span></span>Collector에서 push(NECollector)를 놓는게 NEStack::push(NEStack)보다 좋겠다</li><li><span></span>ModuleDirectory의 맨 마지막이 /이면, / 지우는 코드.</li><li><span></span>KeySelector, ModuleSelectorTemplate등에서 NETYpe을 파라메터 타입으로 주자. 그게 더 좋은 코딩인 것 같다.</li><li><span></span>모듈을 내보낼 수 있는 new item templates을 작성하라</li><li><span></span>NEModuleSet에서도 execute를 쓴다. 이 참에 execute를 NEExecutable로 빼?</li><li><span></span>콜렉터에 템플릿특화시 NEType을 파라메터된 변수로 수정할것</li><li><span></span>패널이나 모듈만 나오게끔 만들어져 있으므로, MDK 폴더구조를 변경하라.</li><li><span></span>모듈의 네임코드는 전혀 관리가 안되잖아!</li><li><span></span>여유가 된다면 지금까지 만들었던 패널과 모듈의 구조도 변경해야 한다.</li><li><span></span>CommonMoudleSelector는 안되는 거야?</li><li><span></span>묵시적DLL 링킹을 하고도, runnable과 같은 폴더에 넣지 않아도 되게 하는 테크닉을 문서화</li><li><span></span>에러를 처리하는 방식에 대한 명확한 기준이 필요한것 같다. A::fun1()를 하자 여 러개의 함수를 거쳐서 B에 도착했다. B에서 처리하는 도중 에러가 발생했다. 근데 이 에러는 A의 시점에서 미리 발견할 수 있으며, A에서 처리하는 것이 무엇보다 효율적이다. 하지만 각각 분산되어 B에서 에러를 처리하는 모양새가 더 깔끔하다. 2번째 케이스---&gt; A::operator==가 호출되면 B::operator==가 호출되고 C::operator==가 호</li><li><span></span>INI에서 디버그의 플래그(printConsole, printMessageBox등등을 0 ~ 15의 숫자로 표현하는데, 이걸 false 등으로 수정하기 쉽게 변환해보자.</li><li><span></span>여태까지는 void set~~(); 처럼 변경자 함수 뒤에는 void로 했는데 주어진 인자 의 valid 여부를 판단할 필요가 있다. 따라서 type_result set~~~() 처럼 하는게 어때?</li><li><span></span>위임을 하되, 프록시함수를 만드는 것이 아니라 객체를 제공하게.</li><li><span></span>MDK에서 패널프로젝트를 생성한 경우, 어딘가에 있을 모듈 프로젝트를 링크하 여 자동으로 #include &lt;&gt;할수 있게 만들어야 빌드가 된다.</li><li><span></span>콜렉터에서도 ++, --도 지원했으면 좋겠다.</li><li><span></span>MDK를 GUI부터 해서 완벽하게 패널과 모듈 분리형태로 만들어라</li><li><span></span>NEStringList에도 split, extract를 넣을것</li><li><span></span>모듈의 getErrorMessage를 사용하는 ErrorSpy가 있는데, 메세지만 보고는 각 에러의 대한 설명이 충분치 않을 수 잇다.</li><li><span></span>Settings와 ModifiableSettings는 제대로된 설계가 아니다. 그 증거로, Editor::ModifialbeSettings에는 IsLoadFromINI()라는 settings의 함수를 중복해서 정의하고 있다.이걸 제대로 설계해보자.</li><li><span></span>SystemManager같은 걸 심어놓아서, 메모리 사용량이나, 기동중인 PC의 스펙등을 알게 할수 있으면 좋겠다.</li><li><span></span>다음처럼 바꾸어라. NEString(bool data); 아니라, NEString(const bool data); 가 되야한다.</li><li><span></span>Window에 접근하는 상위클래스를 만들어라</li><li><span></span>노드셀렉터 뿐만 아니라 모듈 셀렉터, 키셀렉터도 getType을 특수화시키자.</li><li><span></span>getErrorMessage와 자연스럽게 연동이되는 ALERT_ERROR. 현재는 getErrorMessage와 ALERT_ERROR을 각각 따로 적어줘야하는 식으로 돌아가고 있다. 이걸 바꿀 수 있는 방법은 없는 걸까. 어느 한쪽에 적어놓고 다른쪽에서는 연동하는 방법이 있다면 참 좋을 텐데.</li><li><span></span>split에 NESTringList 추가-----&gt; 취소 대신 NEList &lt;---&gt; NEStack를 변환 가능하게 하는 코드를 넣어서 나중에 최적화 하기로</li><li><span></span>모듈은 없는데 패널만 있는 경우, ALERT_ERROR를 사용할 수 없다. 해결책은?</li><li><span></span>_initialize를 생성자에서 호출하는 방식으로 하지말고, 모듈들에 필요한 이벤트핸들러가 많이 있을테니 그걸 다 추가하면서 동시에 _onModuleFetched도 만들어서 해결해 보자.</li><li><span></span>MDK에서 커넥터를 모듈.cpp에 합치지 말고 따로 분리할것. [! module_name] 매크로를 사용해서 [! module_name]Connector.cpp를 생성해야 한다. inf 파일로부터.</li><li><span></span>패널과 실행모듈이 한데 묶일 수없으니 이를 MDK에서 분리해서 만들것. 그리고 ModuleName.hpp도 없애야 한다.</li><li><span></span>그 클래스에 상속받는 MouseSpy와 ...Spy</li><li><span></span>모듈의 id를 serialize 할때, id를 int로 serialize하기 때문에 모듈매니져에서 순서가 바뀌면 id는 일치하지 않게 됨</li></ul>
			<p class="small">
					These tasks are generated with Wunderlist
			</p>
		</div>
	</body>
</html>