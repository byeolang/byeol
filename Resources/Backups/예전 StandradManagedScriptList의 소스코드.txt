#include "../../NEStandardScriptEditor.hpp"
#include "../../../define/define.hpp"

namespace NE
{
	NE_DLL NEStandardScriptEditor::StandardManagedScriptList::StandardManagedScriptList()
		: NEManagedScriptList()
	{
		_release();
	}

	NE_DLL NEStandardScriptEditor::StandardManagedScriptList::StandardManagedScriptList(const StandardManagedScriptList& source)
		: NEManagedScriptList(source)
	{
		_assign(source);
	}

	NE_DLL NEStandardScriptEditor::StandardManagedScriptList::~StandardManagedScriptList()
	{
		
	}
	
	NEStandardScriptEditor::StandardManagedScriptList NE_DLL &NEStandardScriptEditor::StandardManagedScriptList::operator=(const StandardManagedScriptList& source)
	{
		NEManagedScriptList::operator=(source);

		return _assign(source);
	}

	bool NE_DLL NEStandardScriptEditor::StandardManagedScriptList::operator==(const StandardManagedScriptList& source) const
	{
		if(this == &source) return true;
		if(NEManagedScriptList::operator!=(source)) return false;
		if(_banks != source._banks) return false;

		return true;
	}

	bool NE_DLL NEStandardScriptEditor::StandardManagedScriptList::operator!=(const StandardManagedScriptList& source) const
	{
		return !(operator==(source));
	}

	
	type_code NE_DLL NEStandardScriptEditor::StandardManagedScriptList::getMaxNameCodeIndex() const
	{
		return getBanks().getNameBank().getLengthLastIndex();
	}

	type_code NE_DLL NEStandardScriptEditor::StandardManagedScriptList::getMaxScriptCodeIndex() const
	{
		return getBanks().getScriptBank().getLengthLastIndex();
	}

	type_code NE_DLL NEStandardScriptEditor::StandardManagedScriptList::getMaxGroupCodeIndex() const
	{
		return getBanks().getGroupBank().getLengthLastIndex();		
	}

	type_code NE_DLL NEStandardScriptEditor::StandardManagedScriptList::getMaxPriorityCodeIndex() const
	{
		return getBanks().getPriorityBank().getLengthLastIndex();
	}
	
	NEManagedScriptList::Banks NE_DLL &NEStandardScriptEditor::StandardManagedScriptList::getBanks()
	{
		return _banks;
	}

	const NEManagedScriptList::Banks NE_DLL &NEStandardScriptEditor::StandardManagedScriptList::getBanks() const
	{
		return _banks;
	}
	
	type_result NE_DLL NEStandardScriptEditor::StandardManagedScriptList::initialize()
	{
		release();
		
		//	메인 노드를 추가하기 위한 뱅크 초기화:
		_banks.initialize();
		
		push(NENode()); // 0번 노드(메인 노드) 추가 
		
		return RESULT_SUCCESS;
	}
	
	type_result NE_DLL NEStandardScriptEditor::StandardManagedScriptList::insert(type_index index, const NENode& source)
	{
		//	pre:
		type_result result = NEManagedScriptList::insert(index, source);		
		if(NEResult::hasError(result))
			ALERT_WARNING_IN_SPECIFIED_MODULE(NEExportable::Identifier(_NAME, _DEVELOPER, _REVISION), " : 일단 synchronize 실시")
		//		노드 등록:
		//			타겟팅:		
		NENode& target = getElement(index);
		//			결과 코드 분석:
		if( ! &target )
		{	
			ALERT_WARNING_IN_SPECIFIED_MODULE(NEExportable::Identifier(_T(_NAME), _T(_DEVELOPER), _REVISION), "W110031C6 : 더미노드의 숏컷 등록 에러 - 2\n주어진 노드가 더미노드(NEType::UNDEFINED)이기에, 숏컷에 등록하지 않습니다.\n프레임 카운트 : %d\t삽입 시도한 인덱스 : %d", Kernal::getInstance().getNodeManager().getLocalStack().getFrameCount(), index)
			return result;
		}
		
		
		
		//	main:
		//		ID 동기화:
		_onAfterInsertBeforeEnroll();
		//		등록:
		_onEnroll(target, false); // _onEnroll 내부에서 서브노드셋 탐색을 실시한다.



		//	post:
		//		메소드 캐스팅:
		EnrollmentMethod casted_method = static_cast<EnrollmentMethod>(&NEStandardScriptEditor::StandardManagedScriptList::_onEnroll);

		return _searchModuleSet(target.getModuleSet(), casted_method, this);
	}
	
	type_result NE_DLL NEStandardScriptEditor::StandardManagedScriptList::remove(type_index index)
	{
		NENode& node = getElement(index);
		if( ! &node)
		{
			ALERT_ERROR_IN_SPECIFIED_MODULE(NEExportable::Identifier(_T(_NAME), _T(_DEVELOPER), _REVISION), " : ")
			return RESULT_TYPE_ERROR;
		}




		//	main:
		//		파고들기:
		//			메소드 캐스팅:
		EnrollmentMethod casted_method = static_cast<EnrollmentMethod>(&NEStandardScriptEditor::StandardManagedScriptList::_onUnenroll);
		_searchModuleSetWithReverseDirection(node.getModuleSet(), casted_method, NE_NULL);
		//		자신을 마지막에 해제:
		_onUnenroll(node, false);



		//	post:
		NEManagedScriptList::remove(index);
		
		_onAfterRemoveAndUnenroll();
		
		return RESULT_SUCCESS;
	}
	
	type_result NE_DLL NEStandardScriptEditor::StandardManagedScriptList::insertNameCode(type_code new_namecode)
	{
		//	pre:
		//		타겟팅:
		Editor& editor = Editor::getInstance();
		if( ! &editor)
		{
			ALERT_ERROR_IN_SPECIFIED_MODULE(NEExportable::Identifier(_NAME, _DEVELOPER, _REVISION), " : ")
			return RESULT_TYPE_ERROR;
		}
		NEScriptEditor& scripted = editor.getScriptEditor();
		if( ! &scripted)
		{
			ALERT_ERROR_IN_SPECIFIED_MODULE(NEExportable::Identifier(_NAME, _DEVELOPER, _REVISION), " : ")
			return RESULT_TYPE_ERROR;
		}
		NEManagedScriptList& scriptlist = scripted.getManagedScriptList();
		type_code max_namecode = scriptlist.getMaxNameCodeIndex();		
		NEManagedScriptList::Banks& banks = scriptlist.getBanks();
		if(new_namecode < 0 || new_namecode > max_namecode + 1)
		{
			ALERT_ERROR_IN_SPECIFIED_MODULE(NEExportable::Identifier(_NAME, _DEVELOPER, _REVISION), " : ")
			return RESULT_TYPE_ERROR;
		}



		//	main:
		//		이미 존재하는 스크립트들의 코드를 변경할 필요가 있다면:
		//			push의 경우는 Bank의 크기만 늘려주면 된다
		if(new_namecode < max_namecode)
		{	//		삽입이라면:	
			//			새로 생성과는 다르게 기존에 존재하는 데이터를 한칸씩 뒤로 밀어서 자리를	만들어야 한다.
			//			값옮김의 대상은 다음과 같다.
			//				1	노드의 코드데이터
			//				2	노드 셀렉터의 코드셋 데이터
			//			새로 생성하는 경우는 이 과정을 거치지 않아도 된다.
			//			셀렉터 설정:
			
			NEScriptSelector node_selector;
			node_selector.setNodeType(NECodeType::ALL);
			NENode* node = NE_NULL;
			while( node = &(node_selector.getNode()) )
			{
				//			새로운 노드라면:
				//				코드 확인:	
				//					배열(Array)이 삽입될때 처럼, 파라메터의 index와 같거나, 보다 큰 스크립트코드만 ++를 해야한다.
				type_code namecode = node->getNameCode();
				if(namecode >= new_namecode)
					_setNameCode(*node, namecode+1); 	// 변경 대상자에 포함된다면:
			}
			
			NEScriptModuleSelector module_selector(NECodeType::ALL, NECodeType::ALL);
			NEModule* module = NE_NULL;
			while( module = &(module_selector.getModule()) )
				//			모듈 검색:
				_widenCodeForInsertingModule(NECodeType::NAME, new_namecode, *module);
		}



		//	post:
		//		새로 생성 및 삽입 공통:
		//			네임뱅크 공간 삽입:
		banks.getNameBank().push(NETString(""));
		return RESULT_SUCCESS;
	}
	
	type_result NE_DLL NEStandardScriptEditor::StandardManagedScriptList::insertGroupCode(type_code new_groupcode)
	{
		//	pre:
		//		타겟팅:
		Editor& editor = Editor::getInstance();
		if( ! &editor)
		{
			ALERT_ERROR_IN_SPECIFIED_MODULE(NEExportable::Identifier(_NAME, _DEVELOPER, _REVISION), " : ")
				return RESULT_TYPE_ERROR;
		}
		NEScriptEditor& scripted = editor.getScriptEditor();
		if( ! &scripted)
		{
			ALERT_ERROR_IN_SPECIFIED_MODULE(NEExportable::Identifier(_NAME, _DEVELOPER, _REVISION), " : ")
				return RESULT_TYPE_ERROR;
		}
		NEManagedScriptList& scriptlist = scripted.getManagedScriptList();
		NEManagedScriptList::Banks& banks = scriptlist.getBanks();
		type_code max_groupcode = scripted.getManagedScriptList().getMaxGroupCodeIndex();
		//	pre:
		if(new_groupcode < 0 || new_groupcode > max_groupcode + 1)
		{
			ALERT_ERROR_IN_SPECIFIED_MODULE(NEExportable::Identifier(_NAME, _DEVELOPER, _REVISION), " : ")
				return RESULT_TYPE_ERROR;
		}



		//	main:
		//		이미 존재하는 스크립트들의 코드를 변경할 필요가 있다면:
		//			push의 경우는 Bank의 크기만 늘려주면 된다
		if(new_groupcode < max_groupcode)
		{	//		삽입이라면:	
			//			새로 생성과는 다르게 기존에 존재하는 데이터를 한칸씩 뒤로 밀어서 자리를	만들어야 한다.
			//			값옮김의 대상은 다음과 같다.
			//				1	노드의 코드데이터
			//				2	노드 셀렉터의 코드셋 데이터
			//			새로 생성하는 경우는 이 과정을 거치지 않아도 된다.
		 	//			셀렉터 설정:

			NEScriptSelector node_selector;
			node_selector.setNodeType(NECodeType::ALL);
			NENode* node = NE_NULL;
			while( node = &(node_selector.getNode()) )
			{
				NECodeSet groupcodeset = node->getGroupCode();
				//					루핑:
				for(int n=0; n < groupcodeset.getLength() ;n++)
				{
					//					타겟팅:
					type_code& target = groupcodeset[n];
					//					변경해야하는 엘리먼트 인가?:
					if(target >= new_groupcode)
						//					코드를 하나 늘려준다.
						target++;
				}

				//	왜 node는 const getGroupCode()만 있는가:
				//		setGroupCode시, _onEnroll 과정이 필요하기 때문이다.
				if(groupcodeset != node->getGroupCode()) // 퍼포먼스를 위해서 서로 다를 경우만 변경
					_setGroupCode(*node, groupcodeset);
			}
		
			
			NEScriptModuleSelector module_selector(NECodeType::ALL, NECodeType::ALL);
			NEModule* module = NE_NULL;
			
			while( module = &(module_selector.getModule()) )
				//			모듈 검색:
				_widenCodeForInsertingModule(NECodeType::GROUP, new_groupcode, *module);
					
		}



		//	post:
		//		새로 생성 및 삽입 공통:
		//			네임뱅크 공간 삽입:
		banks.getGroupBank().push(NETString(""));

		return RESULT_SUCCESS;
	}

	type_result NE_DLL NEStandardScriptEditor::StandardManagedScriptList::insertPriorityCode(type_code new_prioritycode)
	{
		//	pre:
		//		타겟팅:
		Editor& editor = Editor::getInstance();
		if( ! &editor)
		{
			ALERT_ERROR_IN_SPECIFIED_MODULE(NEExportable::Identifier(_NAME, _DEVELOPER, _REVISION), " : ")
				return RESULT_TYPE_ERROR;
		}
		NEScriptEditor& scripted = editor.getScriptEditor();
		if( ! &scripted)
		{
			ALERT_ERROR_IN_SPECIFIED_MODULE(NEExportable::Identifier(_NAME, _DEVELOPER, _REVISION), " : ")
				return RESULT_TYPE_ERROR;
		}
		NEManagedScriptList& scriptlist = scripted.getManagedScriptList();
		NEManagedScriptList::Banks& banks = scriptlist.getBanks();
		type_code max_prioritycode = scripted.getManagedScriptList().getMaxPriorityCodeIndex();
		//	pre:
		if(new_prioritycode < 0 || new_prioritycode > max_prioritycode + 1)
		{
			ALERT_ERROR_IN_SPECIFIED_MODULE(NEExportable::Identifier(_NAME, _DEVELOPER, _REVISION), " : ")
				return RESULT_TYPE_ERROR;
		}



		//	main:
		//		이미 존재하는 스크립트들의 코드를 변경할 필요가 있다면:
		//			push의 경우는 Bank의 크기만 늘려주면 된다
		if(new_prioritycode < max_prioritycode)
		{	//		삽입이라면:	
			//			새로 생성과는 다르게 기존에 존재하는 데이터를 한칸씩 뒤로 밀어서 자리를	만들어야 한다.
			//			값옮김의 대상은 다음과 같다.
			//				1	노드의 코드데이터
			//				2	노드 셀렉터의 코드셋 데이터
			//			새로 생성하는 경우는 이 과정을 거치지 않아도 된다.
			//			셀렉터 설정:
			NEScriptSelector node_selector;
			node_selector.setNodeType(NECodeType::ALL);
			NENode* node = NE_NULL;
			while( node = &(node_selector.getNode()) )
			{
				//			새로운 노드라면:
				//				코드 확인:	
				//					배열(Array)이 삽입될때 처럼, 파라메터의 index와 같거나, 보다 큰 스크립트코드만 ++를 해야한다.
				type_code priority = node->getPriority();
				if(priority >= new_prioritycode)
					_setPriorityCode(*node, priority+1); 	// 변경 대상자에 포함된다면:	
			}
			
			
			NEScriptModuleSelector module_selector(NECodeType::ALL, NECodeType::ALL);
			NEModule* module = NE_NULL;
			while( module = &(module_selector.getModule()) )
				//			모듈 검색:
				_widenCodeForInsertingModule(NECodeType::PRIORITY, new_prioritycode, *module);
		}



		//	post:
		//		새로 생성 및 삽입 공통:
		//			네임뱅크 공간 삽입:
		banks.getPriorityBank().push(NETString(""));

		return RESULT_SUCCESS;
	}

	type_result NE_DLL NEStandardScriptEditor::StandardManagedScriptList::removeNameCode(type_code namecode_to_remove)
	{
		//	pre:
		//		타겟팅:
		Editor& editor = Editor::getInstance();
		if( ! &editor)
		{
			ALERT_ERROR_IN_SPECIFIED_MODULE(NEExportable::Identifier(_NAME, _DEVELOPER, _REVISION), " : ")
				return RESULT_TYPE_ERROR;
		}
		NEScriptEditor& scripted = editor.getScriptEditor();
		if( ! &scripted)
		{
			ALERT_ERROR_IN_SPECIFIED_MODULE(NEExportable::Identifier(_NAME, _DEVELOPER, _REVISION), " : ")
				return RESULT_TYPE_ERROR;
		}
		NEManagedScriptList& scriptlist = scripted.getManagedScriptList();
		type_code max_namecode = scriptlist.getMaxNameCodeIndex();
		NETStringList& namebank = scriptlist.getBanks().getNameBank();
		if(namecode_to_remove < 0 || namecode_to_remove > max_namecode + 1)
		{
			ALERT_ERROR_IN_SPECIFIED_MODULE(NEExportable::Identifier(_NAME, _DEVELOPER, _REVISION), " : ")
				return RESULT_TYPE_ERROR;
		}



		//	main:
		//		작업은 크게 3부분으로 나누어진다.
		//			1	삭제대상 노드를 스크립트리스트에서 제거
		//			2	삭제대상 노드를 노드셋키에서 제거
		//			3	노드 셀렉터의 코드셋 데이터와 키의 코드를 변경
		//
		//		왜 이렇게 3부분으로 나누는가?:
		//			단적으로 말해서 "셀렉터를 통한 노드 삭제가 곤란"하기 때문이다.
		//			셀렉터를 통해서 나오는 노드 및 모듈은 그 순서를 예측하기가 힘들다.
		//			게다가 셀렉터 내부에서 위치 저장된 값이 존재하는데,
		//			노드를 삭제해버리면 그 값과 불일치하게 되므로써 (= 대글링포인터)
		//			오작동을 일으킨다.
		//			노드를 지울때마다 initializePosition()을 호출하는 것도 하나의 방법
		//			이나, 그렇게 되면 하나 지울때마다 처음부터 탐색을 실시하므로 
		//			이 또한 번거롭다.
		//	
		//		위와 같은 방법은 택한 이유는 무엇인가?:
		//			노드를 삭제하는 프로세스는 사실 2가지로 나눌 수 있다.
		//				1	노드의 인스턴스를 루트(스크립트리스트)에서 삭제
		//				2	노드를 노드셋키에서 삭제
		//			2번 같은 경우는 삭제가 수월한 편으로, 모듈셋 셀렉터로도 어느정도 가능하다.
		//			셀렉터에서는 모듈이 외부로 반환되고나서, "다시 getModule()을 호출"할때 
		//			모듈이 가진 키를 세부적으로 살펴보게 된다. (노드셋키, 모듈셋키가 존재하는지
		//			보는 것이다.)
		//			이는 노드셀렉터도 동일하다.
		//			이경우, getModule()로 나온 모듈에서 노드셋키를 미리 발견해서 처리하면, 
		//			셀렉터의 오작동을 막을 수 있다.
		//			다만 1번과 같은 경우는 모듈셀렉터로는 불가능하다.
		//			모듈 셀렉터는 내부적으로 노드셀렉터로부터 getNode()를 호출하고 있으므로,
		//			외부에서 peekNode()를 통해 노드에 접근했을 때는, 이미 노드셀렉터에 위치
		//			정보가 기록된 상태이기 때문이다.
		//			1번을 노드셀렉터로 처리한다면, 역시 삭제후 initailizeNodePostion()을 하는
		//			방법이 있으나, 이경우는 차라리 index를 사용해서 순차탐색을 하는 편이 낫다.
		//
		//		삭제 대상 노드를 스크립트리스트에서 1단계 탐색:	1단계 탐색이란, 세부적으로 파고들지 않는 탐색을 말한다.	
		//			탐색:
		//				앞선 삭제:
		//					왜 앞선 삭제를 하는가?:
		//						반복자를 사용하면서 삭제를 하기 위해서다.
		//						보통, 반복자를 사용하면서 삭제를 하면 반복자의 위치정보가 틀어진다.
		//						이를 막기 위해서는 타겟팅시, iterator->getValue()가 아니라,
		//						iterator->getNext()->getValue()로 하면 된다.
		//						단, 이 방법은 인덱스0 에대해서는 적용이 안되므로, 첫부분에
		//						미리 실시하는 것이다.
		//		one-step-off 제거:
		//			단일 링크드 리스트에서, 특정 유닛 A를 제거 하기 위해서는, 해당 유닛을 가리키고 있는
		//			유닛에서 조작을 해야한다. (한 발자국 뒤에서 조작해야 한다)
		//			이러한 형태를 빗대어서 나타낸 말.
		//			단, 이 방법의 경우, 헤드는 별도로 제거 해줘야 한다는 단점이 있다.
		//		코드 삭제시, 노드 인스턴스 정책(policy):
		//			namecode, id, priority같은 코드는 노드당 1개만 존재하며, 가능한한 다른 노드와 달라야한다.
		//			때문에, 코드를 삭제하게 되면 이미 해당 코드를 가지고 있는 노드를 어떻게 할것인가가
		//			문제로 남는다.
		//			현재 커널에서는, 이런 경우 노드를 삭제하는 것으로 한다.
		//			단, 그룹코드는 해당 코드만 삭제하는 것이 가능하고 그룹코드의 특성이 "되도록이면 많은
		//			노드가 같은 그룹코드를 갖는 것" 이므로, 이 경우는 삭제하지 않아도 된다.
		//
		//		노드제거 파트:	삭제할 코드를 가지고 있는 노드를 제거한다.
		//			분기1 그룹코드를 삭제하지 않는다면:	
		//				그룹코드를 삭제할때는, 노드를 삭제하지 않아도 된다. 다만 CodeSet에서 그룹코드 엘리
		//				먼트만 삭제하면 된다.
		//				단, 삭제시 그룹코드가 아무것도 없다면 역시 노드를 삭제한다.



		//			1차 제거:	헤드제거
		//				one-step-off 제거에서는 헤드를 제거 할 수 없으므로, 여기서 미리 헤드를
		//				제거한다.
		while(scriptlist[0].getNameCode() == namecode_to_remove)
			scriptlist.popFront();
		//			2차 제거:	루트 노드를 제거한다.
		//				인덱스 카운터:	인덱스를 1로 맞추는 것에 주의하라.
		type_index index = 1;
		//				탐색시작:	위의 코드로 인해서, getUnit(0)은 대상자가 아니라는 걸 전제로 한다.
		for(NEManagedScriptList::Iterator* iterator = scriptlist.getIterator(0); iterator ;iterator->getNext())
		{
			//				타겟팅:
			NENode& node = iterator->getNext()->getValue();
			//				삭제 대상 판단:	변경대상은 제외된다
			if(node.getNameCode() ==  namecode_to_remove)
				scriptlist.remove(index);
			else
			{
				iterator = iterator->getNext();
				index++;
			}	
		}	
		//		3차 노드제거:	서브 노드를 제거한다.
		NEScriptModuleSelector selector(NECodeType::ALL, NECodeType::ALL);
		//		타겟터:
		NENode* node = NE_NULL;
		//		변경작업:
		for(NEModule* module = &(selector.getModule()); module ;module = &(selector.getModule()))
		{
			//	키 탐색:
			for(int n=0; n < module->getKeySet().getLength() ;n++)
			{
				//	타겟팅:
				NEKey& key = module->getKeySet()[n];
				//	노드셋 판별:	키안에 노드가 있을 곳은 노드셋키 밖에 없다
				if(key.isSubClassOf(NEType::NEMANAGED_NODE_SET_KEY))
				{
					//	노드셋 키라면:	
					//		셀렉터가 노드셋키에 접근하기 전에, 탐색한다. 다음 getModule()
					//		호출시, 셀렉터 내부에서 키를 탐색할 것이다.
					//		타겟팅:
					NEManagedNodeSetKey& nodesetkey = static_cast<NEManagedNodeSetKey&>(key);
					NENodeSet& nodeset = nodesetkey.getValue();
					//		탐색:	셀렉터보다 한발 빨리 키를 탐색하고 있다.
					for(int node_index=0; node_index < nodeset.getLength() ;node_index++)
					{
						NENode& target = nodeset[node_index];
						//		삭제 대상자 판별:
						if(target.getNameCode() == namecode_to_remove)
						{
							//		삭제 대상자라면:	삭제한다.
							nodeset.remove(node_index);
							nodeset.resize(nodeset.getLength());
							node_index--;
						}
					}
				}
			}
		}
		//	코드 수정 및 영향받는 노드의 코드값 변경:
		//		셀렉터 설정:
		selector.initialize();
		//		한번에 모듈과 노드를 검색:
		//			모듈셀렉터인 셀렉터로 getNode() 대신 peekNode()를 사용한다.
		//			getNode()와 getModule()을 혼용하면 모든 모듈을 참조 할 수 없기 때문이다.
		//			peekNode()로 노드포인터가 갱신될때만 노드의 스크립트 코드를 조사한다.
		node = NE_NULL;
		//		키의 코드와 노드의 코드 변경:
		for(NEModule* module = &(selector.getModule()); module ;module = &(selector.getModule()))
		{
			//		모듈 검색 및 삭제 대상 판별:
			_narrowCodeForRemovingModule(NECodeType::NAME, namecode_to_remove, *module);
			//		노드 검색:	새로히 바뀐 노드인가?
			if(node != &(selector.peekNode()))
			{
				//		새로운 노드라면:
				//			포인터 갱신:	갱신하지 않으면, 다음번에도 같은 노드의 코드를 변경하려 할 것이다.
				node = &(selector.peekNode());
				//			코드별 제거 액션:		
				type_code namecode = node->getNameCode();
				if(namecode > namecode_to_remove)
					_setNameCode(*node, namecode-1);
			}	
		}


		//	post:
		//		스크립트 코드:
		//		네임뱅크 공간 삭제:
		namebank.remove(namecode_to_remove);
		
		return RESULT_SUCCESS;
	}

	
	type_result NE_DLL NEStandardScriptEditor::StandardManagedScriptList::removeGroupCode(type_code groupcode_to_remove)
	{
		//	pre:
		//		타겟팅:
		Editor& editor = Editor::getInstance();
		if( ! &editor)
		{
			ALERT_ERROR_IN_SPECIFIED_MODULE(NEExportable::Identifier(_NAME, _DEVELOPER, _REVISION), " : ")
				return RESULT_TYPE_ERROR;
		}
		NEScriptEditor& scripted = editor.getScriptEditor();
		if( ! &scripted)
		{
			ALERT_ERROR_IN_SPECIFIED_MODULE(NEExportable::Identifier(_NAME, _DEVELOPER, _REVISION), " : ")
				return RESULT_TYPE_ERROR;
		}
		NEManagedScriptList& scriptlist = scripted.getManagedScriptList();
		type_code max_groupcode = scriptlist.getMaxGroupCodeIndex();
		NETStringList& namebank = scriptlist.getBanks().getGroupBank();
		if(groupcode_to_remove < 0 || groupcode_to_remove > max_groupcode + 1)
		{
			ALERT_ERROR_IN_SPECIFIED_MODULE(NEExportable::Identifier(_NAME, _DEVELOPER, _REVISION), " : ")
				return RESULT_TYPE_ERROR;
		}



		//	코드 수정 및 영향받는 노드의 코드값 변경:
		NEScriptSelector node_selector;
		NENode* node = NE_NULL;
		//		노드 검색:	새로히 바뀐 노드인가?
		while( node = &(node_selector.getNode()) )
		{
			//		새로운 노드라면:
			//			코드별 제거 액션:
			//				타겟팅:
			NECodeSet codeset = node->getGroupCode();
			//				루핑:
			for(int n=0; n < codeset.getLength() ;n++)
				if(codeset[n] > groupcode_to_remove)
					codeset[n]--;
				else if(codeset[n] == groupcode_to_remove)
					codeset.remove(n);
			//				크기 변경:	도중에, remove가 되었다면 length와 size가 안맞게 된다.
			codeset.resize(codeset.getLength());
			//				할당:
			if(codeset != node->getGroupCode())
				_setGroupCode(*node, codeset);			
		}	
		
		
		//		셀렉터 설정:
		NEScriptModuleSelector module_selector(NECodeType::ALL, NECodeType::ALL);
		NEModule* module = NE_NULL;
		//		키의 코드와 노드의 코드 변경:
		while( module = &(module_selector.getModule()) )
			//		모듈 검색 및 삭제 대상 판별:
			_narrowCodeForRemovingModule(NECodeType::GROUP, groupcode_to_remove, *module);


		//	post:
		//		네임뱅크 공간 삭제:
		namebank.remove(groupcode_to_remove);
		
		return RESULT_SUCCESS;return RESULT_SUCCESS;
	}

	type_result NE_DLL NEStandardScriptEditor::StandardManagedScriptList::removePriorityCode(type_code prioritycode_to_remove)
	{
		//	pre:
		//		타겟팅:
		Editor& editor = Editor::getInstance();
		if( ! &editor)
		{
			ALERT_ERROR_IN_SPECIFIED_MODULE(NEExportable::Identifier(_NAME, _DEVELOPER, _REVISION), " : ")
				return RESULT_TYPE_ERROR;
		}
		NEScriptEditor& scripted = editor.getScriptEditor();
		if( ! &scripted)
		{
			ALERT_ERROR_IN_SPECIFIED_MODULE(NEExportable::Identifier(_NAME, _DEVELOPER, _REVISION), " : ")
				return RESULT_TYPE_ERROR;
		}
		NEManagedScriptList& scriptlist = scripted.getManagedScriptList();
		type_code max_prioritycode = scriptlist.getMaxPriorityCodeIndex();
		NETStringList& namebank = scriptlist.getBanks().getPriorityBank();
		if(prioritycode_to_remove < 0 || prioritycode_to_remove > max_prioritycode + 1)
		{
			ALERT_ERROR_IN_SPECIFIED_MODULE(NEExportable::Identifier(_NAME, _DEVELOPER, _REVISION), " : ")
				return RESULT_TYPE_ERROR;
		}


		//			1차 제거:	헤드제거
		//				one-step-off 제거에서는 헤드를 제거 할 수 없으므로, 여기서 미리 헤드를
		//				제거한다.
		while(scriptlist[0].getPriority() == prioritycode_to_remove)
			scriptlist.popFront();
		//			2차 제거:	루트 노드를 제거한다.
		//				인덱스 카운터:	인덱스를 1로 맞추는 것에 주의하라.
		type_index index = 1;
		//				탐색시작:	위의 코드로 인해서, getUnit(0)은 대상자가 아니라는 걸 전제로 한다.
		for(NEManagedScriptList::Iterator* iterator = scriptlist.getIterator(0); iterator ;iterator->getNext())
		{
			//		타겟팅:
			NENode& node = iterator->getNext()->getValue();
			//		삭제 대상 판단:	변경대상은 제외된다
			if(node.getPriority() ==  prioritycode_to_remove)
				//		삭제대상이라면:	removeScript없이, 바로 제거한다.
				scriptlist.remove(index);
			else
			{
				iterator = iterator->getNext();
				index++;
			}	
		}	
		//		3차 노드제거:	서브 노드를 제거한다.
		NEScriptModuleSelector selector(NECodeType::ALL, NECodeType::ALL);
		//		타겟터:
		NENode* node = NE_NULL;
		//		변경작업:
		for(NEModule* module = &(selector.getModule()); module ;module = &(selector.getModule()))
		{
			//	키 탐색:
			for(int n=0; n < module->getKeySet().getLength() ;n++)
			{
				//	타겟팅:
				NEKey& key = module->getKeySet()[n];
				//	노드셋 판별:	키안에 노드가 있을 곳은 노드셋키 밖에 없다
				if(key.isSubClassOf(NEType::NEMANAGED_NODE_SET_KEY))
				{
					//	노드셋 키라면:	
					//		셀렉터가 노드셋키에 접근하기 전에, 탐색한다. 다음 getModule()
					//		호출시, 셀렉터 내부에서 키를 탐색할 것이다.
					//		타겟팅:
					NEManagedNodeSetKey& nodesetkey = static_cast<NEManagedNodeSetKey&>(key);
					NENodeSet& nodeset = nodesetkey.getValue();
					//		탐색:	셀렉터보다 한발 빨리 키를 탐색하고 있다.
					for(int node_index=0; node_index < nodeset.getLength() ;node_index++)
					{
						NENode& target = nodeset[node_index];
						//		삭제 대상자 판별:
						if(target.getPriority() == prioritycode_to_remove)
						{
							//		삭제 대상자라면:	삭제한다.
							nodeset.remove(node_index);
							nodeset.resize(nodeset.getLength());
							node_index--;
						}
					}
				}
			}
		}

		//	코드 수정 및 영향받는 노드의 코드값 변경:
		//		셀렉터 설정:
		selector.initialize();
		//		한번에 모듈과 노드를 검색:
		//			모듈셀렉터인 셀렉터로 getNode() 대신 peekNode()를 사용한다.
		//			getNode()와 getModule()을 혼용하면 모든 모듈을 참조 할 수 없기 때문이다.
		//			peekNode()로 노드포인터가 갱신될때만 노드의 스크립트 코드를 조사한다.
		node = NE_NULL;
		//		키의 코드와 노드의 코드 변경:
		for(NEModule* module = &(selector.getModule()); module ;module = &(selector.getModule()))
		{
			//		모듈 검색 및 삭제 대상 판별:
			_narrowCodeForRemovingModule(NECodeType::PRIORITY, prioritycode_to_remove, *module);
			//		노드 검색:	새로히 바뀐 노드인가?
			if(node != &(selector.peekNode()))
			{
				//		새로운 노드라면:
				//			포인터 갱신:	갱신하지 않으면, 다음번에도 같은 노드의 코드를 변경하려 할 것이다.
				node = &(selector.peekNode());
				//			코드별 제거 액션:	
				type_code priority = node->getNameCode();
				if(priority > prioritycode_to_remove)
					_setPriorityCode(*node, priority-1);
			}	
		}


		//	post:
		//		네임뱅크 공간 삭제:
		namebank.remove(prioritycode_to_remove + 1);
		
		return RESULT_SUCCESS;
	}

	NEObject NE_DLL &NEStandardScriptEditor::StandardManagedScriptList::clone() const
	{
		return *(new StandardManagedScriptList(*this));
	}

	type_result NE_DLL NEStandardScriptEditor::StandardManagedScriptList::isValid() const
	{
		type_result result = NEManagedScriptList::isValid();
		if(NEResult::hasError(result)) return result;
		
		return RESULT_SUCCESS;
	}	

	NEBinaryFileSaver NE_DLL &NEStandardScriptEditor::StandardManagedScriptList::serialize(NEBinaryFileSaver& saver) const
	{
		NEManagedScriptList::serialize(saver);

		return saver << _banks;
	}

	NEBinaryFileLoader NE_DLL &NEStandardScriptEditor::StandardManagedScriptList::serialize(NEBinaryFileLoader& loader)
	{
		NEManagedScriptList::serialize(loader);

		return loader >> _banks;
	}

	void NE_DLL NEStandardScriptEditor::StandardManagedScriptList::release()
	{
		NEManagedScriptList::release();
		
		_release();
	}
	
	NEStandardScriptEditor::StandardManagedScriptList& NEStandardScriptEditor::StandardManagedScriptList::_assign(const StandardManagedScriptList& source)
	{
		if(this == &source) return *this;

		_banks = source._banks;

		return *this;
	}
	
	type_result NE_DLL NEStandardScriptEditor::StandardManagedScriptList::_onEnroll(NENode& node, bool is_sub_node)
	{
		//	pre:
		if( ! &node ) return RESULT_TYPE_ERROR;
		NEEnrollableNodeList* manager_of_target = _getManager(node.getModuleSet());
		//		이미 등록되어있는 노드인지:
		if(manager_of_target)
		{
			if(this == manager_of_target) return RESULT_TYPE_INFORMATION | RESULT_ABORT_ACTION;

			ALERT_ERROR_IN_SPECIFIED_MODULE(NEExportable::Identifier(_T(_NAME), _T(_DEVELOPER), _REVISION), " : ")
				return RESULT_TYPE_WARNING | RESULT_ABORT_ACTION;
		}
		//		노드의 코드 Valid 검증:
		//			NameCode:
		if(node.getNameCode() < 0 || node.getNameCode() > getMaxNameCodeIndex())
		{
			ALERT_ERROR_IN_SPECIFIED_MODULE(NEExportable::Identifier(_T(_NAME), _T(_DEVELOPER), _REVISION), " : ")
			return RESULT_TYPE_WARNING;
		}
		//			GroupCode:
		const NECodeSet& groupcode = node.getGroupCode();
		type_code max_groupcode = getMaxGroupCodeIndex();
		for(int n=0; n < groupcode.getLength() ;n++)
			if(groupcode[n] < 0 || groupcode[n] > max_groupcode)
			{
				ALERT_ERROR_IN_SPECIFIED_MODULE(NEExportable::Identifier(_T(_NAME), _T(_DEVELOPER), _REVISION), " : ")
				return RESULT_TYPE_WARNING;
			}
		//			PriorityCode:
		if(!is_sub_node)
		{
			if(node.getPriority() < 0 || node.getPriority() > getMaxPriorityCodeIndex())
			{
				ALERT_ERROR_IN_SPECIFIED_MODULE(NEExportable::Identifier(_T(_NAME), _T(_DEVELOPER), _REVISION), " : ")
				return RESULT_TYPE_WARNING;
			}
		}
		else
		{
			if(node.getPriority())
			{
				ALERT_ERROR_IN_SPECIFIED_MODULE(NEExportable::Identifier(_T(_NAME), _T(_DEVELOPER), _REVISION), " : ")
				return RESULT_TYPE_WARNING;
			}
		}	
		
		
		
		//	main:
		//		노드의 manager 변경:
		_setManager(node.getModuleSet(), this);
		//		뱅크 크기 변경:
		//			타겟팅:
		NETStringList& idbank = _banks.getScriptBank();
   		//			id fetch:
		type_id id = node.getId();
		//			뱅크에 삽입:
		idbank.insert(id, NETString(_T(""))); // id는 인덱스.
		
		
		
		//	post:
		return RESULT_SUCCESS;
	}
	
	type_result NE_DLL NEStandardScriptEditor::StandardManagedScriptList::_onUnenroll(NENode& node, bool is_sub_node)
	{
		//	매니져 제거:
		_setManager(node.getModuleSet(), NE_NULL);
		//	뱅크 크기 변경:
		//		타겟팅:
		NETStringList& idbank = _banks.getScriptBank();
		//		id fetch:
		type_id id = node.getId(); // 지워지게될 노드의 아이디
		//		뱅크에 삽입:
		return idbank.remove(id); // id는 인덱스.
	}
	
	
	type_result NEStandardScriptEditor::StandardManagedScriptList::_synchronizeId()
	{
		//	pre:
		Editor& editor = Editor::getInstance();
		if( ! &editor) 
		{	
			ALERT_ERROR_IN_SPECIFIED_MODULE(NEExportable::Identifier(_NAME, _DEVELOPER, _REVISION), " : ")
				return NE_INDEX_ERROR;
		}
		NEEventHandler& handler = editor.getEventHandler();
		if( ! &handler)
		{
			ALERT_ERROR_IN_SPECIFIED_MODULE(NEExportable::Identifier(_NAME, _DEVELOPER, _REVISION), " : ")
				return NE_INDEX_ERROR;
		}



		//	main:
		type_id id_to_bind = 0;

		for(int n=0; n < getLength() ;n++)
		{
			NENode& node = getElement(n);
			_setId(node, id_to_bind);
			id_to_bind++;

			id_to_bind = _synchronizeIdWith(node.getModuleSet(), id_to_bind);
		}

		return RESULT_SUCCESS;
	}
	
	
	type_id NEStandardScriptEditor::StandardManagedScriptList::_synchronizeIdWith(NEModuleSet& moduleset, type_id id_to_bind)
	{
		for(int n=0; n < moduleset.getLength() ;n++)
		{
			NEModule& module = moduleset[n];
			if( ! &module) continue;

			NEKeySet& keyset = module.getKeySet();

			for(int key_n=0; key_n < keyset.getLength() ;key_n++)
			{
				NEKey& key = keyset[key_n];
				if( ! &key) continue; // for(int key_n...)가 continue 된다.
				if(key.isSubClassOf(NEType::NEMANAGED_NODE_SET_KEY))
				{
					NEManagedNodeSetKey& nodeset_key = static_cast<NEManagedNodeSetKey&>(key);
					id_to_bind = _synchronizeIdWith(nodeset_key.getValue(), id_to_bind);
				}
				else if(key.isSubClassOf(NEType::NEMANAGED_MODULE_SET_KEY))
				{
					NEManagedModuleSetKey& moduleset_key = static_cast<NEManagedModuleSetKey&>(key);
					id_to_bind = _synchronizeIdWith(moduleset_key.getValue(), id_to_bind);
				}
			}
		}

		return id_to_bind;
	}

	type_id NEStandardScriptEditor::StandardManagedScriptList::_synchronizeIdWith(NENodeSet& nodeset, type_id id_to_bind)
	{
		//	pre:
		Editor& editor = Editor::getInstance();
		if( ! &editor) 
		{	
			ALERT_ERROR_IN_SPECIFIED_MODULE(NEExportable::Identifier(_NAME, _DEVELOPER, _REVISION), " : ")
			return NE_INDEX_ERROR;
		}
		NEEventHandler& handler = editor.getEventHandler();
		if( ! &handler)
		{
			ALERT_ERROR_IN_SPECIFIED_MODULE(NEExportable::Identifier(_NAME, _DEVELOPER, _REVISION), " : ")
			return NE_INDEX_ERROR;
		}
		
		
		
		//	main:
		for(int n=0; n < nodeset.getLength() ;n++)
		{
			NENode& node = nodeset.getElement(n);
			_setId(node, id_to_bind);
			id_to_bind++;

			id_to_bind = _synchronizeIdWith(node.getModuleSet(), id_to_bind);
		}

		return id_to_bind;
	}	
		
	void NEStandardScriptEditor::StandardManagedScriptList::_release()
	{
		_banks.release();
	}
	
	type_result NEStandardScriptEditor::StandardManagedScriptList::_onChangeNameCode(NENode& target, type_code new_namecode)
	{
		if(new_namecode < 0 || new_namecode > getMaxNameCodeIndex()) return RESULT_TYPE_WARNING | RESULT_ABORT_ACTION;
		
		_setNameCode(target, new_namecode);

		return RESULT_SUCCESS;
	}

	type_result NEStandardScriptEditor::StandardManagedScriptList::_onChangeGroupCode(NENode& target, const NECodeSet& new_groupcode)
	{
		type_code max_groupcode = getMaxGroupCodeIndex();
		
		for(int n=0; n < new_groupcode.getLength() ;n++)
			if(new_groupcode[n] < 0 || new_groupcode[n] > max_groupcode) return RESULT_TYPE_WARNING | RESULT_ABORT_ACTION; 
		
		_setGroupCode(target, new_groupcode);
		
		return RESULT_SUCCESS;
	}

	type_result NEStandardScriptEditor::StandardManagedScriptList::_onChangePriorityCode(NENode& target, type_code new_prioritycode)
	{
		if(new_prioritycode < 0 || new_prioritycode > getMaxPriorityCodeIndex()) return RESULT_TYPE_WARNING | RESULT_ABORT_ACTION;
		
		_setPriorityCode(target, new_prioritycode);
		
		return RESULT_SUCCESS;
	}
	
	void NEStandardScriptEditor::StandardManagedScriptList::_widenCodeForInsertingModule(NECodeType::CodeType codetype, type_code code_to_insert, NEModule& module) const
	{
		//	pre:
		if( ! &module) return;



		//	main:
		for(int n=0; n < module.getKeySet().getLength() ;n++)
		{
			//			타겟팅:
			NEKey& key = module.getKeySet()[n];
			NEType::Type type = key.getType();
			//			검사:	스크립트 노드셀렉터를 가지고 있는가?
			//					검사 영역이 "커널의 스크립트" 이므로, Kernal에 속하지 않는 컴포넌트, NEEditnode 키는 제외한다.
			//					그랬을때, 영향을 받게 되는 노드 셀렉터는 다음과 같다.
			//						1	NENodeSelectorByScript	:	순수 노드 셀렉터
			//						2	NERecentByScript, NENameByScript, NEScriptByScript	:	모듈 셀렉터
			//						3	NERecentByScriptKey, NENameByScriptKey, NEScriptByScriptKey	:	키 셀렉터
			//				분기1:	노드셀렉터인가?
			if(	key.isSubClassOf(NEType::NENODE_SELECTOR)	||
				key.isSubClassOf(NEType::NESCRIPT_SELECTOR)	)
			{	//				노드셀렉터라면:	코드셋에 추가한다.
				//					타겟팅:
				NENodeSelectorInterface& node_selector = static_cast<NENodeSelectorInterface&>(key);
				//					분기1-2 노드타입 비교:	같은 노드타입이라면
				if(node_selector.getNodeType() == codetype)
				{	//					코드증가:
					NECodeSet processed_codeset = _widenCodeForInsertingCodeSet(code_to_insert, node_selector.getCodeSet());
					node_selector.setCodeSet(processed_codeset);
				}
				//				분기2:	모듈셀렉터인가?
				if(key.isSubClassOf(NEType::NEMODULE_SELECTOR))
				{	//				모듈셀렉터라면:	코드셋 추가한다.
					NEModuleSelector& module_selector = static_cast<NEModuleSelector&>(key);
					//					분기2-1:	같은 모듈타입인가?
					if(module_selector.getModuleType() == codetype)
					{
						NECodeSet processed_codeset = _widenCodeForInsertingCodeSet(code_to_insert, module_selector.getCodeSet());
						module_selector.setModuleCodeSet(processed_codeset);
					}
				}
				else if(key.isSubClassOf(NEType::NESCRIPT_MODULE_SELECTOR))
				{	//				모듈셀렉터라면:	코드셋 추가한다.
					NEScriptModuleSelector& module_selector = static_cast<NEScriptModuleSelector&>(key);
					//					분기2-1:	같은 모듈타입인가?
					if(module_selector.getModuleType() == codetype)
					{
						NECodeSet processed_codeset = _widenCodeForInsertingCodeSet(code_to_insert, module_selector.getCodeSet());
						module_selector.setModuleCodeSet(processed_codeset);
					}
				}
			}
		}
	}

	void NEStandardScriptEditor::StandardManagedScriptList::_narrowCodeForRemovingModule(NECodeType::CodeType codetype, type_code code_to_remove, NEModule& module) const
	{
		//	pre:
		if(! &module) return;



		//	main:
		for(int n=0; n < module.getKeySet().getLength() ;n++)
		{
			//		타겟팅:
			NEKey& key = module.getKeySet()[n];
			NEType::Type type = key.getType();
			//		코드셋 삭제:
			//			검사:	스크립트 노드셀렉터를 가지고 있는가?
			//					검사 영역이 "커널의 스크립트" 이므로, Kernal에 속하지 않는 컴포넌트, NEEditnode 키는 제외한다.
			//					그랬을때, 영향을 받게 되는 노드 셀렉터는 다음과 같다.
			//						1	NENodeSelectorByScript	:	순수 노드 셀렉터
			//						2	NERecentByScript, NENameByScript, NEScriptByScript	:	모듈 셀렉터
			//						3	NERecentByScriptKey, NENameByScriptKey, NEScriptByScriptKey	:	키 셀렉터
			//				분기1:	노드셀렉터인가?
			if(	key.isSubClassOf(NEType::NENODE_SELECTOR)	||
				key.isSubClassOf(NEType::NESCRIPT_SELECTOR)	)
			{	//				노드셀렉터라면:	코드셋에서 삭제한다.
				//					타겟팅:
				NENodeSelectorInterface& node_selector = static_cast<NENodeSelectorInterface&>(key);
				//					분기1-2 노드타입 비교:	같은 노드타입이라면
				if(node_selector.getNodeType() == codetype)
				{	//					코드증가:
					NECodeSet processed_codeset = _narrowCodeForRemovingCodeSet(code_to_remove, node_selector.getCodeSet());
					node_selector.setCodeSet(processed_codeset);
				}
				//				분기2:	모듈셀렉터인가?
				if(key.isSubClassOf(NEType::NEMODULE_SELECTOR))
				{	//				모듈셀렉터라면:	코드셋 추가한다.
					NEModuleSelector& module_selector = static_cast<NEModuleSelector&>(key);
					//					분기2-1:	같은 모듈타입인가?
					if(module_selector.getModuleType() == codetype)
					{
						NECodeSet processed_codeset = _narrowCodeForRemovingCodeSet(code_to_remove, module_selector.getCodeSet());
						module_selector.setModuleCodeSet(processed_codeset);
					}
				}
				else if(key.isSubClassOf(NEType::NESCRIPT_MODULE_SELECTOR))
				{	//				모듈셀렉터라면:	코드셋 추가한다.
					NEScriptModuleSelector& module_selector = static_cast<NEScriptModuleSelector&>(key);
					//					분기2-1:	같은 모듈타입인가?
					if(module_selector.getModuleType() == codetype)
					{
						NECodeSet processed_codeset = _narrowCodeForRemovingCodeSet(code_to_remove, module_selector.getCodeSet());
						module_selector.setModuleCodeSet(processed_codeset);
					}				
				}
			}
		}
	}

	NECodeSet NEStandardScriptEditor::StandardManagedScriptList::_narrowCodeForRemovingCodeSet(type_code code_to_remove, const NECodeSet& codeset) const
	{
		//	버퍼 생성:
		NECodeSet buffer(codeset);
		//	검사:
		for(int n=0; n < buffer.getLength() ;n++)
		{
			//	키 검사:
			//		타겟팅:
			type_code code = buffer[n];
			//		키가 인덱스와 같다면 삭제하고, 보다 큰경우만 --시키면 된다.
			if(code == code_to_remove)
			{
				buffer.remove(n);
				n--;
				//	왜 n--를 하는가?:
				//		remove(3)을 예를 들어보자.
				//		remove(3)이므로 3번은 탐색했다는 뜻. 그렇다면 다음은 4번을 탐색할
				//		차례다.
				//		그런데 remove(3)을 하게 되면, 3이 사라지면서 4가 3으로, 5가 4로 한칸씩 
				//		당겨지게 되므로, 다음에 탐색할 곳은 index 4가 아니라, index 3이 되어
				//		버린다.
				//		따라서 n++의 효과를 없애기 위해서 n--를 하는 것이다.
				//
				//		비슷한 알고리즘이 NEModuleManager에서 중복된 모듈을 제거 하는 과정에서
				//		사용된 적이 있다.
			}
			else if(code > code_to_remove)
				buffer[n] -= 1; // --가 지원 안된다
		}
		//	버퍼정리:	remove로는 size까지 줄일 수는 없기 때문에 이걸 그대로 사용하면
		//				size와 length가 안맞게 된다.
		buffer.resize(buffer.getLength());

		return buffer;
	}

	NECodeSet NEStandardScriptEditor::StandardManagedScriptList::_widenCodeForInsertingCodeSet(type_code code_to_insert, const NECodeSet& codeset) const
	{
		//	버퍼 생성:
		NECodeSet buffer(codeset);
		//	검사:
		for(int n=0; n < codeset.getLength() ;n++)
		{
			//	키 검사:	키가 인덱스와 같거나 큰경우만 ++시키면 된다.
			if(codeset[n] >= code_to_insert)
				buffer[n] += 1; // ++가 지원 안된다
		}

		return buffer;
	}
	
	type_result NEStandardScriptEditor::StandardManagedScriptList::_onAfterInsertBeforeEnroll()
	{
		return _synchronizeId();
	}

	type_result NEStandardScriptEditor::StandardManagedScriptList::_onAfterRemoveAndUnenroll()
	{
		return _synchronizeId();
	}

	type_result NEStandardScriptEditor::StandardManagedScriptList::_onAfterResize()
	{
		return _synchronizeId();
	}
}
