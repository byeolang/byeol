원인
	NEKey.assign(NEKey)가 기본적으로 제공되고 있으나, 이것만으로는 동작이 제한된다.
	다음과 같은 경우를 예로 들어보자.
	
원인의 예
	1. Collector키에 템플릿타입의 관계
	
		void main()
		{
			NEKey& key = NEBooleanSetKey();			
			
			key3번 인덱스에 false를 넣고 싶다면?
				-> 캐스팅을 사용할 수 밖에 없다.
				
			NEKey& key = NEBooleanSetKey();			
			NEKey& key = NEIntSetKey();			
			NEKey& key = NEFloatSetKey();			
			NEKey& key = NEDoubleSetKey();			
						.
						.
						.
						.
						.
					전부다 캐스팅?
		}
		
		그러면 다음과 같이 템플릿 함수를 사용해볼까?
		
		만약 다음과 같은게 있다면 좋을것이다.
		key.insertKey(index, NEKey&);
		key.remove(index);
		NEKey& key.extract(index);
		
		void foo(NEKey& key, NEKey& source)
		{
			if(key.isCollectorKey())
				key.extract(3).assign(source);			
		}
		
	
	2. 1번만으로도 assign문제는 해결되는가?
		-> assign 문제는 크게 다음처럼 나눌수 있다.
		
		1. source가 일반 키일경우,
		2. source가 콜렉터키 일 경우,
		
		그리고 target도 다음처럼 나눌 수 있다.
		
		1. target이 키 일경우
		2. target이 primitive 변수 일때
		
		그리고 각각의 경우에 4개의 경우로 나눌 수 있다.
			
		1. source와 target이 모두 명확할 경우
			-> 이경우 문제 될게 없다. target이 primitive라고 해도,
			target이 bool이라면, source.assign( NEBooleanKey(target) ); 을 해버리면 그만이다.
		
		2. source만 명확할 경우
			2.1. NEBooleanSetKey& source, NEKey& target
				이 경우, NEBooleanKey& source_element.assign(target)과 같은 형태가 되어야하므로,
				BooleanSetKey. 즉, 콜렉터키에서 위와 같은 기능을 제공한다면 대처가 가능할것이다.
				이는, 1번에서 이미 제기한 의문이고 해결책이다.
				
			2.2. NEBooleanSetKey& source, T& target
				1번의 해법으로도 마땅치 않다.
		
		3. target만 명확할 경우
			target이 키 일 경우,
				이경우, if(source.isCollector)
							source.insertKey(target);
						else
							source.assign(target);
							
			target이 primitive일 경우,
				
		
		4. source와 target 모두 명확하지 못한 경우.
			
			
			
		이러한 해결책으로 다음을 생각해볼 수 있다.
		
			근본적으로는 assign(NEKey)를 이용해야한다.
			assign(int), assign(T)와 같이 할 수도 있겠으나, 이는 오차가 생겨버린다.
			왜나하면 primitive타입 = 키가 아니기 때문이다.
			char의 경우, NEByteKey도, NECharKey 모두 사용하고 있으나, 용도가 다르다.
			
			C언어에서는 "용도에 관계없이 데이터의 크기"로 구분하고 있는 것이 강하나,
			Node에서는 "같은 데이터라도 용도가 다르다면 다른 키"라고 구분하고 있기 때문이다.
			
			즉, assign(T) 대신, assign( T->NEKey로 Wrapping ); 과 같은 구조를 생각해볼 수 있다.
			
			그래서 다음과 같은 것은 어떨까.
			
				class NEKey
				{
					.
					.
					.
					.
					
				public:
					template <typename T>
					static NEKey NE_DLL &wrap(NEType::Type, T& source)	// <-- NE_DLL로 선언하여, 미리 템플릿특화시킨 것 이외에 외부에서 정의할 수 없도록 막는다.
					{
						switch(NEType::Type)
						{
						case NEINTKEY:
							return NEIntKey(source);
						case	.
								.
								.
								.
						default:
							NEKey* null_pointer = NE_NULL;
							
							return *null_pointer;
						}
					}
				}
				
				
				이경우, 
				void foo(NEKey& source, NEKey& target)
				{
					if(source.isCollectorKey)
						source.insert(target);
					else
						source.assign(target);
				}
				void foo(NEKey& source, T& target)
				{
					if(source.isCollectorKey)
						source.insert(target);
					else
						source.assign( NEKey::wrap(source.getType(), target));
				}
				
				될것 같긴 하다. 그러면,	wrap의 구현에 대해서 생각해보자.
				
				
				
				
		그러나 Node에서도 C언어에서처럼 "용도에 관계없이 데이터의 크기"로 구분한다면, T ---- NEType -----> NEKey 였던 것이
		T -----> NEKey로 바로 변환이 가능해진다.
		wrap(target); 처럼 사용이 가능할것이다.
		단, 이경우 CustomKey는 불가능해진다.
		
		NEKey에 parseInt, parseFloat과 같은 함수를 만든다면 어떨까?
		
		template <typename T>
		static NEKey NE_DLL &wrap(NEType::Type, T& source)	// <-- NE_DLL로 선언하여, 미리 템플릿특화시킨 것 이외에 외부에서 정의할 수 없도록 막는다.
		{
			switch(NEType::Type)
			{
			case NEINTKEY:
				// NEIntKey(source); // <--- 이게 안된다. NEIntKey(bool)이 없잖아.
				
				
					NEIntKey.getValue() = static_cast<int>(source); 처럼 해야 하는데, 그럼 assign에 선언한걸 또 쓰는게 되버린다.
					
					1. 즉, 이미 존재하는 NEKey.assign등을 재사용할 수 있다면 해결 가능.
					2. 또는 뭔가 재활용성이 높은 함수가 존재하고, 그것을 이용하는 것이 wrap, assign(NEKey)가 된다면 문제 해결
				
					
						wrap을 assign에서 사용한다면?
						--- assign(NEKey)
						switch(key.getType)
						{
						case NEFloatKey:
							NEFloatKey& key = NEKey;
							getValue() = static_cast<int>(key.getValue();
				
						캐스팅1회 + wrapping( 캐스팅1+ 타입 확인1+ 복사생성1)
						되기는 되지만, 너무 돌아간다. 효율이 않좋다.
						
						그럼 이렇게 되나?
						
						assign(int)
						{
							
						}
							-> 단 이경우, 커스텀키를 바로 assign()이 불가능하다.
							근데. 이 점은, wrap을 할때도 마찬가지. 또한, 그러나 Node에서도 C언어에서처럼 "용도에 관계없이 데이터의 크기"로 구분해야 한다.
								-> 키의 축소.
						
						assign(NEKey&)
						{
							switch
							{
							case NEFloatKey:
								NEFloatKey& key = NEKey;
								assign(key.getValue);
							}
						}						
						
						
						
				
			case	.
					.
					.
					.
			default:
				NEKey* null_pointer = NE_NULL;
				
				return *null_pointer;
			}
		}