//	왜 NEModule::operator=로 2단계 위의 클래스를 호출하는가:
		//		ADT의 연산자 오버로딩 문제 때문이다.
		//		ADT의 연산자 오버로딩 문제는,
		//			1. 각 클래스는 자신이 소유한 멤버데이터만 연산자 오버로딩시에 관리한다.
		//			2. ADT는 외부에 공개되는 유일한 객체인데 멤버데이터가 존재하지 않는다.
		//		에 의해서 ADT는 연산자 오버로딩을 가져선 안된다는 결과가 된다.
		//		그런데 연산자 오버로딩이 없으면 다음과 같은 코드가 불가능하다.
		//		{
		//			NEScriptManager& scripter1 = Kernal::getInstance().getScriptManager();
		//			NEScriptManager& another = scripter1.clone();
		//			another = scripter1 // 오류.
		//		}
		//		즉, ADT는 반드시 연산자 오버로딩을 제공해야하므로 이를 해결하기 위해서는
		//		매니져클래스 개발자와 커널 개발자간의 모종의 약속이 필요하다.
		//		그래서 커널을 만들때 다음과 같은 규칙을 세워서 만들었다.
		//			1. 커널개발시, ADT는 operator=, operator==, operator!=만 정의한다.
		//			2. 복사생성자시에는 아무런 동작을 하지 않는다.
		//			3. 1번의 데이터 대상은 pure virtual을 사용해서 접근가능한 모든 멤버데이터를 
		//				를 말한다.
		//
		//		따라서 매니져개발자는 크게 2가지 방법을 택할 수 있다.
		//			연산자 오버로딩의 경우:
		//				1. ADT클래스::operator=() 를 호출하고, ADT에 처리하지 않는 데이터만
		//					추가적으로 처리한다.
		//				2. 처음부터 NEModule::operator=를 불러서 ADT의 함수를 사용하지 않게
		//					한다.
		//		이 문제의 문제점:
		//			ADT 연산자오버로딩에서 pure virtual로 접근가능한 멤버데이터만 수정한다.
		//			만약 상속한 클래스에서 동작에 치명적이나 pure virtual로 공개되지 않은
		//			데이터가 존재한다면?		
		//
		//			---> 그래서 방법을 바꾼다.
		//				protected로 virtual _assign(), virtual _isEqual()를 만드는 것이다.
		//				이거라면 가능할까?
		//			아니다.
		//			예를 들어서 _isEqual(ADT& source); 에서 source가 나와 같은 타입이라고 할수
		//			있을까?
		//			즉, 결론은 이렇다.
		//	ADT에서 연산자 오버로딩을 처리하고자 한다면 타입을 식별할 수 있어야 한다. RTTI.
		
		문제를 처음으로 돌려보자.
		왜 꼭 ADT에서 연산자 오버로딩을 사용하려는 것인가.
		NEModule도 일종의 ADT라고 볼수 있지만, 연산자오버로딩에서는 아무런 동작도 하지 않는다.
		대신에 clone을 사용해서 컬렉터도 구현이 가능했었다.
		
