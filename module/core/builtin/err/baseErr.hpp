/// @file
#pragma once

#include "core/ast/baseObj.hpp"
#include "core/frame/frames.hpp"

namespace by {
    /** @ingroup core
     *  @brief Base class for error hierarchy
     *  @details The base class of the byeol language err class hierarchy. Includes common logic and interfaces for
     *  error handling.
     *
     *  @section error_concept_vs_implementation Error Concept vs Implementation Gap
     *  Byeol's grammar distinguishes two types of errors. One is known error represented by `?`, and the other is
     *  exception - cases where errors are returned without being specified as an errorable type. However, in
     *  implementation, both are completely identical error objects. Errors are only distinguished by their origin:
     *  @ref nerr generated by @ref parser or @ref verifier in native environment, and @ref err generated by byeol
     *  code.
     *
     *  @section strong_frames_reference err has Strong Reference to frames
     *  Uses this frame to provide callstack information. As explained in @ref frame, frame is created by baseObj
     *  during function calls. Later, frame is `del()`ed by @ref frames, only losing strong references but not
     *  immediately deleted from heap. (In this project, it's extremely rare to directly new/delete on heap without
     *  reference counting via @ref tstr from the memlite module.) Therefore, as long as err lives, the referenced
     *  frame data is also maintained.
     *
     *  @remark err is closely related to @ref errReport. See it if curious.
     *
     *  @section nerr_creation nerr is Mainly Created by __core_when__
     *  nerr is primarily created by core module's @ref __core_when__. Code looks like this:
     *
     *  @code
     *      WHEN_NUL(stmt).exErr(IS_NUL, getReport(), "stmt").ret(blk);
     *  @endcode
     *
     *  The above code means if stmt is nullptr, the IS_NUL error is added to the @ref errReport object returned by
     *  getReport(), and the function terminates while returning blk.
     *
     *  @section dumpable_and_log Dumpable and Log
     *  Logs use the clog module to log the error. Meanwhile, dump() exposes as much information as possible including
     *  callstack.
     *
     *  @section errcode_section errCode
     *  nerr is managed by errCode for management purposes. nerr is mainly generated by @ref parser or @ref verifier,
     *  which helps easily search detailed information by giving codes like `Err2203` along with code 2203 when syntax
     *  errors occur. errCode also simply defines description strings as literal constants for reference.
     */
    class _nout baseErr: public baseObj, public errorable {
        BY(ADT(baseErr, baseObj))
        template <typename T, nbool> friend struct tmarshaling;

    public:
        baseErr(errLv::level t);
        baseErr(const baseErr& rhs);

    public:
        me& operator=(const me& rhs);
        virtual nbool operator==(const me& rhs) const = 0;
        nbool operator!=(const me& rhs) const;

    public:
        const frames& getFrames() const;
        void logStack() const override;
        void dump() const override;
        errLv::level getLv() const override;
        static scope& makeSubs();
        const std::string& getMsg() const override;
        virtual errCode getErrCode() const;

    private:
        void _initStack();
        me& _assign(const me& rhs);

    private:
        tstr<frames> _frames;
        errLv::level _lv;
    };
} // namespace by
